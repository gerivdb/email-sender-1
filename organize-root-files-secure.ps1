# organize-root-files-secure.ps1
# Plan Dev v41 - Phase 1.1.1.2 - Script S√©curis√© avec Protection Multi-Couches
# Version: 2.0 SECURE
# Date: 2025-06-03
# 
# Ce script impl√©mente un syst√®me de protection multi-couches pour l'organisation
# s√©curis√©e des fichiers racine du projet EMAIL_SENDER_1

[CmdletBinding()]
param(
    [Parameter(HelpMessage = "Mode simulation uniquement (aucune modification r√©elle)")]
    [switch]$SimulateOnly,
    
    [Parameter(HelpMessage = "D√©sactiver la confirmation interactive")]
    [switch]$NoConfirmation,
    
    [Parameter(HelpMessage = "Chemin vers le fichier de configuration de protection")]
    [string]$ConfigPath = ".\projet\security\protection-config.json",
    
    [Parameter(HelpMessage = "Dossier de destination pour les fichiers non essentiels")]
    [string]$TargetFolder = "misc"
)

# Configuration globale du script s√©curis√©
$ErrorActionPreference = "Stop"
$InformationPreference = "Continue"

# ===== COUCHE 1: INITIALISATION ET VALIDATION =====

function Initialize-SecureEnvironment {
    [CmdletBinding()]
    param()
    
    Write-Information "üîí INITIALISATION S√âCURIS√âE - organize-root-files-secure v2.0"
    Write-Information "Plan Dev v41 - Syst√®me de protection multi-couches activ√©"
    
    # Validation de l'environnement d'ex√©cution
    $scriptPath = $MyInvocation.ScriptName
    if (-not $scriptPath) {
        $scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Definition
    }
    
    $projectRoot = Split-Path -Parent $scriptPath
    if (-not (Test-Path $projectRoot)) {
        throw "ERREUR CRITIQUE: Impossible de d√©terminer la racine du projet"
    }
    
    Write-Information "‚úÖ Racine du projet valid√©e: $projectRoot"
    
    return @{
        ProjectRoot = $projectRoot
        ScriptPath  = $scriptPath
        Timestamp   = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
        SessionId   = [System.Guid]::NewGuid().ToString().Substring(0, 8)
    }
}

function Get-ProtectionConfiguration {
    [CmdletBinding()]
    param(
        [string]$ConfigPath,
        [string]$ProjectRoot
    )
    
    Write-Information "üìã Chargement de la configuration de protection..."
    
    # Configuration par d√©faut bas√©e sur l'audit de s√©curit√©
    $defaultConfig = @{
        # Fichiers critiques - JAMAIS d√©placer (Audit: 22 fichiers manquants)
        CriticalFiles        = @{
            System   = @('.gitmodules', '.gitignore', '.git', '.github', '.vscode', '.env', '.env.*')
            Config   = @('package.json', 'go.mod', 'go.sum', 'Makefile', 'docker-compose.yml', 'Dockerfile')
            Security = @('*.key', '*.pem', '*.cert', '*.p12', 'secrets.*', 'credentials.*')
            Build    = @('*.sln', '*.csproj', '*.vcxproj', 'CMakeLists.txt', 'build.gradle', 'pom.xml')
            Scripts  = @('organize-*.ps1', '*.sh', '*.bat', '*.cmd')
            Docs     = @('README.*', 'LICENSE*', 'CHANGELOG.*', 'SECURITY.*')
        }
        
        # Extensions √† surveiller
        WatchedExtensions    = @('.ps1', '.sh', '.bat', '.json', '.yml', '.yaml', '.xml', '.md')
        
        # Dossiers interdits d'acc√®s
        ForbiddenDirectories = @('.git', 'node_modules', '.vscode', '.github', 'tools', 'projet')
        
        # Seuils de s√©curit√©
        SecurityThresholds   = @{
            MaxFilesToMove           = 50
            MaxTotalSizeMB           = 100
            RequireConfirmationAbove = 10
        }
    }
    
    # Tentative de chargement du fichier de configuration personnalis√©
    $fullConfigPath = Join-Path $ProjectRoot $ConfigPath
    if (Test-Path $fullConfigPath) {
        try {
            $customConfig = Get-Content $fullConfigPath | ConvertFrom-Json -AsHashtable
            Write-Information "‚úÖ Configuration personnalis√©e charg√©e: $fullConfigPath"
            
            # Fusion des configurations (priorit√© √† la configuration personnalis√©e)
            foreach ($key in $customConfig.Keys) {
                $defaultConfig[$key] = $customConfig[$key]
            }
        }
        catch {
            Write-Warning "‚ö†Ô∏è  Erreur lors du chargement de la configuration: $_"
            Write-Information "üìã Utilisation de la configuration par d√©faut"
        }
    }
    else {
        Write-Information "üìã Configuration par d√©faut utilis√©e (pas de config personnalis√©e)"
    }
    
    return $defaultConfig
}

# ===== COUCHE 2: ANALYSE ET CLASSIFICATION DES FICHIERS =====

function Get-FileClassification {
    [CmdletBinding()]
    param(
        [System.IO.FileInfo]$File,
        [hashtable]$ProtectionConfig
    )
    
    $classification = @{
        File        = $File
        IsCritical  = $false
        IsProtected = $false
        Category    = "Unknown"
        Risk        = "Low"
        CanMove     = $true
        Reason      = ""
    }
    
    # V√©rification dans chaque cat√©gorie de fichiers critiques
    foreach ($category in $ProtectionConfig.CriticalFiles.Keys) {
        foreach ($pattern in $ProtectionConfig.CriticalFiles[$category]) {
            if ($File.Name -like $pattern -or $File.FullName -like "*$pattern*") {
                $classification.IsCritical = $true
                $classification.IsProtected = $true
                $classification.Category = $category
                $classification.Risk = "Critical"
                $classification.CanMove = $false
                $classification.Reason = "Fichier critique ($category): correspond au motif '$pattern'"
                break
            }
        }
        if ($classification.IsCritical) { break }
    }
    
    # V√©rification des extensions surveill√©es
    if (-not $classification.IsCritical) {
        $extension = $File.Extension
        if ($ProtectionConfig.WatchedExtensions -contains $extension) {
            $classification.IsProtected = $true
            $classification.Category = "WatchedExtension"
            $classification.Risk = "Medium"
            $classification.Reason = "Extension surveill√©e: $extension"
        }
    }
    
    # Classification par d√©faut pour les fichiers non prot√©g√©s
    if (-not $classification.IsProtected) {
        $classification.Category = "Movable"
        $classification.Risk = "Low"
        $classification.Reason = "Fichier non critique, peut √™tre d√©plac√©"
    }
    
    return $classification
}

function Invoke-FileAnalysis {
    [CmdletBinding()]
    param(
        [string]$ProjectRoot,
        [hashtable]$ProtectionConfig
    )
    
    Write-Information "üîç ANALYSE DES FICHIERS - Couche de protection active"
    
    $analysis = @{
        TotalFiles      = 0
        ProtectedFiles  = @()
        MovableFiles    = @()
        CriticalFiles   = @()
        SuspiciousFiles = @()
        TotalSizeMB     = 0
        Warnings        = @()
    }
    
    try {
        # R√©cup√©ration s√©curis√©e des fichiers (uniquement racine, pas r√©cursif)
        $allFiles = Get-ChildItem -Path $ProjectRoot -File -ErrorAction Stop
        $analysis.TotalFiles = $allFiles.Count
        
        Write-Information "üìä Analyse de $($analysis.TotalFiles) fichiers dans la racine du projet"
        
        foreach ($file in $allFiles) {
            $classification = Get-FileClassification -File $file -ProtectionConfig $ProtectionConfig
            $fileSizeMB = [math]::Round($file.Length / 1MB, 2)
            $analysis.TotalSizeMB += $fileSizeMB
            
            # Classification et stockage
            switch ($classification.Category) {
                { $_ -in @("System", "Config", "Security", "Build", "Scripts", "Docs") } {
                    $analysis.CriticalFiles += $classification
                    Write-Verbose "üõ°Ô∏è  PROT√âG√â: $($file.Name) - $($classification.Reason)"
                }
                "WatchedExtension" {
                    $analysis.ProtectedFiles += $classification
                    Write-Verbose "‚ö†Ô∏è  SURVEILL√â: $($file.Name) - $($classification.Reason)"
                }
                "Movable" {
                    $analysis.MovableFiles += $classification
                    Write-Verbose "üì¶ D√âPLA√áABLE: $($file.Name) - Taille: ${fileSizeMB}MB"
                }
                default {
                    $analysis.SuspiciousFiles += $classification
                    $analysis.Warnings += "Fichier non classifi√©: $($file.Name)"
                }
            }
            
            # D√©tection de fichiers suspects (taille importante)
            if ($fileSizeMB -gt 10) {
                $analysis.Warnings += "Fichier volumineux d√©tect√©: $($file.Name) (${fileSizeMB}MB)"
            }
        }
        
        Write-Information "‚úÖ Analyse termin√©e:"
        Write-Information "   üõ°Ô∏è  Fichiers critiques prot√©g√©s: $($analysis.CriticalFiles.Count)"
        Write-Information "   ‚ö†Ô∏è  Fichiers surveill√©s: $($analysis.ProtectedFiles.Count)"  
        Write-Information "   üì¶ Fichiers d√©pla√ßables: $($analysis.MovableFiles.Count)"
        Write-Information "   ‚ùì Fichiers suspects: $($analysis.SuspiciousFiles.Count)"
        Write-Information "   üìä Taille totale: $([math]::Round($analysis.TotalSizeMB, 2))MB"
        
    }
    catch {
        throw "ERREUR lors de l'analyse des fichiers: $_"
    }
    
    return $analysis
}

# ===== COUCHE 3: VALIDATION ET SIMULATION =====

function Test-MoveOperationSafety {
    [CmdletBinding()]
    param(
        [array]$FilesToMove,
        [string]$TargetPath,
        [hashtable]$SecurityThresholds
    )
    
    Write-Information "üîí VALIDATION DE S√âCURIT√â - Contr√¥le des op√©rations de d√©placement"
    
    $validation = @{
        IsValid  = $true
        Errors   = @()
        Warnings = @()
        Summary  = @{
            FileCount            = $FilesToMove.Count
            TotalSizeMB          = 0
            RequiresConfirmation = $false
        }
    }
    
    # Calcul de la taille totale
    foreach ($fileClass in $FilesToMove) {
        $validation.Summary.TotalSizeMB += [math]::Round($fileClass.File.Length / 1MB, 2)
    }
    
    # V√©rification des seuils de s√©curit√©
    if ($validation.Summary.FileCount -gt $SecurityThresholds.MaxFilesToMove) {
        $validation.Errors += "Nombre de fichiers exc√®de le seuil autoris√© ($($SecurityThresholds.MaxFilesToMove))"
        $validation.IsValid = $false
    }
    
    if ($validation.Summary.TotalSizeMB -gt $SecurityThresholds.MaxTotalSizeMB) {
        $validation.Errors += "Taille totale exc√®de le seuil autoris√© ($($SecurityThresholds.MaxTotalSizeMB)MB)"
        $validation.IsValid = $false
    }
    
    if ($validation.Summary.FileCount -gt $SecurityThresholds.RequireConfirmationAbove) {
        $validation.Summary.RequiresConfirmation = $true
        $validation.Warnings += "Confirmation requise: nombre de fichiers > $($SecurityThresholds.RequireConfirmationAbove)"
    }
    
    # V√©rification de l'existence du dossier de destination
    if (-not (Test-Path $TargetPath)) {
        $validation.Warnings += "Le dossier de destination sera cr√©√©: $TargetPath"
    }
    
    # D√©tection de conflits potentiels
    if (Test-Path $TargetPath) {
        $existingFiles = Get-ChildItem -Path $TargetPath -File
        foreach ($fileClass in $FilesToMove) {
            if ($existingFiles.Name -contains $fileClass.File.Name) {
                $validation.Warnings += "Conflit potentiel: $($fileClass.File.Name) existe d√©j√† dans la destination"
            }
        }
    }
    
    Write-Information "üìä R√©sum√© de validation:"
    Write-Information "   üìÅ Fichiers √† d√©placer: $($validation.Summary.FileCount)"
    Write-Information "   üìè Taille totale: $([math]::Round($validation.Summary.TotalSizeMB, 2))MB"
    Write-Information "   ‚úÖ Validation: $(if ($validation.IsValid) { 'SUCC√àS' } else { '√âCHEC' })"
    Write-Information "   üîî Confirmation requise: $(if ($validation.Summary.RequiresConfirmation) { 'OUI' } else { 'NON' })"
    
    if ($validation.Errors.Count -gt 0) {
        Write-Warning "‚ùå Erreurs d√©tect√©es:"
        $validation.Errors | ForEach-Object { Write-Warning "   $_" }
    }
    
    if ($validation.Warnings.Count -gt 0) {
        Write-Warning "‚ö†Ô∏è  Avertissements:"
        $validation.Warnings | ForEach-Object { Write-Warning "   $_" }
    }
    
    return $validation
}

function Invoke-SimulationEngine {
    [CmdletBinding()]
    param(
        [array]$FilesToMove,
        [string]$TargetPath,
        [string]$ProjectRoot
    )
    
    Write-Information "üéÆ MOTEUR DE SIMULATION - Test des op√©rations sans modifications"
    
    $simulation = @{
        Success    = $true
        Operations = @()
        Conflicts  = @()
        Errors     = @()
        Summary    = @{
            TotalOperations   = $FilesToMove.Count
            EstimatedDuration = 0
            RiskLevel         = "Low"
        }
    }
    
    # V√©rification de l'int√©grit√© du chemin de destination
    $fullTargetPath = Join-Path $ProjectRoot $TargetPath
    
    foreach ($fileClass in $FilesToMove) {
        $operation = @{
            SourceFile    = $fileClass.File.FullName
            TargetFile    = Join-Path $fullTargetPath $fileClass.File.Name
            Status        = "Pending"
            Risk          = $fileClass.Risk
            EstimatedTime = [math]::Max(1, [math]::Round($fileClass.File.Length / 1MB))
        }
        
        # Simulation des v√©rifications
        try {
            # Test d'acc√®s en lecture au fichier source
            if (-not (Test-Path $operation.SourceFile -PathType Leaf)) {
                $operation.Status = "Error"
                $simulation.Errors += "Fichier source introuvable: $($fileClass.File.Name)"
                $simulation.Success = $false
                continue
            }
            
            # Test de permissions de lecture
            $acl = Get-Acl $operation.SourceFile -ErrorAction Stop
            if (-not $acl) {
                $operation.Status = "Warning"
                $simulation.Conflicts += "Permissions incertaines: $($fileClass.File.Name)"
            }
            
            # V√©rification de conflit de destination
            if (Test-Path $operation.TargetFile) {
                $operation.Status = "Conflict"
                $simulation.Conflicts += "Fichier existe d√©j√†: $($fileClass.File.Name)"
                $simulation.Summary.RiskLevel = "Medium"
            }
            else {
                $operation.Status = "Ready"
            }
            
        }
        catch {
            $operation.Status = "Error"
            $simulation.Errors += "Erreur de simulation pour $($fileClass.File.Name): $_"
            $simulation.Success = $false
        }
        
        $simulation.Operations += $operation
        $simulation.Summary.EstimatedDuration += $operation.EstimatedTime
    }
    
    # Calcul du niveau de risque global
    if ($simulation.Errors.Count -gt 0) {
        $simulation.Summary.RiskLevel = "High"
    }
    elseif ($simulation.Conflicts.Count -gt 2) {
        $simulation.Summary.RiskLevel = "Medium"
    }
    
    Write-Information "üéØ R√©sultats de simulation:"
    Write-Information "   ‚úÖ Succ√®s: $(if ($simulation.Success) { 'OUI' } else { 'NON' })"
    Write-Information "   ‚è±Ô∏è  Dur√©e estim√©e: $($simulation.Summary.EstimatedDuration) secondes"
    Write-Information "   üéöÔ∏è  Niveau de risque: $($simulation.Summary.RiskLevel)"
    Write-Information "   ‚ö†Ô∏è  Conflits: $($simulation.Conflicts.Count)"
    Write-Information "   ‚ùå Erreurs: $($simulation.Errors.Count)"
    
    return $simulation
}# ===== COUCHE 4: INTERFACE UTILISATEUR ET CONFIRMATION =====

function Show-OperationSummary {
    [CmdletBinding()]
    param(
        [hashtable]$Analysis,
        [hashtable]$Validation,
        [hashtable]$Simulation
    )
    
    Write-Host "`n" -NoNewline
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
    Write-Host "‚ïë                    R√âSUM√â DE L'OP√âRATION S√âCURIS√âE                            ‚ïë" -ForegroundColor Green  
    Write-Host "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£" -ForegroundColor Green
    Write-Host "‚ïë Plan Dev v41 - organize-root-files-secure v2.0                                ‚ïë" -ForegroundColor Green
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
    
    Write-Host "`nüîç ANALYSE DES FICHIERS:" -ForegroundColor Cyan
    Write-Host "   üìÅ Total de fichiers analys√©s: $($Analysis.TotalFiles)" -ForegroundColor White
    Write-Host "   üõ°Ô∏è  Fichiers critiques prot√©g√©s: $($Analysis.CriticalFiles.Count)" -ForegroundColor Green
    Write-Host "   ‚ö†Ô∏è  Fichiers surveill√©s: $($Analysis.ProtectedFiles.Count)" -ForegroundColor Yellow
    Write-Host "   üì¶ Fichiers √† d√©placer: $($Analysis.MovableFiles.Count)" -ForegroundColor Blue
    Write-Host "   üìä Taille totale: $([math]::Round($Analysis.TotalSizeMB, 2))MB" -ForegroundColor White
    
    Write-Host "`nüîí VALIDATION DE S√âCURIT√â:" -ForegroundColor Cyan
    $validationColor = if ($Validation.IsValid) { "Green" } else { "Red" }
    Write-Host "   ‚úÖ Statut: $(if ($Validation.IsValid) { 'VALID√â' } else { '√âCHEC' })" -ForegroundColor $validationColor
    Write-Host "   üìä Fichiers √† d√©placer: $($Validation.Summary.FileCount)" -ForegroundColor White
    Write-Host "   üìè Taille totale: $([math]::Round($Validation.Summary.TotalSizeMB, 2))MB" -ForegroundColor White
    Write-Host "   üîî Confirmation requise: $(if ($Validation.Summary.RequiresConfirmation) { 'OUI' } else { 'NON' })" -ForegroundColor White
    
    Write-Host "`nüéÆ SIMULATION:" -ForegroundColor Cyan
    $simColor = if ($Simulation.Success) { "Green" } else { "Red" }
    Write-Host "   üéØ Succ√®s: $(if ($Simulation.Success) { 'OUI' } else { 'NON' })" -ForegroundColor $simColor
    Write-Host "   ‚è±Ô∏è  Dur√©e estim√©e: $($Simulation.Summary.EstimatedDuration) secondes" -ForegroundColor White
    Write-Host "   üéöÔ∏è  Niveau de risque: $($Simulation.Summary.RiskLevel)" -ForegroundColor White
    Write-Host "   ‚ö†Ô∏è  Conflits d√©tect√©s: $($Simulation.Conflicts.Count)" -ForegroundColor $(if ($Simulation.Conflicts.Count -gt 0) { "Yellow" } else { "Green" })
    Write-Host "   ‚ùå Erreurs d√©tect√©es: $($Simulation.Errors.Count)" -ForegroundColor $(if ($Simulation.Errors.Count -gt 0) { "Red" } else { "Green" })
    
    if ($Analysis.Warnings.Count -gt 0) {
        Write-Host "`n‚ö†Ô∏è  AVERTISSEMENTS:" -ForegroundColor Yellow
        $Analysis.Warnings | ForEach-Object { Write-Host "   ‚Ä¢ $_" -ForegroundColor Yellow }
    }
    
    if ($Validation.Errors.Count -gt 0) {
        Write-Host "`n‚ùå ERREURS CRITIQUES:" -ForegroundColor Red
        $Validation.Errors | ForEach-Object { Write-Host "   ‚Ä¢ $_" -ForegroundColor Red }
    }
}

function Request-UserConfirmation {
    [CmdletBinding()]
    param(
        [hashtable]$Analysis,
        [hashtable]$Validation,
        [hashtable]$Simulation,
        [string]$TargetFolder
    )
    
    Show-OperationSummary -Analysis $Analysis -Validation $Validation -Simulation $Simulation
    
    if (-not $Validation.IsValid) {
        Write-Host "`n‚ùå OP√âRATION BLOQU√âE - Erreurs de validation d√©tect√©es" -ForegroundColor Red
        Write-Host "   Veuillez corriger les erreurs avant de continuer." -ForegroundColor Red
        return $false
    }
    
    if ($Analysis.MovableFiles.Count -eq 0) {
        Write-Host "`n‚úÖ AUCUNE ACTION N√âCESSAIRE - Tous les fichiers sont d√©j√† prot√©g√©s ou organis√©s" -ForegroundColor Green
        return $false
    }
    
    Write-Host "`nüìã D√âTAIL DES FICHIERS √Ä D√âPLACER:" -ForegroundColor Cyan
    $Analysis.MovableFiles | Select-Object -First 10 | ForEach-Object {
        $sizeMB = [math]::Round($_.File.Length / 1MB, 2)
        Write-Host "   üìÑ $($_.File.Name) (${sizeMB}MB)" -ForegroundColor White
    }
    
    if ($Analysis.MovableFiles.Count -gt 10) {
        Write-Host "   ... et $($Analysis.MovableFiles.Count - 10) autres fichiers" -ForegroundColor Gray
    }
    
    Write-Host "`nüéØ DESTINATION: $TargetFolder/" -ForegroundColor Cyan
    
    Write-Host "`n" -NoNewline
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Magenta
    Write-Host "‚ïë                               CONFIRMATION REQUISE                            ‚ïë" -ForegroundColor Magenta
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Magenta
    
    do {
        Write-Host "`nVoulez-vous proc√©der au d√©placement des fichiers? " -ForegroundColor Yellow -NoNewline
        Write-Host "[O]ui / [N]on / [D]√©tails / [S]imuler : " -ForegroundColor White -NoNewline
        $response = Read-Host
        
        switch ($response.ToUpper()) {
            "O" { 
                Write-Host "‚úÖ Confirmation re√ßue - Proc√©dure de d√©placement autoris√©e" -ForegroundColor Green
                return $true 
            }
            "N" { 
                Write-Host "‚ùå Op√©ration annul√©e par l'utilisateur" -ForegroundColor Red
                return $false 
            }
            "D" {
                Write-Host "`nüìã LISTE COMPL√àTE DES FICHIERS:" -ForegroundColor Cyan
                $Analysis.MovableFiles | ForEach-Object {
                    $sizeMB = [math]::Round($_.File.Length / 1MB, 2)
                    Write-Host "   üìÑ $($_.File.Name) - ${sizeMB}MB - $($_.Reason)" -ForegroundColor White
                }
            }
            "S" {
                Write-Host "`nüéÆ D√âTAILS DE SIMULATION:" -ForegroundColor Cyan
                $Simulation.Operations | ForEach-Object {
                    $statusColor = switch ($_.Status) {
                        "Ready" { "Green" }
                        "Conflict" { "Yellow" }
                        "Error" { "Red" }
                        default { "White" }
                    }
                    Write-Host "   $($_.Status): $(Split-Path $_.SourceFile -Leaf)" -ForegroundColor $statusColor
                }
            }
            default {
                Write-Host "‚ö†Ô∏è  R√©ponse invalide. Veuillez saisir O, N, D ou S." -ForegroundColor Yellow
            }
        }
    } while ($response.ToUpper() -notin @("O", "N"))
    
    return $false
}

# ===== COUCHE 5: EX√âCUTION S√âCURIS√âE =====

function Invoke-SecureFileMove {
    [CmdletBinding()]
    param(
        [array]$FilesToMove,
        [string]$TargetPath,
        [string]$SessionId
    )
    
    Write-Information "üöÄ EX√âCUTION S√âCURIS√âE - D√©placement des fichiers avec protection"
    
    $execution = @{
        Success    = $true
        MovedFiles = @()
        Errors     = @()
        StartTime  = Get-Date
        SessionId  = $SessionId
    }
    
    # Cr√©ation du dossier de destination avec v√©rification
    if (-not (Test-Path $TargetPath)) {
        try {
            New-Item -ItemType Directory -Path $TargetPath -Force | Out-Null
            Write-Information "üìÅ Dossier de destination cr√©√©: $TargetPath"
        }
        catch {
            $execution.Errors += "Impossible de cr√©er le dossier de destination: $_"
            $execution.Success = $false
            return $execution
        }
    }
    
    $totalFiles = $FilesToMove.Count
    $currentFile = 0
    
    foreach ($fileClass in $FilesToMove) {
        $currentFile++
        $percentComplete = [math]::Round(($currentFile / $totalFiles) * 100)
        
        Write-Progress -Activity "D√©placement s√©curis√© des fichiers" -Status "Traitement: $($fileClass.File.Name)" -PercentComplete $percentComplete
        
        $operation = @{
            SourceFile = $fileClass.File.FullName
            TargetFile = Join-Path $TargetPath $fileClass.File.Name
            Status     = "Pending"
            Timestamp  = Get-Date
            Error      = $null
        }
        
        try {
            # V√©rification finale de s√©curit√©
            if (-not (Test-Path $operation.SourceFile)) {
                throw "Fichier source introuvable"
            }
            
            # V√©rification de conflit
            if (Test-Path $operation.TargetFile) {
                $backupName = "$($fileClass.File.BaseName)_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')$($fileClass.File.Extension)"
                $backupPath = Join-Path $TargetPath $backupName
                Move-Item $operation.TargetFile $backupPath -Force
                Write-Warning "‚ö†Ô∏è  Conflit r√©solu: fichier existant sauvegard√© en $backupName"
            }
            
            # Op√©ration de d√©placement s√©curis√©e
            Move-Item $operation.SourceFile $operation.TargetFile -ErrorAction Stop
            $operation.Status = "Success"
            
            Write-Information "‚úÖ D√©plac√©: $($fileClass.File.Name) -> $TargetPath"
            
        }
        catch {
            $operation.Status = "Error"
            $operation.Error = $_.Exception.Message
            $execution.Errors += "Erreur lors du d√©placement de $($fileClass.File.Name): $_"
            $execution.Success = $false
            
            Write-Error "‚ùå √âchec: $($fileClass.File.Name) - $_"
        }
        
        $execution.MovedFiles += $operation
    }
    
    Write-Progress -Activity "D√©placement s√©curis√© des fichiers" -Completed
    
    $execution.EndTime = Get-Date
    $execution.Duration = $execution.EndTime - $execution.StartTime
    
    Write-Information "üèÅ Ex√©cution termin√©e:"
    Write-Information "   ‚úÖ Fichiers d√©plac√©s avec succ√®s: $(($execution.MovedFiles | Where-Object { $_.Status -eq 'Success' }).Count)"
    Write-Information "   ‚ùå Erreurs rencontr√©es: $($execution.Errors.Count)"
    Write-Information "   ‚è±Ô∏è  Dur√©e totale: $([math]::Round($execution.Duration.TotalSeconds, 2)) secondes"
    
    return $execution
}

# ===== COUCHE 6: LOGGING ET AUDIT =====

function Save-OperationLog {
    [CmdletBinding()]
    param(
        [hashtable]$Environment,
        [hashtable]$Analysis,
        [hashtable]$Validation,
        [hashtable]$Simulation,
        [hashtable]$Execution,
        [bool]$SimulateOnly
    )
    
    $logEntry = @{
        Metadata   = @{
            Timestamp      = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            SessionId      = $Environment.SessionId
            ScriptVersion  = "organize-root-files-secure v2.0"
            PlanDevVersion = "v41"
            Mode           = if ($SimulateOnly) { "SIMULATION" } else { "EXECUTION" }
            ProjectRoot    = $Environment.ProjectRoot
        }
        
        Analysis   = @{
            TotalFiles             = $Analysis.TotalFiles
            CriticalFilesProtected = $Analysis.CriticalFiles.Count
            MovableFiles           = $Analysis.MovableFiles.Count
            TotalSizeMB            = $Analysis.TotalSizeMB
            WarningsCount          = $Analysis.Warnings.Count
        }
        
        Validation = @{
            IsValid              = $Validation.IsValid
            ErrorsCount          = $Validation.Errors.Count
            RequiredConfirmation = $Validation.Summary.RequiresConfirmation
        }
        
        Simulation = @{
            Success           = $Simulation.Success
            RiskLevel         = $Simulation.Summary.RiskLevel
            ConflictsCount    = $Simulation.Conflicts.Count
            EstimatedDuration = $Simulation.Summary.EstimatedDuration
        }
        
        Execution  = if ($Execution) {
            @{
                Success         = $Execution.Success
                MovedFilesCount = ($Execution.MovedFiles | Where-Object { $_.Status -eq 'Success' }).Count
                ErrorsCount     = $Execution.Errors.Count
                DurationSeconds = if ($Execution.Duration) { [math]::Round($Execution.Duration.TotalSeconds, 2) } else { 0 }
            }
        }
        else { $null }
    }
    
    # Sauvegarde dans le fichier de log
    $logDirectory = Join-Path $Environment.ProjectRoot "projet\security\logs"
    if (-not (Test-Path $logDirectory)) {
        New-Item -ItemType Directory -Path $logDirectory -Force | Out-Null
    }
    
    $logFileName = "operation-log_$($Environment.SessionId)_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
    $logPath = Join-Path $logDirectory $logFileName
    
    try {
        $logEntry | ConvertTo-Json -Depth 10 | Out-File $logPath -Encoding UTF8
        Write-Information "üìù Log sauvegard√©: $logPath"
    }
    catch {
        Write-Warning "‚ö†Ô∏è  Impossible de sauvegarder le log: $_"
    }
    
    return $logPath
}

# ===== FONCTION PRINCIPALE =====

function Start-SecureFileOrganization {
    [CmdletBinding()]
    param()
    
    try {
        # Phase 1: Initialisation s√©curis√©e
        $environment = Initialize-SecureEnvironment
        Write-Information "üîß Environment initialized - Session: $($environment.SessionId)"
        
        # Phase 2: Chargement de la configuration
        $protectionConfig = Get-ProtectionConfiguration -ConfigPath $ConfigPath -ProjectRoot $environment.ProjectRoot
        Write-Information "‚öôÔ∏è  Protection configuration loaded"
        
        # Phase 3: Analyse des fichiers
        $analysis = Invoke-FileAnalysis -ProjectRoot $environment.ProjectRoot -ProtectionConfig $protectionConfig
        Write-Information "üîç File analysis completed"
        
        # Phase 4: Validation de s√©curit√©
        $targetPath = Join-Path $environment.ProjectRoot $TargetFolder
        $validation = Test-MoveOperationSafety -FilesToMove $analysis.MovableFiles -TargetPath $targetPath -SecurityThresholds $protectionConfig.SecurityThresholds
        Write-Information "üîí Security validation completed"
        
        # Phase 5: Simulation
        $simulation = Invoke-SimulationEngine -FilesToMove $analysis.MovableFiles -TargetPath $targetPath -ProjectRoot $environment.ProjectRoot
        Write-Information "üéÆ Simulation completed"
        
        # Phase 6: Confirmation utilisateur (si n√©cessaire)
        $userConfirmed = $true
        if (-not $NoConfirmation -and ($validation.Summary.RequiresConfirmation -or $analysis.MovableFiles.Count -gt 0)) {
            $userConfirmed = Request-UserConfirmation -Analysis $analysis -Validation $validation -Simulation $simulation -TargetFolder $TargetFolder
        }
        
        # Phase 7: Ex√©cution ou simulation uniquement
        $execution = $null
        if ($userConfirmed -and -not $SimulateOnly) {
            if ($validation.IsValid) {
                $execution = Invoke-SecureFileMove -FilesToMove $analysis.MovableFiles -TargetPath $targetPath -SessionId $environment.SessionId
                Write-Information "üöÄ Secure execution completed"
            }
            else {
                Write-Error "‚ùå Impossible d'ex√©cuter: √©chec de validation de s√©curit√©"
                return 1
            }
        }
        elseif ($SimulateOnly) {
            Write-Information "üéÆ Mode simulation uniquement - Aucune modification effectu√©e"
        }
        elseif (-not $userConfirmed) {
            Write-Information "üë§ Op√©ration annul√©e par l'utilisateur"
        }
        
        # Phase 8: Logging et audit
        $logPath = Save-OperationLog -Environment $environment -Analysis $analysis -Validation $validation -Simulation $simulation -Execution $execution -SimulateOnly $SimulateOnly
        Write-Information "üìù Operation logged successfully"
        
        # R√©sum√© final
        Write-Host "`n" -NoNewline
        Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
        Write-Host "‚ïë                           OP√âRATION TERMIN√âE                                  ‚ïë" -ForegroundColor Green
        Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
        
        if ($execution) {
            $successCount = ($execution.MovedFiles | Where-Object { $_.Status -eq 'Success' }).Count
            Write-Host "‚úÖ Fichiers d√©plac√©s avec succ√®s: $successCount" -ForegroundColor Green
            if ($execution.Errors.Count -gt 0) {
                Write-Host "‚ùå Erreurs rencontr√©es: $($execution.Errors.Count)" -ForegroundColor Red
            }
        }
        elseif ($SimulateOnly) {
            Write-Host "üéÆ Simulation termin√©e - Aucune modification effectu√©e" -ForegroundColor Blue
        }
        else {
            Write-Host "‚ÑπÔ∏è  Aucune action effectu√©e" -ForegroundColor Yellow
        }
        
        Write-Host "üìù Log de l'op√©ration: $logPath" -ForegroundColor Cyan
        Write-Host "üîí Session s√©curis√©e: $($environment.SessionId)" -ForegroundColor Cyan
        
        return 0
        
    }
    catch {
        Write-Error "üí• ERREUR CRITIQUE: $_"
        Write-Error "   Session: $($environment.SessionId)"
        Write-Error "   Timestamp: $(Get-Date)"
        return 2
    }
}

# ===== POINT D'ENTR√âE =====

# Affichage de l'en-t√™te de s√©curit√©
Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
Write-Host "‚ïë                  ORGANIZE-ROOT-FILES-SECURE v2.0                              ‚ïë" -ForegroundColor Green
Write-Host "‚ïë                     Plan Dev v41 - Phase 1.1.1.2                             ‚ïë" -ForegroundColor Green
Write-Host "‚ïë              Syst√®me de Protection Multi-Couches Activ√©                       ‚ïë" -ForegroundColor Green
Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green

if ($SimulateOnly) {
    Write-Host "üéÆ MODE SIMULATION ACTIV√â - Aucune modification r√©elle ne sera effectu√©e" -ForegroundColor Blue
}

# Ex√©cution du script s√©curis√©
exit (Start-SecureFileOrganization)