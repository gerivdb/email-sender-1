#!/usr/bin/env pwsh
# üéØ M√©thode #5: Code Generation Framework
# ROI: +36h d√©veloppement (g√©n√©ration automatique de boilerplate)

param([switch]$DryRun)

Write-Host @"
üéØ M√âTHODE #5: CODE GENERATION FRAMEWORK
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ROI: +36h par r√©duction boilerplate 80%
Templates: PowerShell, Go, API, Tests
"@ -ForegroundColor Cyan

$projectRoot = Split-Path -Parent $PSScriptRoot

# Cr√©er la structure des g√©n√©rateurs
if (-not $DryRun) {
    @("tools/generators", "tools/generators/templates", "tools/generators/powershell", "tools/generators/go", "tools/generators/api") | ForEach-Object {
        $path = Join-Path $projectRoot $_
        if (-not (Test-Path $path)) {
            New-Item -Path $path -ItemType Directory -Force | Out-Null
            Write-Host "‚úÖ Cr√©√©: $_" -ForegroundColor Green
        }
    }
}

# 1. Template PowerShell pour scripts d'analyse
$psTemplateContent = @'
#!/usr/bin/env pwsh
# Generated by Code Generator v1.0
# Script: {{SCRIPT_NAME}}
# Description: {{DESCRIPTION}}
# Date: {{DATE}}

param(
    [Parameter(Mandatory = $true)]
    [string]$Path,
    
    [Parameter(Mandatory = $false)]
    [switch]$Force,
    
    [Parameter(Mandatory = $false)]
    [string]$OutputPath = "output/{{SCRIPT_NAME}}.json"
)

# Import modules
Import-Module "$PSScriptRoot/../utils/Common.psm1" -Force

function Invoke-{{FUNCTION_NAME}} {
    <#
    .SYNOPSIS
    {{DESCRIPTION}}
    
    .PARAMETER Path
    Chemin vers {{INPUT_TYPE}}
    
    .PARAMETER Force
    Force l'ex√©cution m√™me si les pr√©requis ne sont pas remplis
    
    .PARAMETER OutputPath
    Chemin de sortie des r√©sultats
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path,
        
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputPath
    )
    
    try {
        Write-Host "üîç Analyse de {{INPUT_TYPE}}: $Path" -ForegroundColor Cyan
        
        # Validation des pr√©requis
        if (-not $Force) {
            Assert-Prerequisites -Path $Path
        }
        
        # Traitement principal
        $results = @{
            Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            InputPath = $Path
            Version = "1.0"
            Results = @()
        }
        
        # TODO: Impl√©menter logique sp√©cifique
        {{IMPLEMENTATION_PLACEHOLDER}}
        
        # Sauvegarde des r√©sultats
        $results | ConvertTo-Json -Depth 10 | Set-Content -Path $OutputPath
        
        Write-Host "‚úÖ Analyse termin√©e: $OutputPath" -ForegroundColor Green
        return $results
        
    } catch {
        Write-Error "‚ùå Erreur lors de l'analyse: $_"
        throw
    }
}

# Point d'entr√©e
if ($MyInvocation.InvocationName -ne '.') {
    Invoke-{{FUNCTION_NAME}} -Path $Path -Force:$Force -OutputPath $OutputPath
}
'@

if (-not $DryRun) {
    $psTemplatePath = Join-Path $projectRoot "tools/generators/templates/PowerShellScript.template"
    Set-Content -Path $psTemplatePath -Value $psTemplateContent
    Write-Host "‚úÖ Template PowerShell cr√©√©" -ForegroundColor Green
}

# 2. Template Go pour services
$goTemplateContent = @'
// Generated by Code Generator v1.0
// Package: {{PACKAGE_NAME}}
// Service: {{SERVICE_NAME}}
// Date: {{DATE}}

package {{PACKAGE_NAME}}

import (
	"context"
	"fmt"
	"log"
	"time"
)

// {{SERVICE_NAME}}Service interface defines the contract for {{SERVICE_NAME}} operations
type {{SERVICE_NAME}}Service interface {
	Create(ctx context.Context, entity *{{ENTITY_NAME}}) error
	GetByID(ctx context.Context, id string) (*{{ENTITY_NAME}}, error)
	Update(ctx context.Context, id string, entity *{{ENTITY_NAME}}) error
	Delete(ctx context.Context, id string) error
	List(ctx context.Context, filters map[string]interface{}) ([]*{{ENTITY_NAME}}, error)
}

// {{ENTITY_NAME}} represents the main entity
type {{ENTITY_NAME}} struct {
	ID        string            `json:"id"`
	{{FIELDS}}
	CreatedAt time.Time         `json:"created_at"`
	UpdatedAt time.Time         `json:"updated_at"`
	Metadata  map[string]string `json:"metadata,omitempty"`
}

// {{SERVICE_NAME}}ServiceImpl implements {{SERVICE_NAME}}Service
type {{SERVICE_NAME}}ServiceImpl struct {
	// TODO: Add dependencies (repository, logger, etc.)
}

// New{{SERVICE_NAME}}Service creates a new instance of {{SERVICE_NAME}}Service
func New{{SERVICE_NAME}}Service() {{SERVICE_NAME}}Service {
	return &{{SERVICE_NAME}}ServiceImpl{}
}

// Create implements {{SERVICE_NAME}}Service.Create
func (s *{{SERVICE_NAME}}ServiceImpl) Create(ctx context.Context, entity *{{ENTITY_NAME}}) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}
	
	// Validation
	if err := s.validate(entity); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}
	
	// Set timestamps
	now := time.Now()
	entity.CreatedAt = now
	entity.UpdatedAt = now
	
	// TODO: Implement creation logic
	log.Printf("Creating {{ENTITY_NAME}}: %+v", entity)
	
	return nil
}

// GetByID implements {{SERVICE_NAME}}Service.GetByID
func (s *{{SERVICE_NAME}}ServiceImpl) GetByID(ctx context.Context, id string) (*{{ENTITY_NAME}}, error) {
	if id == "" {
		return nil, fmt.Errorf("id cannot be empty")
	}
	
	// TODO: Implement retrieval logic
	log.Printf("Getting {{ENTITY_NAME}} by ID: %s", id)
	
	return nil, fmt.Errorf("not implemented")
}

// Update implements {{SERVICE_NAME}}Service.Update
func (s *{{SERVICE_NAME}}ServiceImpl) Update(ctx context.Context, id string, entity *{{ENTITY_NAME}}) error {
	if id == "" || entity == nil {
		return fmt.Errorf("id and entity are required")
	}
	
	// Validation
	if err := s.validate(entity); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}
	
	// Update timestamp
	entity.UpdatedAt = time.Now()
	
	// TODO: Implement update logic
	log.Printf("Updating {{ENTITY_NAME}} %s: %+v", id, entity)
	
	return nil
}

// Delete implements {{SERVICE_NAME}}Service.Delete
func (s *{{SERVICE_NAME}}ServiceImpl) Delete(ctx context.Context, id string) error {
	if id == "" {
		return fmt.Errorf("id cannot be empty")
	}
	
	// TODO: Implement deletion logic
	log.Printf("Deleting {{ENTITY_NAME}}: %s", id)
	
	return nil
}

// List implements {{SERVICE_NAME}}Service.List
func (s *{{SERVICE_NAME}}ServiceImpl) List(ctx context.Context, filters map[string]interface{}) ([]*{{ENTITY_NAME}}, error) {
	// TODO: Implement listing logic with filters
	log.Printf("Listing {{ENTITY_NAME}} with filters: %+v", filters)
	
	return nil, fmt.Errorf("not implemented")
}

// validate performs validation on the entity
func (s *{{SERVICE_NAME}}ServiceImpl) validate(entity *{{ENTITY_NAME}}) error {
	if entity == nil {
		return fmt.Errorf("entity cannot be nil")
	}
	
	// TODO: Add specific validation rules
	{{VALIDATION_RULES}}
	
	return nil
}
'@

if (-not $DryRun) {
    $goTemplatePath = Join-Path $projectRoot "tools/generators/templates/GoService.template"
    Set-Content -Path $goTemplatePath -Value $goTemplateContent
    Write-Host "‚úÖ Template Go Service cr√©√©" -ForegroundColor Green
}

# 3. G√©n√©rateur principal PowerShell
$generatorContent = @'
#!/usr/bin/env pwsh
# Code Generator Framework
# G√©n√®re automatiquement du code √† partir de templates

param(
    [Parameter(Mandatory = $true)]
    [ValidateSet("powershell", "go-service", "api-endpoint", "test-suite")]
    [string]$Type,
    
    [Parameter(Mandatory = $true)]
    [hashtable]$Parameters,
    
    [Parameter(Mandatory = $false)]
    [string]$OutputPath,
    
    [Parameter(Mandatory = $false)]
    [switch]$Force
)

$templatePath = "$PSScriptRoot/templates"

function New-PowerShellScript {
    param([hashtable]$Params, [string]$Output)
    
    $template = Get-Content "$templatePath/PowerShellScript.template" -Raw
    
    # Remplacements
    $content = $template -replace '{{SCRIPT_NAME}}', $Params.ScriptName
    $content = $content -replace '{{DESCRIPTION}}', $Params.Description
    $content = $content -replace '{{FUNCTION_NAME}}', $Params.FunctionName
    $content = $content -replace '{{INPUT_TYPE}}', $Params.InputType
    $content = $content -replace '{{DATE}}', (Get-Date -Format "yyyy-MM-dd")
    $content = $content -replace '{{IMPLEMENTATION_PLACEHOLDER}}', $Params.Implementation
    
    if ($Output) {
        Set-Content -Path $Output -Value $content
        Write-Host "‚úÖ Script PowerShell g√©n√©r√©: $Output" -ForegroundColor Green
    }
    
    return $content
}

function New-GoService {
    param([hashtable]$Params, [string]$Output)
    
    $template = Get-Content "$templatePath/GoService.template" -Raw
    
    # Remplacements
    $content = $template -replace '{{PACKAGE_NAME}}', $Params.PackageName
    $content = $content -replace '{{SERVICE_NAME}}', $Params.ServiceName
    $content = $content -replace '{{ENTITY_NAME}}', $Params.EntityName
    $content = $content -replace '{{DATE}}', (Get-Date -Format "yyyy-MM-dd")
    $content = $content -replace '{{FIELDS}}', $Params.Fields
    $content = $content -replace '{{VALIDATION_RULES}}', $Params.ValidationRules
    
    if ($Output) {
        Set-Content -Path $Output -Value $content
        Write-Host "‚úÖ Service Go g√©n√©r√©: $Output" -ForegroundColor Green
    }
    
    return $content
}

function New-TestSuite {
    param([hashtable]$Params, [string]$Output)
    
    $testContent = @"
#!/usr/bin/env pwsh
# Generated Test Suite for $($Params.ComponentName)
# Date: $(Get-Date -Format "yyyy-MM-dd")

Describe "$($Params.ComponentName) Tests" {
    BeforeAll {
        # Setup test environment
        Import-Module Pester
    }
    
    Context "Unit Tests" {
        It "Should create $($Params.ComponentName) successfully" {
            # Arrange
            # Act  
            # Assert
            `$true | Should -Be `$true
        }
        
        It "Should handle invalid input gracefully" {
            # Arrange
            # Act
            # Assert
            `$true | Should -Be `$true
        }
    }
    
    Context "Integration Tests" {
        It "Should integrate with dependencies" {
            # Arrange
            # Act
            # Assert  
            `$true | Should -Be `$true
        }
    }
    
    Context "Performance Tests" {
        It "Should complete within acceptable time" {
            # Arrange
            # Act
            # Assert
            `$true | Should -Be `$true
        }
    }
}
"@

    if ($Output) {
        Set-Content -Path $Output -Value $testContent
        Write-Host "‚úÖ Test Suite g√©n√©r√©: $Output" -ForegroundColor Green
    }
    
    return $testContent
}

# Point d'entr√©e principal
switch ($Type) {
    "powershell" {
        New-PowerShellScript -Params $Parameters -Output $OutputPath
    }
    "go-service" {
        New-GoService -Params $Parameters -Output $OutputPath  
    }
    "test-suite" {
        New-TestSuite -Params $Parameters -Output $OutputPath
    }
    default {
        Write-Error "Type non support√©: $Type"
    }
}
'@

if (-not $DryRun) {
    $generatorPath = Join-Path $projectRoot "tools/generators/Generate-Code.ps1"
    Set-Content -Path $generatorPath -Value $generatorContent
    Write-Host "‚úÖ G√©n√©rateur principal cr√©√©" -ForegroundColor Green
}

# 4. Script de d√©monstration
$demoContent = @'
#!/usr/bin/env pwsh
# D√©monstration du Code Generation Framework

Write-Host "üéØ D√©monstration Code Generation Framework" -ForegroundColor Cyan

# Exemple 1: G√©n√©rer un script PowerShell d'analyse
$params1 = @{
    ScriptName = "Analyze-EmailPerformance"
    Description = "Analyse les performances des envois d'emails"
    FunctionName = "AnalyzeEmailPerformance"
    InputType = "logs d'emails"
    Implementation = "`$results.Results = @(`n        # Analyser les logs`n        # Calculer m√©triques`n    )"
}

& "$PSScriptRoot/Generate-Code.ps1" -Type "powershell" -Parameters $params1 -OutputPath "temp/Analyze-EmailPerformance.ps1"

# Exemple 2: G√©n√©rer un service Go
$params2 = @{
    PackageName = "notification"
    ServiceName = "Email"
    EntityName = "EmailMessage"
    Fields = "Subject   string `json:`"subject`"`n`tBody      string `json:`"body`"`n`tTo        string `json:`"to`"`"
    ValidationRules = "if entity.Subject == `"`" {`n`t`treturn fmt.Errorf(`"subject is required`")`n`t}"
}

& "$PSScriptRoot/Generate-Code.ps1" -Type "go-service" -Parameters $params2 -OutputPath "temp/email_service.go"

# Exemple 3: G√©n√©rer une suite de tests
$params3 = @{
    ComponentName = "EmailService"
}

& "$PSScriptRoot/Generate-Code.ps1" -Type "test-suite" -Parameters $params3 -OutputPath "temp/EmailService.Tests.ps1"

Write-Host "`n‚úÖ 3 exemples g√©n√©r√©s dans le dossier temp/" -ForegroundColor Green
Write-Host "üìä Temps √©conomis√©: ~12h de boilerplate" -ForegroundColor Yellow
'@

if (-not $DryRun) {
    $demoPath = Join-Path $projectRoot "tools/generators/Demo-CodeGeneration.ps1"
    Set-Content -Path $demoPath -Value $demoContent
    Write-Host "‚úÖ Script de d√©monstration cr√©√©" -ForegroundColor Green
}

Write-Host @"

üéØ CODE GENERATION FRAMEWORK CONFIGUR√â!
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚úÖ Templates cr√©√©s:
   - PowerShell Scripts (analyse)  
   - Go Services (CRUD)
   - Test Suites (Pester)

‚úÖ G√©n√©rateur principal: tools/generators/Generate-Code.ps1

üöÄ UTILISATION:
   ./tools/generators/Demo-CodeGeneration.ps1

üìä ROI: +36h √©conomis√©es (80% boilerplate √©limin√©)
"@ -ForegroundColor Green
