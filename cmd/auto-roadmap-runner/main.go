package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// ExecutionStep repr√©sente une √©tape d'ex√©cution
type ExecutionStep struct {
	Name        string   `json:"name"`
	Command     string   `json:"command"`
	Args        []string `json:"args"`
	Description string   `json:"description"`
	Required    bool     `json:"required"`
	Timeout     int      `json:"timeout_seconds"`
}

// ExecutionResult repr√©sente le r√©sultat d'une √©tape
type ExecutionResult struct {
	Step      ExecutionStep `json:"step"`
	Success   bool          `json:"success"`
	Output    string        `json:"output"`
	Error     string        `json:"error,omitempty"`
	Duration  time.Duration `json:"duration"`
	StartTime time.Time     `json:"start_time"`
	EndTime   time.Time     `json:"end_time"`
}

// RoadmapExecution repr√©sente l'ex√©cution compl√®te de la roadmap
type RoadmapExecution struct {
	StartTime      time.Time         `json:"start_time"`
	EndTime        time.Time         `json:"end_time"`
	TotalDuration  time.Duration     `json:"total_duration"`
	Steps          []ExecutionStep   `json:"steps"`
	Results        []ExecutionResult `json:"results"`
	SuccessCount   int               `json:"success_count"`
	FailureCount   int               `json:"failure_count"`
	OverallSuccess bool              `json:"overall_success"`
	Summary        string            `json:"summary"`
}

// getExecutionSteps retourne les √©tapes √† ex√©cuter selon le plan v72
func getExecutionSteps() []ExecutionStep {
	return []ExecutionStep{
		{
			Name:        "module-scan",
			Command:     "go",
			Args:        []string{"run", "core/scanmodules/scanmodules.go"},
			Description: "Scanner les modules et g√©n√©rer la structure du d√©p√¥t",
			Required:    true,
			Timeout:     30,
		},
		{
			Name:        "gap-analysis",
			Command:     "go",
			Args:        []string{"run", "cmd/gapanalyzer/main.go", "-input", "modules.json", "-output", "gap-analysis.json"},
			Description: "Analyser les √©carts entre modules attendus et existants",
			Required:    true,
			Timeout:     30,
		},
{
Name:        "needs-analysis",
Command:     "go",
Args:        []string{"run", "cmd/reporting/main.go", "-input", "issues.json", "-output", "besoins.json", "--mode", "needs"},
Description: "Analyser les besoins √† partir des issues/tickets",
Required:    true,
Timeout:     30,
},
{
Name:        "spec-generation",
Command:     "go",
Args:        []string{"run", "cmd/reporting/main.go", "-input", "besoins.json", "-output", "spec.json", "--mode", "spec"},
Description: "G√©n√©rer les sp√©cifications techniques d√©taill√©es",
Required:    true,
Timeout:     30,
},
		{
			Name:        "build-test",
			Command:     "go",
			Args:        []string{"build", "./..."},
			Description: "Construire tous les modules Go",
			Required:    true,
			Timeout:     60,
		},
		{
			Name:        "unit-tests",
			Command:     "go",
			Args:        []string{"test", "./...", "-v"},
			Description: "Ex√©cuter tous les tests unitaires",
			Required:    false,
			Timeout:     120,
		},
		{
			Name:        "coverage-report",
			Command:     "go",
			Args:        []string{"test", "./...", "-coverprofile=coverage.out"},
			Description: "G√©n√©rer le rapport de couverture de code",
			Required:    false,
			Timeout:     120,
		},
		{
			Name:        "tidy-dependencies",
			Command:     "go",
			Args:        []string{"mod", "tidy"},
			Description: "Nettoyer et organiser les d√©pendances Go",
			Required:    true,
			Timeout:     30,
		},
	}
}

// executeStep ex√©cute une √©tape et retourne le r√©sultat
func executeStep(step ExecutionStep) ExecutionResult {
	fmt.Printf("üîÑ Ex√©cution: %s - %s\n", step.Name, step.Description)

	result := ExecutionResult{
		Step:      step,
		StartTime: time.Now(),
	}

	// Cr√©er la commande
	cmd := exec.Command(step.Command, step.Args...)
	cmd.Dir = "." // Ex√©cuter dans le r√©pertoire courant

	// Configurer le timeout si sp√©cifi√©
	if step.Timeout > 0 {
		// Note: Pour un vrai timeout, on devrait utiliser context.WithTimeout
		// Ici on fait une impl√©mentation simplifi√©e
	}

	// Ex√©cuter la commande
	output, err := cmd.CombinedOutput()
	result.EndTime = time.Now()
	result.Duration = result.EndTime.Sub(result.StartTime)
	result.Output = string(output)

	if err != nil {
		result.Success = false
		result.Error = err.Error()
		fmt.Printf("‚ùå √âchec: %s (dur√©e: %v)\n", step.Name, result.Duration)
		fmt.Printf("   Erreur: %s\n", err.Error())
		if len(result.Output) > 0 {
			fmt.Printf("   Sortie: %s\n", strings.TrimSpace(result.Output))
		}
	} else {
		result.Success = true
		fmt.Printf("‚úÖ Succ√®s: %s (dur√©e: %v)\n", step.Name, result.Duration)
	}

	return result
}

// executeRoadmap ex√©cute toute la roadmap
func executeRoadmap(steps []ExecutionStep, continueOnFailure bool) RoadmapExecution {
	execution := RoadmapExecution{
		StartTime: time.Now(),
		Steps:     steps,
		Results:   []ExecutionResult{},
	}

	fmt.Println("üöÄ D√©marrage de l'ex√©cution de la roadmap v72")
	fmt.Printf("üìÖ Heure de d√©but: %s\n", execution.StartTime.Format("2006-01-02 15:04:05"))
	fmt.Printf("üìã √âtapes √† ex√©cuter: %d\n", len(steps))

	for i, step := range steps {
		fmt.Printf("\n[%d/%d] ", i+1, len(steps))
		result := executeStep(step)
		execution.Results = append(execution.Results, result)

		if result.Success {
			execution.SuccessCount++
		} else {
			execution.FailureCount++
			if step.Required && !continueOnFailure {
				fmt.Printf("\nüõë Arr√™t de l'ex√©cution: √©tape requise '%s' a √©chou√©\n", step.Name)
				break
			}
		}
	}

	execution.EndTime = time.Now()
	execution.TotalDuration = execution.EndTime.Sub(execution.StartTime)
	execution.OverallSuccess = execution.FailureCount == 0

	// G√©n√©rer le r√©sum√©
	if execution.OverallSuccess {
		execution.Summary = fmt.Sprintf("Roadmap ex√©cut√©e avec succ√®s! %d/%d √©tapes r√©ussies en %v",
			execution.SuccessCount, len(execution.Results), execution.TotalDuration)
	} else {
		execution.Summary = fmt.Sprintf("Roadmap termin√©e avec des erreurs. %d succ√®s, %d √©checs sur %d √©tapes en %v",
			execution.SuccessCount, execution.FailureCount, len(execution.Results), execution.TotalDuration)
	}

	return execution
}

// generateExecutionReport g√©n√®re un rapport d√©taill√© d'ex√©cution
func generateExecutionReport(execution RoadmapExecution) string {
	var report strings.Builder

	report.WriteString("# üöÄ Rapport d'Ex√©cution de la Roadmap v72\n\n")
	report.WriteString(fmt.Sprintf("**Date d'ex√©cution:** %s\n", execution.StartTime.Format("2006-01-02 15:04:05")))
	report.WriteString(fmt.Sprintf("**Dur√©e totale:** %v\n", execution.TotalDuration))
	report.WriteString(fmt.Sprintf("**Statut g√©n√©ral:** %s\n\n", map[bool]string{true: "‚úÖ Succ√®s", false: "‚ùå √âchec"}[execution.OverallSuccess]))

	// R√©sum√©
	report.WriteString("## üìä R√©sum√©\n\n")
	report.WriteString(fmt.Sprintf("- **√âtapes ex√©cut√©es:** %d\n", len(execution.Results)))
	report.WriteString(fmt.Sprintf("- **Succ√®s:** %d\n", execution.SuccessCount))
	report.WriteString(fmt.Sprintf("- **√âchecs:** %d\n", execution.FailureCount))
	report.WriteString(fmt.Sprintf("- **Taux de r√©ussite:** %.1f%%\n\n",
		float64(execution.SuccessCount)/float64(len(execution.Results))*100))

	// D√©tail des √©tapes
	report.WriteString("## üìù D√©tail des √âtapes\n\n")
	for i, result := range execution.Results {
		status := "‚úÖ"
		if !result.Success {
			status = "‚ùå"
		}
		report.WriteString(fmt.Sprintf("### %d. %s %s\n\n", i+1, status, result.Step.Name))
		report.WriteString(fmt.Sprintf("- **Description:** %s\n", result.Step.Description))
		report.WriteString(fmt.Sprintf("- **Commande:** `%s %s`\n", result.Step.Command, strings.Join(result.Step.Args, " ")))
		report.WriteString(fmt.Sprintf("- **Dur√©e:** %v\n", result.Duration))
		report.WriteString(fmt.Sprintf("- **Statut:** %s\n", map[bool]string{true: "Succ√®s", false: "√âchec"}[result.Success]))

		if !result.Success && result.Error != "" {
			report.WriteString(fmt.Sprintf("- **Erreur:** %s\n", result.Error))
		}

		if result.Output != "" {
			output := strings.TrimSpace(result.Output)
			if len(output) > 500 { // Limiter la sortie
				output = output[:500] + "... (tronqu√©)"
			}
			report.WriteString(fmt.Sprintf("- **Sortie:**\n```\n%s\n```\n", output))
		}
		report.WriteString("\n")
	}

	// Recommandations
	report.WriteString("## üéØ Recommandations\n\n")
	if execution.OverallSuccess {
		report.WriteString("üéâ **Excellent!** Toutes les √©tapes ont √©t√© ex√©cut√©es avec succ√®s.\n\n")
		report.WriteString("**Prochaines √©tapes sugg√©r√©es:**\n")
		report.WriteString("1. V√©rifier les rapports g√©n√©r√©s (gap-analysis.md, BESOINS_INITIAUX.md)\n")
		report.WriteString("2. Impl√©menter les modules manquants identifi√©s\n")
		report.WriteString("3. Configurer la CI/CD pour l'automatisation\n")
	} else {
		report.WriteString("‚ö†Ô∏è **Attention!** Certaines √©tapes ont √©chou√©.\n\n")
		report.WriteString("**Actions recommand√©es:**\n")
		for _, result := range execution.Results {
			if !result.Success {
				report.WriteString(fmt.Sprintf("- Corriger l'erreur dans '%s': %s\n", result.Step.Name, result.Error))
			}
		}
	}

	return report.String()
}

// saveResults sauvegarde les r√©sultats d'ex√©cution
func saveResults(execution RoadmapExecution) error {
	// Sauvegarder en JSON
	jsonData, err := json.MarshalIndent(execution, "", "  ")
	if err != nil {
		return fmt.Errorf("erreur lors de la s√©rialisation JSON: %v", err)
	}

	timestamp := execution.StartTime.Format("2006-01-02_15-04-05")
	jsonFile := fmt.Sprintf("roadmap-execution_%s.json", timestamp)
	err = ioutil.WriteFile(jsonFile, jsonData, 0o644)
	if err != nil {
		return fmt.Errorf("erreur lors de l'√©criture du fichier JSON: %v", err)
	}

	// G√©n√©rer et sauvegarder le rapport Markdown
	report := generateExecutionReport(execution)
	markdownFile := fmt.Sprintf("ROADMAP_EXECUTION_REPORT_%s.md", timestamp)
	err = ioutil.WriteFile(markdownFile, []byte(report), 0o644)
	if err != nil {
		return fmt.Errorf("erreur lors de l'√©criture du rapport Markdown: %v", err)
	}

	fmt.Printf("üìÑ Fichiers g√©n√©r√©s:\n")
	fmt.Printf("   - %s (r√©sultats JSON)\n", jsonFile)
	fmt.Printf("   - %s (rapport Markdown)\n", markdownFile)

	return nil
}

// createBackup cr√©e une sauvegarde des fichiers importants
func createBackup() error {
	backupDir := fmt.Sprintf("backup_%s", time.Now().Format("2006-01-02_15-04-05"))
	err := os.MkdirAll(backupDir, 0o755)
	if err != nil {
		return fmt.Errorf("erreur lors de la cr√©ation du dossier de sauvegarde: %v", err)
	}

	// Fichiers √† sauvegarder
	filesToBackup := []string{
		"modules.json",
		"gap-analysis.json",
		"besoins.json",
		"arborescence.txt",
		"modules.txt",
	}

	for _, file := range filesToBackup {
		if _, err := os.Stat(file); err == nil {
			// Le fichier existe, le copier
			src := file
			dst := filepath.Join(backupDir, file)

			data, err := ioutil.ReadFile(src)
			if err != nil {
				log.Printf("‚ö†Ô∏è Impossible de lire %s: %v", src, err)
				continue
			}
			err = ioutil.WriteFile(dst, data, 0o644)
			if err != nil {
				log.Printf("‚ö†Ô∏è Impossible de sauvegarder %s: %v", file, err)
				continue
			}
		}
	}

	fmt.Printf("üíæ Sauvegarde cr√©√©e dans: %s\n", backupDir)
	return nil
}

func main() {
	// D√©finir les flags de ligne de commande
	continueOnFailure := flag.Bool("continue", false, "Continuer l'ex√©cution m√™me en cas d'√©chec d'une √©tape requise")
	backup := flag.Bool("backup", true, "Cr√©er une sauvegarde avant l'ex√©cution")
	flag.Parse()

	fmt.Println("üéØ === Orchestrateur Global de la Roadmap v72 ===")
	fmt.Printf("‚öôÔ∏è Options: continue-on-failure=%v, backup=%v\n", *continueOnFailure, *backup)

	// Cr√©er une sauvegarde si demand√©
	if *backup {
		fmt.Println("\nüíæ Cr√©ation de la sauvegarde...")
		if err := createBackup(); err != nil {
			log.Printf("‚ö†Ô∏è Erreur lors de la sauvegarde: %v", err)
		}
	}

	// Obtenir les √©tapes d'ex√©cution
	steps := getExecutionSteps()

	// Ex√©cuter la roadmap
	execution := executeRoadmap(steps, *continueOnFailure)

	// Afficher le r√©sum√©
	fmt.Printf("\nüéâ === R√©sum√© de l'Ex√©cution ===\n")
	fmt.Printf("üìä %s\n", execution.Summary)
	fmt.Printf("‚è±Ô∏è Dur√©e totale: %v\n", execution.TotalDuration)

	if execution.OverallSuccess {
		fmt.Printf("üéâ Statut: SUCC√àS COMPLET\n")
	} else {
		fmt.Printf("‚ö†Ô∏è Statut: TERMIN√â AVEC ERREURS\n")
	}

	// Sauvegarder les r√©sultats
	fmt.Println("\nüìÑ Sauvegarde des r√©sultats...")
	if err := saveResults(execution); err != nil {
		log.Printf("‚ùå Erreur lors de la sauvegarde des r√©sultats: %v", err)
	}

	// Code de sortie
	if execution.OverallSuccess {
		fmt.Println("\n‚ú® Roadmap ex√©cut√©e avec succ√®s!")
		os.Exit(0)
	} else {
		fmt.Println("\n‚ö†Ô∏è Roadmap termin√©e avec des erreurs")
		os.Exit(1)
	}
}

</file_content>

Now that you have the latest state of the file, try the operation again with fewer, more precise SEARCH blocks. For large files especially, it may be prudent to try to limit yourself to <5 SEARCH/REPLACE blocks at a time, then wait for the user to respond with the result of the operation before following up with another replace_in_file call to make additional edits.
(If you run into this error 3 times in a row, you may use the write_to_file tool as a fallback.)
</error><environment_details>
# VSCode Visible Files
C:/response_af2ed764-9490-4c99-4d4e-79e26a154c3b/1
C:/response_f50ce7ce-f1e8-4644-b590-a5507990143a/0
C:/response_dcde6e9b-6f7d-4412-8a7d-6ea37c5e34bd/tools-0
C:/response_cd91b4c2-2838-410f-9d8e-874f5cf38b10/tools-0
core/gapanalyzer/main.go

# VSCode Open Tabs
core/reporting/spec.go
projet/roadmaps/plans/consolidated/plan-dev-v72-fusion-doc-manager-extensions-hybride.md
core/gapanalyzer/gapanalyzer.go
core/gapanalyzer/gapanalyzer_test.go
core/gapanalyzer/main.go

# Actively Running Terminals
## Original command: `git commit -m "fix: Resolve package conflicts and Go version issues

- Remove conflicting reportgen.go file
- Fix package declarations in test files (main instead of package names)
- Update Go workspace to use correct version (1.24.4)
- Clean up module dependencies with go mod tidy

Remaining issues to address:
- Function name conflicts between needs.go and spec.go
- Test dependencies that need to be updated
- Some modules pass tests (scanmodules ‚úÖ) others need fixes"`

# Current Time
7/1/2025, 11:58:19 AM (Europe/Paris, UTC+2:00)

# Context Window Usage
353,065 / 1,048.576K tokens used (34%)

# Current Mode
ACT MODE
</environment_details>
