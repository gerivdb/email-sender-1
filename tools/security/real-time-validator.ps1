# Real-Time Validation System - Plan Dev v41
# Phase 1.1.1.2 - Syst√®me de validation en temps r√©el
# Version: 1.0
# Date: 2025-06-03

[CmdletBinding()]
param(
    [Parameter(Mandatory = $true)]
    [string]$OperationLogPath,
    
    [Parameter(Mandatory = $true)]
    [string]$ProjectRoot,
    
    [switch]$ContinuousMonitoring,
    
    [int]$MonitoringIntervalSeconds = 30,
    
    [string]$AlertThreshold = "Medium"
)

# Configuration de validation en temps r√©el
$ValidationRules = @{
    FileIntegrity = @{
        RequiredFiles = @('.gitignore', 'package.json', 'go.mod', 'README.md')
        ForbiddenPatterns = @('*.tmp', '*.log', 'temp*', 'debug*')
        MaxFileSize = 50MB
        ChecksumValidation = $true
    }
    
    DirectoryStructure = @{
        ProtectedDirectories = @('.git', '.github', '.vscode', 'tools', 'projet')
        RequiredDirectories = @('src', 'cmd', 'internal')
        MaxDepth = 10
    }
    
    SecurityCompliance = @{
        NoExecutablesInRoot = $true
        NoSecretsInPlainText = $true
        RequireSecurePatterns = $true
        EnforceGitignore = $true
    }
    
    PerformanceMetrics = @{
        MaxProcessingTime = 300  # 5 minutes
        MaxMemoryUsage = 1GB
        MinDiskSpace = 5GB
    }
}

function Initialize-RealTimeValidator {
    [CmdletBinding()]
    param()
    
    Write-Information "üîÑ INITIALISATION DU SYST√àME DE VALIDATION TEMPS R√âEL"
    Write-Information "Plan Dev v41 - Phase 1.1.1.2 - Validation System v1.0"
    
    # V√©rification des pr√©requis
    if (-not (Test-Path $ProjectRoot)) {
        throw "Racine du projet introuvable: $ProjectRoot"
    }
    
    # Cr√©ation du r√©pertoire de validation
    $validationDir = Join-Path $ProjectRoot "projet\security\validation"
    if (-not (Test-Path $validationDir)) {
        New-Item -ItemType Directory -Path $validationDir -Force | Out-Null
        Write-Information "üìÅ R√©pertoire de validation cr√©√©: $validationDir"
    }
    
    return @{
        ValidationDirectory = $validationDir
        StartTime = Get-Date
        SessionId = [System.Guid]::NewGuid().ToString().Substring(0,8)
        Rules = $ValidationRules
    }
}

function Test-FileIntegrity {
    [CmdletBinding()]
    param(
        [string]$ProjectRoot,
        [hashtable]$Rules
    )
    
    Write-Verbose "üîç V√©rification de l'int√©grit√© des fichiers..."
    
    $results = @{
        Status = "Valid"
        Issues = @()
        Details = @()
    }
    
    # V√©rification des fichiers requis
    foreach ($requiredFile in $Rules.FileIntegrity.RequiredFiles) {
        $filePath = Join-Path $ProjectRoot $requiredFile
        if (-not (Test-Path $filePath)) {
            $results.Issues += "Fichier requis manquant: $requiredFile"
            $results.Status = "Invalid"
        }
        else {
            $results.Details += "‚úÖ Fichier requis pr√©sent: $requiredFile"
        }
    }
    
    # V√©rification des patterns interdits
    foreach ($pattern in $Rules.FileIntegrity.ForbiddenPatterns) {
        $forbiddenFiles = Get-ChildItem -Path $ProjectRoot -Filter $pattern -File -ErrorAction SilentlyContinue
        if ($forbiddenFiles) {
            foreach ($file in $forbiddenFiles) {
                $results.Issues += "Fichier interdit d√©tect√©: $($file.Name)"
                $results.Status = "Invalid"
            }
        }
    }
    
    # V√©rification de la taille des fichiers
    $largeFiles = Get-ChildItem -Path $ProjectRoot -File | Where-Object { $_.Length -gt $Rules.FileIntegrity.MaxFileSize }
    foreach ($file in $largeFiles) {
        $sizeMB = [math]::Round($file.Length / 1MB, 2)
        $results.Issues += "Fichier trop volumineux: $($file.Name) (${sizeMB}MB)"
        $results.Status = "Warning"
    }
    
    return $results
}

function Test-DirectoryStructure {
    [CmdletBinding()]
    param(
        [string]$ProjectRoot,
        [hashtable]$Rules
    )
    
    Write-Verbose "üìÅ V√©rification de la structure des r√©pertoires..."
    
    $results = @{
        Status = "Valid"
        Issues = @()
        Details = @()
    }
    
    # V√©rification des r√©pertoires prot√©g√©s
    foreach ($protectedDir in $Rules.DirectoryStructure.ProtectedDirectories) {
        $dirPath = Join-Path $ProjectRoot $protectedDir
        if (Test-Path $dirPath) {
            $results.Details += "üõ°Ô∏è  R√©pertoire prot√©g√© intact: $protectedDir"
        }
        else {
            $results.Issues += "R√©pertoire prot√©g√© manquant: $protectedDir"
            $results.Status = "Warning"
        }
    }
    
    # V√©rification des r√©pertoires requis
    foreach ($requiredDir in $Rules.DirectoryStructure.RequiredDirectories) {
        $dirPath = Join-Path $ProjectRoot $requiredDir
        if (-not (Test-Path $dirPath)) {
            $results.Issues += "R√©pertoire requis manquant: $requiredDir"
            $results.Status = "Invalid"
        }
        else {
            $results.Details += "‚úÖ R√©pertoire requis pr√©sent: $requiredDir"
        }
    }
    
    # V√©rification de la profondeur maximale
    try {
        $deepPaths = Get-ChildItem -Path $ProjectRoot -Recurse -Directory -ErrorAction SilentlyContinue | 
                     Where-Object { ($_.FullName -replace [regex]::Escape($ProjectRoot)).Split([IO.Path]::DirectorySeparatorChar).Count -gt $Rules.DirectoryStructure.MaxDepth }
        
        foreach ($deepPath in $deepPaths) {
            $depth = ($deepPath.FullName -replace [regex]::Escape($ProjectRoot)).Split([IO.Path]::DirectorySeparatorChar).Count
            $results.Issues += "R√©pertoire trop profond: $($deepPath.Name) (profondeur: $depth)"
            $results.Status = "Warning"
        }
    }
    catch {
        $results.Issues += "Erreur lors de la v√©rification de profondeur: $_"
        $results.Status = "Warning"
    }
    
    return $results
}

function Test-SecurityCompliance {
    [CmdletBinding()]
    param(
        [string]$ProjectRoot,
        [hashtable]$Rules
    )
    
    Write-Verbose "üîí V√©rification de la conformit√© s√©curitaire..."
    
    $results = @{
        Status = "Valid"
        Issues = @()
        Details = @()
    }
    
    # V√©rification: pas d'ex√©cutables dans la racine
    if ($Rules.SecurityCompliance.NoExecutablesInRoot) {
        $executables = Get-ChildItem -Path $ProjectRoot -Filter "*.exe" -File
        foreach ($exe in $executables) {
            $results.Issues += "Ex√©cutable d√©tect√© dans la racine: $($exe.Name)"
            $results.Status = "Warning"
        }
        
        if ($executables.Count -eq 0) {
            $results.Details += "‚úÖ Aucun ex√©cutable dans la racine"
        }
    }
    
    # V√©rification: pas de secrets en texte clair
    if ($Rules.SecurityCompliance.NoSecretsInPlainText) {
        $secretPatterns = @("password", "secret", "token", "key", "api", "auth")
        $textFiles = Get-ChildItem -Path $ProjectRoot -Include "*.txt", "*.md", "*.json", "*.yaml", "*.yml" -File
        
        foreach ($file in $textFiles) {
            try {
                $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
                foreach ($pattern in $secretPatterns) {
                    if ($content -and $content -match $pattern) {
                        $results.Issues += "Potentiel secret d√©tect√© dans: $($file.Name)"
                        $results.Status = "Warning"
                        break
                    }
                }
            }
            catch {
                # Ignorer les fichiers non lisibles
            }
        }
    }
    
    # V√©rification: .gitignore pr√©sent et fonctionnel
    if ($Rules.SecurityCompliance.EnforceGitignore) {
        $gitignorePath = Join-Path $ProjectRoot ".gitignore"
        if (Test-Path $gitignorePath) {
            $results.Details += "‚úÖ .gitignore pr√©sent"
            
            # V√©rifier si .gitignore contient des r√®gles importantes
            $gitignoreContent = Get-Content $gitignorePath -Raw
            $importantRules = @("*.exe", "*.log", "node_modules", ".env")
            
            foreach ($rule in $importantRules) {
                if ($gitignoreContent -notmatch [regex]::Escape($rule)) {
                    $results.Issues += ".gitignore ne contient pas la r√®gle: $rule"
                    $results.Status = "Warning"
                }
            }
        }
        else {
            $results.Issues += "Fichier .gitignore manquant"
            $results.Status = "Invalid"
        }
    }
    
    return $results
}

function Test-PerformanceMetrics {
    [CmdletBinding()]
    param(
        [string]$ProjectRoot,
        [hashtable]$Rules,
        [datetime]$StartTime
    )
    
    Write-Verbose "üìä V√©rification des m√©triques de performance..."
    
    $results = @{
        Status = "Valid"
        Issues = @()
        Details = @()
        Metrics = @{}
    }
    
    # Temps de traitement
    $elapsedTime = (Get-Date) - $StartTime
    $results.Metrics.ProcessingTime = $elapsedTime.TotalSeconds
    
    if ($elapsedTime.TotalSeconds -gt $Rules.PerformanceMetrics.MaxProcessingTime) {
        $results.Issues += "Temps de traitement excessif: $([math]::Round($elapsedTime.TotalSeconds))s"
        $results.Status = "Warning"
    }
    else {
        $results.Details += "‚úÖ Temps de traitement acceptable: $([math]::Round($elapsedTime.TotalSeconds))s"
    }
    
    # Utilisation m√©moire
    try {
        $process = Get-Process -Id $PID
        $memoryUsage = $process.WorkingSet64
        $results.Metrics.MemoryUsage = $memoryUsage
        
        if ($memoryUsage -gt $Rules.PerformanceMetrics.MaxMemoryUsage) {
            $memoryMB = [math]::Round($memoryUsage / 1MB, 2)
            $results.Issues += "Utilisation m√©moire √©lev√©e: ${memoryMB}MB"
            $results.Status = "Warning"
        }
        else {
            $memoryMB = [math]::Round($memoryUsage / 1MB, 2)
            $results.Details += "‚úÖ Utilisation m√©moire normale: ${memoryMB}MB"
        }
    }
    catch {
        $results.Issues += "Impossible de mesurer l'utilisation m√©moire: $_"
    }
    
    # Espace disque disponible
    try {
        $drive = (Get-Item $ProjectRoot).PSDrive
        $freeSpace = $drive.Free
        $results.Metrics.FreeSpace = $freeSpace
        
        if ($freeSpace -lt $Rules.PerformanceMetrics.MinDiskSpace) {
            $freeSpaceGB = [math]::Round($freeSpace / 1GB, 2)
            $results.Issues += "Espace disque insuffisant: ${freeSpaceGB}GB"
            $results.Status = "Invalid"
        }
        else {
            $freeSpaceGB = [math]::Round($freeSpace / 1GB, 2)
            $results.Details += "‚úÖ Espace disque suffisant: ${freeSpaceGB}GB"
        }
    }
    catch {
        $results.Issues += "Impossible de v√©rifier l'espace disque: $_"
    }
    
    return $results
}

function Invoke-ComprehensiveValidation {
    [CmdletBinding()]
    param(
        [string]$ProjectRoot,
        [hashtable]$ValidationContext
    )
    
    Write-Information "üîç VALIDATION COMPL√àTE EN COURS..."
    
    $validationReport = @{
        Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        SessionId = $ValidationContext.SessionId
        OverallStatus = "Valid"
        Categories = @{}
        Summary = @{
            TotalIssues = 0
            CriticalIssues = 0
            WarningIssues = 0
            PassedChecks = 0
        }
    }
    
    # Test 1: Int√©grit√© des fichiers
    Write-Information "üîç Test d'int√©grit√© des fichiers..."
    $fileIntegrityResults = Test-FileIntegrity -ProjectRoot $ProjectRoot -Rules $ValidationContext.Rules
    $validationReport.Categories.FileIntegrity = $fileIntegrityResults
    
    # Test 2: Structure des r√©pertoires
    Write-Information "üîç Test de structure des r√©pertoires..."
    $directoryResults = Test-DirectoryStructure -ProjectRoot $ProjectRoot -Rules $ValidationContext.Rules
    $validationReport.Categories.DirectoryStructure = $directoryResults
    
    # Test 3: Conformit√© s√©curitaire
    Write-Information "üîç Test de conformit√© s√©curitaire..."
    $securityResults = Test-SecurityCompliance -ProjectRoot $ProjectRoot -Rules $ValidationContext.Rules
    $validationReport.Categories.SecurityCompliance = $securityResults
    
    # Test 4: M√©triques de performance
    Write-Information "üîç Test des m√©triques de performance..."
    $performanceResults = Test-PerformanceMetrics -ProjectRoot $ProjectRoot -Rules $ValidationContext.Rules -StartTime $ValidationContext.StartTime
    $validationReport.Categories.PerformanceMetrics = $performanceResults
    
    # Calcul du statut global
    $allCategories = @($fileIntegrityResults, $directoryResults, $securityResults, $performanceResults)
    $invalidCount = ($allCategories | Where-Object { $_.Status -eq "Invalid" }).Count
    $warningCount = ($allCategories | Where-Object { $_.Status -eq "Warning" }).Count
    
    if ($invalidCount -gt 0) {
        $validationReport.OverallStatus = "Invalid"
    }
    elseif ($warningCount -gt 0) {
        $validationReport.OverallStatus = "Warning"
    }
    
    # Calcul du r√©sum√©
    foreach ($category in $allCategories) {
        $validationReport.Summary.TotalIssues += $category.Issues.Count
        if ($category.Status -eq "Invalid") {
            $validationReport.Summary.CriticalIssues += $category.Issues.Count
        }
        elseif ($category.Status -eq "Warning") {
            $validationReport.Summary.WarningIssues += $category.Issues.Count
        }
        $validationReport.Summary.PassedChecks += $category.Details.Count
    }
    
    return $validationReport
}

function Show-ValidationReport {
    [CmdletBinding()]
    param(
        [hashtable]$Report
    )
    
    Write-Host "`n" -NoNewline
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
    Write-Host "‚ïë                      RAPPORT DE VALIDATION TEMPS R√âEL                         ‚ïë" -ForegroundColor Green
    Write-Host "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£" -ForegroundColor Green
    Write-Host "‚ïë Plan Dev v41 - Phase 1.1.1.2 - Real-Time Validation System v1.0              ‚ïë" -ForegroundColor Green
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
    
    # Statut global
    $statusColor = switch ($Report.OverallStatus) {
        "Valid" { "Green" }
        "Warning" { "Yellow" }
        "Invalid" { "Red" }
        default { "White" }
    }
    
    Write-Host "`nüéØ STATUT GLOBAL: $($Report.OverallStatus.ToUpper())" -ForegroundColor $statusColor
    Write-Host "üìÖ Horodatage: $($Report.Timestamp)" -ForegroundColor White
    Write-Host "üîí Session: $($Report.SessionId)" -ForegroundColor White
    
    # R√©sum√©
    Write-Host "`nüìä R√âSUM√â:" -ForegroundColor Cyan
    Write-Host "   ‚úÖ V√©rifications r√©ussies: $($Report.Summary.PassedChecks)" -ForegroundColor Green
    Write-Host "   ‚ö†Ô∏è  Avertissements: $($Report.Summary.WarningIssues)" -ForegroundColor Yellow
    Write-Host "   ‚ùå Probl√®mes critiques: $($Report.Summary.CriticalIssues)" -ForegroundColor Red
    Write-Host "   üìã Total des probl√®mes: $($Report.Summary.TotalIssues)" -ForegroundColor White
    
    # D√©tails par cat√©gorie
    foreach ($categoryName in $Report.Categories.Keys) {
        $category = $Report.Categories[$categoryName]
        
        Write-Host "`nüìÇ CAT√âGORIE: $categoryName" -ForegroundColor Cyan
        $categoryColor = switch ($category.Status) {
            "Valid" { "Green" }
            "Warning" { "Yellow" }
            "Invalid" { "Red" }
            default { "White" }
        }
        Write-Host "   üìä Statut: $($category.Status)" -ForegroundColor $categoryColor
        
        if ($category.Details.Count -gt 0) {
            Write-Host "   ‚úÖ D√©tails positifs:" -ForegroundColor Green
            $category.Details | ForEach-Object { Write-Host "      $_" -ForegroundColor Green }
        }
        
        if ($category.Issues.Count -gt 0) {
            Write-Host "   ‚ö†Ô∏è  Probl√®mes d√©tect√©s:" -ForegroundColor Yellow
            $category.Issues | ForEach-Object { Write-Host "      $_" -ForegroundColor Yellow }
        }
        
        # M√©triques sp√©ciales pour la performance
        if ($categoryName -eq "PerformanceMetrics" -and $category.Metrics) {
            Write-Host "   üìä M√©triques:" -ForegroundColor White
            if ($category.Metrics.ProcessingTime) {
                Write-Host "      ‚è±Ô∏è  Temps de traitement: $([math]::Round($category.Metrics.ProcessingTime, 2))s" -ForegroundColor White
            }
            if ($category.Metrics.MemoryUsage) {
                $memoryMB = [math]::Round($category.Metrics.MemoryUsage / 1MB, 2)
                Write-Host "      üß† Utilisation m√©moire: ${memoryMB}MB" -ForegroundColor White
            }
            if ($category.Metrics.FreeSpace) {
                $freeSpaceGB = [math]::Round($category.Metrics.FreeSpace / 1GB, 2)
                Write-Host "      üíæ Espace disque libre: ${freeSpaceGB}GB" -ForegroundColor White
            }
        }
    }
}

function Save-ValidationReport {
    [CmdletBinding()]
    param(
        [hashtable]$Report,
        [string]$ValidationDirectory
    )
    
    $reportFileName = "validation-report_$($Report.SessionId)_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
    $reportPath = Join-Path $ValidationDirectory $reportFileName
    
    try {
        $Report | ConvertTo-Json -Depth 10 | Out-File $reportPath -Encoding UTF8
        Write-Information "üíæ Rapport de validation sauvegard√©: $reportPath"
        return $reportPath
    }
    catch {
        Write-Warning "‚ö†Ô∏è  Impossible de sauvegarder le rapport: $_"
        return $null
    }
}

# ===== FONCTION PRINCIPALE =====

function Start-RealTimeValidation {
    [CmdletBinding()]
    param()
    
    try {
        # Initialisation
        $validationContext = Initialize-RealTimeValidator
        Write-Information "üöÄ Syst√®me de validation initialis√© - Session: $($validationContext.SessionId)"
        
        # Validation compl√®te
        $validationReport = Invoke-ComprehensiveValidation -ProjectRoot $ProjectRoot -ValidationContext $validationContext
        
        # Affichage du rapport
        Show-ValidationReport -Report $validationReport
        
        # Sauvegarde du rapport
        $reportPath = Save-ValidationReport -Report $validationReport -ValidationDirectory $validationContext.ValidationDirectory
        
        # Retour du code d'erreur appropri√©
        $exitCode = switch ($validationReport.OverallStatus) {
            "Valid" { 0 }
            "Warning" { 1 }
            "Invalid" { 2 }
            default { 3 }
        }
        
        Write-Information "‚úÖ Validation compl√©t√©e avec le code de sortie: $exitCode"
        return $exitCode
        
    }
    catch {
        Write-Error "üí• ERREUR CRITIQUE lors de la validation: $_"
        return 99
    }
}

# ===== POINT D'ENTR√âE =====

# Configuration globale
$ErrorActionPreference = "Continue"
$InformationPreference = "Continue"

# Affichage de l'en-t√™te
Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
Write-Host "‚ïë                     REAL-TIME VALIDATION SYSTEM v1.0                          ‚ïë" -ForegroundColor Green
Write-Host "‚ïë                       Plan Dev v41 - Phase 1.1.1.2                           ‚ïë" -ForegroundColor Green
Write-Host "‚ïë                     Syst√®me de Validation Temps R√©el                          ‚ïë" -ForegroundColor Green
Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green

# Ex√©cution du syst√®me de validation
exit (Start-RealTimeValidation)
