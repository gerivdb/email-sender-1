package api

import (
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
{{- if .hasAuth}}
	"github.com/golang-jwt/jwt/v5"
{{- end}}
{{- if .hasRateLimit}}
	"golang.org/x/time/rate"
{{- end}}
)

// {{.service}}API implements the REST API for {{.service}}
type {{.service}}API struct {
	logger *logrus.Logger
	router *gin.Engine
{{- if .hasAuth}}
	jwtSecret []byte
{{- end}}
{{- if .hasRateLimit}}
	limiter *rate.Limiter
{{- end}}
}

// New{{.service}}API creates a new API instance
func New{{.service}}API(logger *logrus.Logger) *{{.service}}API {
	api := &{{.service}}API{
		logger: logger,
		router: gin.New(),
{{- if .hasAuth}}
		jwtSecret: []byte("your-secret-key"), // TODO: Use environment variable
{{- end}}
{{- if .hasRateLimit}}
		limiter: rate.NewLimiter(rate.Every(time.Second), 100), // 100 requests per second
{{- end}}
	}
	
	api.setupRoutes()
	return api
}

// GetRouter returns the configured Gin router
func (api *{{.service}}API) GetRouter() *gin.Engine {
	return api.router
}

// setupRoutes configures all API routes
func (api *{{.service}}API) setupRoutes() {
	// Middleware
	api.router.Use(gin.Recovery())
	api.router.Use(api.loggingMiddleware())
	api.router.Use(api.corsMiddleware())
{{- if .hasRateLimit}}
	api.router.Use(api.rateLimitMiddleware())
{{- end}}
	
	// Public routes
	public := api.router.Group("/api/{{.version}}")
	{
		public.GET("/health", api.handleHealth)
		public.GET("/version", api.handleVersion)
{{- if .hasAuth}}
		public.POST("/auth/login", api.handleLogin)
		public.POST("/auth/register", api.handleRegister)
{{- end}}
	}
	
{{- if .hasAuth}}
	// Protected routes
	protected := api.router.Group("/api/{{.version}}")
	protected.Use(api.authMiddleware())
	{
		protected.GET("/profile", api.handleProfile)
		protected.GET("/{{lower .service}}", api.handleList{{.service}})
		protected.POST("/{{lower .service}}", api.handleCreate{{.service}})
		protected.GET("/{{lower .service}}/:id", api.handleGet{{.service}})
		protected.PUT("/{{lower .service}}/:id", api.handleUpdate{{.service}})
		protected.DELETE("/{{lower .service}}/:id", api.handleDelete{{.service}})
	}
{{- else}}
	// API routes
	api := api.router.Group("/api/{{.version}}")
	{
		api.GET("/{{lower .service}}", api.handleList{{.service}})
		api.POST("/{{lower .service}}", api.handleCreate{{.service}})
		api.GET("/{{lower .service}}/:id", api.handleGet{{.service}})
		api.PUT("/{{lower .service}}/:id", api.handleUpdate{{.service}})
		api.DELETE("/{{lower .service}}/:id", api.handleDelete{{.service}})
	}
{{- end}}
}

// Handlers

func (api *{{.service}}API) handleHealth(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"status":    "healthy",
		"timestamp": time.Now(),
		"service":   "{{.service}} API",
		"version":   "{{.version}}",
	})
}

func (api *{{.service}}API) handleVersion(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"service": "{{.service}} API",
		"version": "{{.version}}",
		"build":   "development",
	})
}

{{- if .hasAuth}}
func (api *{{.service}}API) handleLogin(c *gin.Context) {
	var request struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
	}
	
	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	// TODO: Implement actual authentication logic
	if request.Username == "admin" && request.Password == "password" {
		token, err := api.generateJWT(request.Username)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
			return
		}
		
		c.JSON(http.StatusOK, gin.H{
			"token": token,
			"user":  request.Username,
		})
	} else {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
	}
}

func (api *{{.service}}API) handleRegister(c *gin.Context) {
	var request struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
		Email    string `json:"email" binding:"required,email"`
	}
	
	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	// TODO: Implement user registration logic
	c.JSON(http.StatusCreated, gin.H{
		"message": "User registered successfully",
		"user":    request.Username,
	})
}

func (api *{{.service}}API) handleProfile(c *gin.Context) {
	username := c.GetString("username")
	
	// TODO: Fetch user profile from database
	c.JSON(http.StatusOK, gin.H{
		"username":   username,
		"email":      username + "@example.com",
		"created_at": time.Now().AddDate(0, -1, 0), // Mock: 1 month ago
	})
}
{{- end}}

func (api *{{.service}}API) handleList{{.service}}(c *gin.Context) {
	// Query parameters
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
	
	// TODO: Implement actual data fetching
	items := []gin.H{
		{"id": 1, "name": "Sample Item 1", "created_at": time.Now()},
		{"id": 2, "name": "Sample Item 2", "created_at": time.Now()},
	}
	
	c.JSON(http.StatusOK, gin.H{
		"data": items,
		"meta": gin.H{
			"page":  page,
			"limit": limit,
			"total": len(items),
		},
	})
}

func (api *{{.service}}API) handleCreate{{.service}}(c *gin.Context) {
	var request struct {
		Name        string `json:"name" binding:"required"`
		Description string `json:"description"`
	}
	
	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	// TODO: Implement actual creation logic
	item := gin.H{
		"id":          123,
		"name":        request.Name,
		"description": request.Description,
		"created_at":  time.Now(),
	}
	
	c.JSON(http.StatusCreated, gin.H{
		"message": "{{.service}} created successfully",
		"data":    item,
	})
}

func (api *{{.service}}API) handleGet{{.service}}(c *gin.Context) {
	id := c.Param("id")
	
	// TODO: Implement actual data fetching
	item := gin.H{
		"id":          id,
		"name":        "Sample Item " + id,
		"description": "This is a sample item",
		"created_at":  time.Now(),
	}
	
	c.JSON(http.StatusOK, gin.H{
		"data": item,
	})
}

func (api *{{.service}}API) handleUpdate{{.service}}(c *gin.Context) {
	id := c.Param("id")
	
	var request struct {
		Name        string `json:"name"`
		Description string `json:"description"`
	}
	
	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	
	// TODO: Implement actual update logic
	item := gin.H{
		"id":          id,
		"name":        request.Name,
		"description": request.Description,
		"updated_at":  time.Now(),
	}
	
	c.JSON(http.StatusOK, gin.H{
		"message": "{{.service}} updated successfully",
		"data":    item,
	})
}

func (api *{{.service}}API) handleDelete{{.service}}(c *gin.Context) {
	id := c.Param("id")
	
	// TODO: Implement actual deletion logic
	c.JSON(http.StatusOK, gin.H{
		"message": "{{.service}} deleted successfully",
		"id":      id,
	})
}

// Middleware

func (api *{{.service}}API) loggingMiddleware() gin.HandlerFunc {
	return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		api.logger.WithFields(logrus.Fields{
			"status":    param.StatusCode,
			"method":    param.Method,
			"path":      param.Path,
			"latency":   param.Latency,
			"client_ip": param.ClientIP,
		}).Info("API Request")
		return ""
	})
}

func (api *{{.service}}API) corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Authorization")
		
		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}
		
		c.Next()
	}
}

{{- if .hasRateLimit}}
func (api *{{.service}}API) rateLimitMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		if !api.limiter.Allow() {
			c.JSON(http.StatusTooManyRequests, gin.H{
				"error": "Rate limit exceeded",
			})
			c.Abort()
			return
		}
		c.Next()
	}
}
{{- end}}

{{- if .hasAuth}}
func (api *{{.service}}API) authMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}
		
		tokenString := authHeader[7:] // Remove "Bearer " prefix
		
		token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
			return api.jwtSecret, nil
		})
		
		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}
		
		if claims, ok := token.Claims.(jwt.MapClaims); ok {
			c.Set("username", claims["username"])
		}
		
		c.Next()
	}
}

func (api *{{.service}}API) generateJWT(username string) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"username": username,
		"exp":      time.Now().Add(time.Hour * 24).Unix(),
	})
	
	return token.SignedString(api.jwtSecret)
}
{{- end}}
