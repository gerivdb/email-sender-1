// dispatcher.go
// Module Roo-Code : Dispatcher CLI multi-OS avec hooks PluginInterface Roo
// Voir conventions : [`AGENTS.md`](AGENTS.md:PluginInterface), [`rules-code.md`](.roo/rules/rules-code.md:1)

package gatewaymanager

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"time"
)

/*
Command Roo : structure repr√©sentant une commande √† ex√©cuter dans le shell cible.
- ID : identifiant unique pour tra√ßabilit√© documentaire Roo (mode, audit, logs)
- Content : contenu de la commande shell √† ex√©cuter
- Meta : m√©tadonn√©es extensibles (contexte, origine, param√®tres, etc.)
Conforme AGENTS.md, tra√ßabilit√© mode d‚Äôex√©cution Roo.
*/
type Command struct {
	ID      string
	Content string
	Meta    map[string]interface{}
}

/*
AuditHook Roo : interface pour l‚Äôaudit et l‚Äôextension documentaire.
- BeforeExecute : appel√© avant l‚Äôex√©cution r√©elle, permet la validation, le reporting, l‚Äôenrichissement du contexte.
- AfterExecute : appel√© apr√®s l‚Äôex√©cution, pour journalisation, reporting, extension plugin.
Points d‚Äôextension Roo : voir AGENTS.md (hooks/plugins), rules-plugins.md.
*/
type AuditHook interface {
	BeforeExecute(ctx context.Context, cmd *Command) error
	AfterExecute(ctx context.Context, cmd *Command, result *CommandResult) error
}

/*
PluginInterface Roo : interface pour l‚Äôextension dynamique des hooks d‚Äôaudit.
- RegisterHook : ajoute dynamiquement un hook d‚Äôaudit (plugin, strat√©gie, etc.)
- UnregisterHook : retire un hook par nom (gestion dynamique, s√©curit√©)
- ListHooks : retourne la liste des hooks actifs (audit, reporting)
Conforme AGENTS.md, points d‚Äôextension plugins/documentation.
*/
type PluginInterface interface {
	RegisterHook(hook AuditHook) error
	UnregisterHook(name string) error
	ListHooks() []AuditHook
}

/*
CommandResult Roo : structure du r√©sultat d‚Äôex√©cution shell.
- Success : bool√©en indiquant le succ√®s ou l‚Äô√©chec
- Output : sortie standard/erreur du shell (stdout/stderr)
- Error : objet d‚Äôerreur Go (pour reporting, audit, extension plugin)
- Timestamp : horodatage de l‚Äôex√©cution
Tra√ßabilit√© Roo : chaque r√©sultat est audit√© via hooks/plugins.
*/
type CommandResult struct {
	Success   bool
	Output    string
	Error     error
	Timestamp time.Time
}

/*
ExecutionLogEntry Roo : structure de journalisation structur√©e pour chaque ex√©cution shell.
- CommandID, CommandContent, Meta, Success, Output, Error, Timestamp, Mode
- Conforme Roo : tra√ßabilit√©, audit, documentation
*/
type ExecutionLogEntry struct {
	CommandID      string
	CommandContent string
	Meta           map[string]interface{}
	Success        bool
	Output         string
	Error          string
	Timestamp      time.Time
	Mode           string
}

// Slice globale pour journaliser toutes les ex√©cutions (pour g√©n√©ration Markdown)
var executionLogs []ExecutionLogEntry

/*
Dispatcher Roo : manager central pour l‚Äôex√©cution shell multi-OS.
- hooks : liste des hooks d‚Äôaudit/documentation (extension dynamique)
Responsable de la tra√ßabilit√©, de la s√©curit√© (sandbox), de l‚Äôorchestration des plugins.
Conforme AGENTS.md, mod√®le manager/agent Roo.
*/
type Dispatcher struct {
	hooks []AuditHook
}

// Structure Roo : sauvegarde d‚Äô√©tat pour rollback automatique
type DispatcherStateBackup struct {
	executionLogs []ExecutionLogEntry
	hooks         []AuditHook
}

// M√©thode Roo : restaure l‚Äô√©tat du dispatcher depuis une sauvegarde
func (d *Dispatcher) RestoreStateFromBackup(backup *DispatcherStateBackup) {
	if backup == nil {
		return
	}
	executionLogs = append([]ExecutionLogEntry(nil), backup.executionLogs...)
	d.hooks = append([]AuditHook(nil), backup.hooks...)
}

// M√©thode Roo : sauvegarde l‚Äô√©tat courant du dispatcher
func (d *Dispatcher) BackupState() *DispatcherStateBackup {
	return &DispatcherStateBackup{
		executionLogs: append([]ExecutionLogEntry(nil), executionLogs...),
		hooks:         append([]AuditHook(nil), d.hooks...),
	}
}

/*
globalDispatcher Roo : r√©f√©rence globale pour injection des hooks dans la sandbox.
Permet l‚Äôacc√®s aux hooks d‚Äôaudit depuis la validation de s√©curit√© (isCommandSafe).
Point d‚Äôextension Roo : adaptation possible selon architecture r√©elle.
*/
var globalDispatcher *Dispatcher

/*
NewDispatcher Roo : constructeur du manager Dispatcher.
- Initialise la liste des hooks d‚Äôaudit
- D√©finit la r√©f√©rence globale pour la sandbox (s√©curit√©, audit)
Tra√ßabilit√© Roo : chaque instance est li√©e au mode d‚Äôex√©cution/documentation.
*/
func NewDispatcher() *Dispatcher {
	d := &Dispatcher{
		hooks: make([]AuditHook, 0),
	}
	// Roo: Initialisation du dispatcher global pour acc√®s hooks dans sandbox
	globalDispatcher = d
	return d
}

/*
RegisterHook Roo : ajoute dynamiquement un hook d‚Äôaudit.
- Extension documentaire, reporting, validation, plugins
Conforme points d‚Äôextension AGENTS.md/rules-plugins.md.
*/
func (d *Dispatcher) RegisterHook(hook AuditHook) error {
	d.hooks = append(d.hooks, hook)
	return nil
}

/*
ReceiveCommand Roo : point d‚Äôentr√©e principal pour l‚Äôex√©cution shell.
- Audit avant ex√©cution (hooks/plugins, tra√ßabilit√© documentaire Roo)
- D√©tection OS et mapping shell (multi-OS, conformit√© AGENTS.md)
- S√©curit√© documentaire (sandbox, validation avanc√©e, audit dynamique)
- Ex√©cution r√©elle via exec.Command (Go standard, s√©curit√©/sandbox int√©gr√©e)
- Audit apr√®s ex√©cution (hooks/plugins, reporting, extension)
Cas limites : gestion d‚Äôerreur, reporting, extension plugin.
*/
func (d *Dispatcher) ReceiveCommand(ctx context.Context, cmd *Command) (*CommandResult, error) {
	// Capture du timestamp d‚Äôex√©cution
	execTimestamp := time.Now()

	// Roo: Audit avant ex√©cution (hooks Roo, tra√ßabilit√© documentaire)
	for _, hook := range d.hooks {
		if err := hook.BeforeExecute(ctx, cmd); err != nil {
			return nil, fmt.Errorf("audit hook failed: %w", err)
		}
	}

	// Roo: D√©tection OS et mapping shell (multi-OS Roo, conformit√© AGENTS.md)
	shell, args := detectShell()
	if shell == "" {
		return nil, errors.New("unsupported OS")
	}

	// Roo: S√©curit√© documentaire, sandbox, validation avanc√©e, audit dynamique
	var backupSandbox = d.BackupState()
	if !isCommandSafe(cmd.Content) {
		// Rollback Roo : restauration d‚Äô√©tat en cas d‚Äô√©chec critique (sandbox)
		d.RestoreStateFromBackup(backupSandbox)
		// Roo: Reporting s√©curit√©, extension plugins/audit
		for _, hook := range d.hooks {
			_ = hook.AfterExecute(ctx, cmd, &CommandResult{
				Success:   false,
				Output:    "",
				Error:     errors.New("commande non autoris√©e (sandbox Roo)"),
				Timestamp: execTimestamp,
			})
		}
		// Journalisation structur√©e de l‚Äô√©chec
		executionLogs = append(executionLogs, ExecutionLogEntry{
			CommandID:      cmd.ID,
			CommandContent: cmd.Content,
			Meta:           cmd.Meta,
			Success:        false,
			Output:         "",
			Error:          "commande non autoris√©e (sandbox Roo)",
			Timestamp:      execTimestamp,
			Mode:           getModeFromMeta(cmd.Meta),
		})
		return nil, errors.New("commande non autoris√©e (sandbox Roo)")
	}

	// === √âtape interactive Roo : validation humaine avant ex√©cution ===
	if !requestUserConfirmation(cmd.Content) {
		// Refus utilisateur, journalisation et audit
		for _, hook := range d.hooks {
			_ = hook.AfterExecute(ctx, cmd, &CommandResult{
				Success:   false,
				Output:    "",
				Error:     errors.New("commande refus√©e par l‚Äôutilisateur (validation interactive Roo)"),
				Timestamp: execTimestamp,
			})
		}
		executionLogs = append(executionLogs, ExecutionLogEntry{
			CommandID:      cmd.ID,
			CommandContent: cmd.Content,
			Meta:           cmd.Meta,
			Success:        false,
			Output:         "",
			Error:          "commande refus√©e par l‚Äôutilisateur (validation interactive Roo)",
			Timestamp:      execTimestamp,
			Mode:           getModeFromMeta(cmd.Meta),
		})
		return nil, errors.New("commande refus√©e par l‚Äôutilisateur (validation interactive Roo)")
	}

	// Roo: Ex√©cution r√©elle via exec.Command (Go standard, s√©curit√©/sandbox int√©gr√©e)
	// Documentation Roo : voir rules-code.md, AGENTS.md
	output, err := executeShellCommand(shell, args, cmd.Content)
	result := &CommandResult{
		Success:   err == nil,
		Output:    output,
		Error:     err,
		Timestamp: execTimestamp,
	}

	// Roo: Audit apr√®s ex√©cution (hooks Roo, tra√ßabilit√© documentaire)
	for _, hook := range d.hooks {
		_ = hook.AfterExecute(ctx, cmd, result)
	}

	// Journalisation structur√©e de l‚Äôex√©cution
	executionLogs = append(executionLogs, ExecutionLogEntry{
		CommandID:      cmd.ID,
		CommandContent: cmd.Content,
		Meta:           cmd.Meta,
		Success:        result.Success,
		Output:         result.Output,
		Error:          errorToString(result.Error),
		Timestamp:      result.Timestamp,
		Mode:           getModeFromMeta(cmd.Meta),
	})

	return result, nil
}

// Utilitaire Roo : extraire le mode d‚Äôex√©cution Roo depuis Meta
func getModeFromMeta(meta map[string]interface{}) string {
	if meta == nil {
		return ""
	}
	if mode, ok := meta["mode"]; ok {
		if modeStr, ok := mode.(string); ok {
			return modeStr
		}
	}
	return ""
}

// Utilitaire Roo : conversion error en string
func errorToString(err error) string {
	if err == nil {
		return ""
	}
	return err.Error()
}

/*
detectShell Roo : d√©tecte l‚ÄôOS et retourne le shell adapt√©.
- Windows : PowerShell (pwsh) recommand√©, fallback possible vers cmd
- Linux/macOS : Bash standard
- Convention Roo : args conformes √† AGENTS.md/rules-code.md
Cas limite : OS non support√© ‚Üí tra√ßabilit√© documentaire, reporting d‚Äôerreur.
*/
func detectShell() (string, []string) {
	// D√©tection Roo : mapping shell selon OS, conforme AGENTS.md/PluginInterface
	switch runtime.GOOS {
	case "windows":
		// üü¶ Windows ‚Üí PowerShell (pwsh), usage s√©curis√© recommand√©
		// Convention Roo : args = ["-Command"], voir rules-code.md
		return "pwsh", []string{"-Command"}
	case "linux":
		// üü© Linux ‚Üí Bash, usage standard
		// Convention Roo : args = ["-c"], voir rules-code.md
		return "bash", []string{"-c"}
	case "darwin":
		// üçè macOS ‚Üí Bash, usage standard
		// Convention Roo : args = ["-c"], voir rules-code.md
		return "bash", []string{"-c"}
	default:
		// üö® OS non support√©, tra√ßabilit√© Roo
		return "", nil
	}
}

/*
prepareShellCommand Roo : pr√©pare la commande pour le shell cible.
- Args : shell, arguments sp√©cifiques, contenu de la commande
- S√©curit√© √† renforcer : attention √† l‚Äôinjection, √† la validation des entr√©es
Cas limite : extension possible pour validation avanc√©e, reporting.
*/
func prepareShellCommand(shell string, args []string, content string) string {
	// Pour l‚Äôinstant, retourne la cha√Æne compl√®te (s√©curit√© √† renforcer)
	return fmt.Sprintf("%s %v %s", shell, args, content)
}

/*
isCommandSafe Roo : sandbox documentaire, filtre les commandes dangereuses.
- Blacklist : liste des commandes interdites (s√©curit√© documentaire Roo)
- Audit dynamique : appel des hooks d‚Äôaudit pour reporting s√©curit√©, extension plugin possible
- Extension Roo : injection possible de plugins de validation avanc√©e (QualityGatePlugin, etc.)
Cas limite : reporting d‚Äôerreur, extension dynamique, adaptation architecture.
Documentation Roo : voir rules-code.md, AGENTS.md, rules-plugins.md.
*/
var whitelist = []string{"ls", "echo", "cat", "pwd", "whoami", "date", "uptime", "ps", "top", "dir", "type", "hostname"}

func isWhitelisted(content string) bool {
	for _, allowed := range whitelist {
		// Autorise si la commande commence par un mot whitelist√©
		if len(content) > 0 && strings.HasPrefix(strings.TrimSpace(content), allowed) {
			return true
		}
	}
	return false
}

func isCommandSafe(content string) bool {
	// Whitelist stricte Roo : seules les commandes autoris√©es sont ex√©cut√©es
	var backupWhitelist = globalDispatcher.BackupState()
	if !isWhitelisted(content) {
		// Rollback Roo : restauration d‚Äô√©tat en cas d‚Äô√©chec critique (whitelist)
		globalDispatcher.RestoreStateFromBackup(backupWhitelist)
		// Audit Roo : refus, journalisation structur√©e, reporting
		if globalDispatcher != nil {
			for _, hook := range globalDispatcher.hooks {
				_ = hook.AfterExecute(context.Background(), &Command{Content: content}, &CommandResult{
					Success: false,
					Output:  "",
					Error:   errors.New("commande non whitelist√©e (s√©curit√© Roo)"),
				})
			}
		}
		// Journalisation structur√©e du refus
		executionLogs = append(executionLogs, ExecutionLogEntry{
			CommandID:      "",
			CommandContent: content,
			Meta:           nil,
			Success:        false,
			Output:         "",
			Error:          "commande non whitelist√©e (s√©curit√© Roo)",
			Timestamp:      time.Now(),
			Mode:           "",
		})
		return false
	}
	// S√©curit√© Roo : sandbox dynamique, audit extensible via hooks/plugins
	blacklist := []string{"rm ", "del ", "shutdown", "reboot", "mkfs", "dd ", "format ", "poweroff"}
	for _, forbidden := range blacklist {
		if len(content) > 0 && containsIgnoreCase(content, forbidden) {
			// Audit dynamique : log, extension plugin possible ici
			if globalDispatcher != nil {
				for _, hook := range globalDispatcher.hooks {
					_ = hook.AfterExecute(context.Background(), &Command{Content: content}, &CommandResult{
						Success: false,
						Output:  "",
						Error:   errors.New("commande interdite d√©tect√©e (sandbox Roo)"),
					})
				}
			}
			return false
		}
	}
	// Extension Roo : point d‚Äôinjection pour plugins de validation avanc√©e
	if globalDispatcher != nil {
		for _, hook := range globalDispatcher.hooks {
			_ = hook.BeforeExecute(context.Background(), &Command{Content: content})
		}
	}
	return true
}

// containsIgnoreCase : utilitaire Roo
func containsIgnoreCase(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || (len(s) > 0 && len(substr) > 0 && (stringContainsFold(s, substr))))
}

// stringContainsFold : ignore la casse
func stringContainsFold(s, substr string) bool {
	return len(s) >= len(substr) && (stringIndexFold(s, substr) >= 0)
}

// stringIndexFold : index ignore case
func stringIndexFold(s, substr string) int {
	return indexFold(s, substr)
}

// indexFold : version simplifi√©e
func indexFold(s, substr string) int {
	sLower := toLower(s)
	substrLower := toLower(substr)
	return index(sLower, substrLower)
}

// toLower : utilitaire
func toLower(s string) string {
	b := []byte(s)
	for i := range b {
		if b[i] >= 'A' && b[i] <= 'Z' {
			b[i] += 'a' - 'A'
		}
	}
	return string(b)
}

// index : retourne l‚Äôindex de substr dans s
func index(s, substr string) int {
	for i := 0; i+len(substr) <= len(s); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}

/*
executeShellCommand Roo : ex√©cute la commande dans le shell cible.
- Args : shell, arguments, contenu de la commande
- S√©curit√©/sandbox int√©gr√©e : conforme AGENTS.md, reporting d‚Äôerreur, audit
- Capture stdout/stderr pour reporting/documentation
Cas limite : gestion d‚Äôerreur, extension plugin, reporting avanc√©.
*/

func executeShellCommand(shell string, args []string, content string) (string, error) {
	cmdArgs := append(args, content)
	cmd := exec.Command(shell, cmdArgs...)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out
	err := cmd.Run()
	return out.String(), err
}

// Validation interactive Roo : demande confirmation utilisateur avant ex√©cution shell
func requestUserConfirmation(cmdContent string) bool {
	fmt.Printf("\nValidation interactive Roo\n")
	fmt.Printf("Commande √† ex√©cuter :\n%s\n", cmdContent)
	fmt.Printf("Confirmez-vous l‚Äôex√©cution ? (o/n) : ")
	var response string
	_, err := fmt.Scanln(&response)
	if err != nil {
		fmt.Println("Erreur lecture confirmation, refus par d√©faut.")
		return false
	}
	response = strings.TrimSpace(strings.ToLower(response))
	return response == "o" || response == "oui" || response == "y" || response == "yes"
}

// G√©n√©ration du rapport Markdown Roo des ex√©cutions shell
// Inclut‚ÄØ: ID, commande, mode, succ√®s/√©chec, timestamp, r√©sultat, erreur
func GenerateExecutionReportMarkdown(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// En-t√™te Roo
	fmt.Fprintf(f, "# Rapport d‚Äôex√©cutions shell Roo\n\n")
	fmt.Fprintf(f, "Ce rapport r√©capitule toutes les ex√©cutions shell via le GatewayManager.\n\n")
	fmt.Fprintf(f, "| ID | Commande | Mode | Succ√®s | Timestamp | R√©sultat | Erreur |\n")
	fmt.Fprintf(f, "|----|----------|------|--------|-----------|----------|--------|\n")

	for _, log := range executionLogs {
		fmt.Fprintf(f, "| %s | `%s` | %s | %v | %s | `%s` | `%s` |\n",
			log.CommandID,
			escapeMarkdown(log.CommandContent),
			log.Mode,
			log.Success,
			log.Timestamp.Format("2006-01-02 15:04:05"),
			escapeMarkdown(log.Output),
			escapeMarkdown(log.Error),
		)
	}

	fmt.Fprintf(f, "\n_G√©n√©r√© automatiquement par Roo-Code, conforme aux standards de tra√ßabilit√© et documentation._\n")
	return nil
}

// Utilitaire Markdown Roo‚ÄØ: √©chappe les pipes et backticks
func escapeMarkdown(s string) string {
	s = strings.ReplaceAll(s, "|", "\\|")
	s = strings.ReplaceAll(s, "`", "'")
	return s
}

// Appel Roo : G√©n√©ration du rapport Markdown des ex√©cutions shell
// √Ä placer √† la fin du flux principal (ex‚ÄØ: main, orchestration, ou apr√®s toutes les commandes)

// Exemple Roo : fonction main pour g√©n√©rer le rapport Markdown des ex√©cutions shell
func main() {
	err := GenerateExecutionReportMarkdown("report-executions.md")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Erreur g√©n√©ration rapport Markdown Roo : %v\n", err)
	}
}
