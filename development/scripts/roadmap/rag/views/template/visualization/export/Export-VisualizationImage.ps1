# Export-VisualizationImage.ps1
# Script pour exporter les visualisations en images statiques
# Version: 1.0
# Date: 2025-05-15

[CmdletBinding()]
param (
    [Parameter(Mandatory = $false)]
    [string]$VisualizationPath,
    
    [Parameter(Mandatory = $false)]
    [string]$OutputPath,
    
    [Parameter(Mandatory = $false)]
    [ValidateSet("PNG", "JPEG", "SVG", "PDF")]
    [string]$Format = "PNG",
    
    [Parameter(Mandatory = $false)]
    [int]$Width = 1200,
    
    [Parameter(Mandatory = $false)]
    [int]$Height = 800,
    
    [Parameter(Mandatory = $false)]
    [switch]$IncludeTimestamp,
    
    [Parameter(Mandatory = $false)]
    [switch]$IncludeWatermark,
    
    [Parameter(Mandatory = $false)]
    [string]$WatermarkText = "Generated by Roadmap RAG",
    
    [Parameter(Mandatory = $false)]
    [ValidateSet("Error", "Warning", "Info", "Debug", "None")]
    [string]$LogLevel = "Info"
)

# Importer le module de journalisation
$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
$parentPath = Split-Path -Parent $scriptPath
$rootPath = Split-Path -Parent $parentPath
$utilsPath = Join-Path -Path (Split-Path -Parent (Split-Path -Parent (Split-Path -Parent $rootPath))) -ChildPath "utils"
$logModulePath = Join-Path -Path $utilsPath -ChildPath "Write-Log.ps1"

if (Test-Path -Path $logModulePath) {
    . $logModulePath
} else {
    function Write-Log {
        param (
            [string]$Message,
            [string]$Level = "Info"
        )
        
        if ($LogLevel -eq "None") {
            return
        }
        
        $logLevels = @{
            "Error" = 0
            "Warning" = 1
            "Info" = 2
            "Debug" = 3
        }
        
        if ($logLevels[$Level] -le $logLevels[$LogLevel]) {
            $color = switch ($Level) {
                "Error" { "Red" }
                "Warning" { "Yellow" }
                "Info" { "White" }
                "Debug" { "Gray" }
                default { "White" }
            }
            
            Write-Host "[$Level] $Message" -ForegroundColor $color
        }
    }
}

# Importer le script de visualisation
$visualizationPath = Join-Path -Path $parentPath -ChildPath "Edit-Visualization.ps1"
if (-not (Test-Path -Path $visualizationPath)) {
    Write-Log "Visualization script not found: $visualizationPath" -Level "Error"
    exit 1
}

. $visualizationPath

# Fonction pour charger une visualisation
function Get-VisualizationFromFile {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$VisualizationPath
    )
    
    if (-not (Test-Path -Path $VisualizationPath)) {
        Write-Log "Visualization file not found: $VisualizationPath" -Level "Error"
        return $null
    }
    
    try {
        $visualization = Get-Content -Path $VisualizationPath -Raw | ConvertFrom-Json
        return $visualization
    } catch {
        Write-Log "Error loading visualization: $_" -Level "Error"
        return $null
    }
}

# Fonction pour générer le HTML de la visualisation avec les scripts d'export
function Get-ExportHtml {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [object]$Visualization,
        
        [Parameter(Mandatory = $true)]
        [string]$Format,
        
        [Parameter(Mandatory = $true)]
        [int]$Width,
        
        [Parameter(Mandatory = $true)]
        [int]$Height,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeTimestamp,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeWatermark,
        
        [Parameter(Mandatory = $false)]
        [string]$WatermarkText
    )
    
    # Générer le HTML de base de la visualisation
    $html = Get-VisualizationHtml -Visualization $Visualization
    
    # Ajouter les scripts nécessaires pour l'export
    $exportScripts = @"
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Attendre que tous les graphiques soient rendus
    setTimeout(function() {
        exportVisualization();
    }, 2000);
    
    function exportVisualization() {
        const format = '$Format';
        const width = $Width;
        const height = $Height;
        const includeTimestamp = $($IncludeTimestamp.IsPresent.ToString().ToLower());
        const includeWatermark = $($IncludeWatermark.IsPresent.ToString().ToLower());
        const watermarkText = '$WatermarkText';
        
        const container = document.querySelector('.container');
        
        // Ajouter un timestamp si demandé
        if (includeTimestamp) {
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.style.position = 'absolute';
            timestamp.style.bottom = '10px';
            timestamp.style.right = '10px';
            timestamp.style.fontSize = '12px';
            timestamp.style.color = '#999';
            timestamp.textContent = 'Generated: ' + new Date().toLocaleString();
            container.appendChild(timestamp);
        }
        
        // Ajouter un filigrane si demandé
        if (includeWatermark) {
            const watermark = document.createElement('div');
            watermark.className = 'watermark';
            watermark.style.position = 'absolute';
            watermark.style.top = '50%';
            watermark.style.left = '50%';
            watermark.style.transform = 'translate(-50%, -50%) rotate(-45deg)';
            watermark.style.fontSize = '48px';
            watermark.style.fontWeight = 'bold';
            watermark.style.color = 'rgba(200, 200, 200, 0.2)';
            watermark.style.pointerEvents = 'none';
            watermark.style.zIndex = '1000';
            watermark.style.whiteSpace = 'nowrap';
            watermark.textContent = watermarkText;
            document.body.appendChild(watermark);
        }
        
        // Exporter selon le format demandé
        switch (format.toLowerCase()) {
            case 'png':
                exportAsPNG(container, width, height);
                break;
            case 'jpeg':
                exportAsJPEG(container, width, height);
                break;
            case 'svg':
                exportAsSVG(container);
                break;
            case 'pdf':
                exportAsPDF(container, width, height);
                break;
        }
    }
    
    function exportAsPNG(element, width, height) {
        html2canvas(element, {
            width: width,
            height: height,
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff'
        }).then(function(canvas) {
            canvas.toBlob(function(blob) {
                saveAs(blob, 'visualization.png');
                window.close();
            });
        });
    }
    
    function exportAsJPEG(element, width, height) {
        html2canvas(element, {
            width: width,
            height: height,
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff'
        }).then(function(canvas) {
            canvas.toBlob(function(blob) {
                saveAs(blob, 'visualization.jpeg');
                window.close();
            }, 'image/jpeg', 0.9);
        });
    }
    
    function exportAsSVG(element) {
        // Créer un SVG contenant tous les graphiques
        const svgContainer = document.createElement('div');
        svgContainer.style.visibility = 'hidden';
        document.body.appendChild(svgContainer);
        
        const draw = SVG().addTo(svgContainer).size(width, height);
        
        // Capturer chaque graphique en SVG
        const canvases = element.querySelectorAll('canvas');
        let promises = [];
        
        canvases.forEach(function(canvas, index) {
            const promise = new Promise(function(resolve) {
                const chart = Chart.getChart(canvas);
                const chartSVG = chart.toBase64Image('image/svg+xml');
                
                const image = draw.image(chartSVG);
                image.move(0, index * (height / canvases.length)).size(width, height / canvases.length);
                
                resolve();
            });
            
            promises.push(promise);
        });
        
        Promise.all(promises).then(function() {
            const svgData = draw.svg();
            const blob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            saveAs(blob, 'visualization.svg');
            window.close();
        });
    }
    
    function exportAsPDF(element, width, height) {
        html2canvas(element, {
            width: width,
            height: height,
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff'
        }).then(function(canvas) {
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jspdf.jsPDF({
                orientation: width > height ? 'landscape' : 'portrait',
                unit: 'mm',
                format: 'a4'
            });
            
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            const ratio = Math.min(pdfWidth / width, pdfHeight / height);
            const pdfImgWidth = width * ratio;
            const pdfImgHeight = height * ratio;
            
            pdf.addImage(imgData, 'PNG', 0, 0, pdfImgWidth, pdfImgHeight);
            pdf.save('visualization.pdf');
            window.close();
        });
    }
});
</script>
"@
    
    # Insérer les scripts d'export avant la balise </body>
    $html = $html -replace "</body>", "$exportScripts</body>"
    
    return $html
}

# Fonction pour exporter une visualisation en image
function Export-VisualizationImage {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [string]$VisualizationPath,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputPath,
        
        [Parameter(Mandatory = $false)]
        [ValidateSet("PNG", "JPEG", "SVG", "PDF")]
        [string]$Format = "PNG",
        
        [Parameter(Mandatory = $false)]
        [int]$Width = 1200,
        
        [Parameter(Mandatory = $false)]
        [int]$Height = 800,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeTimestamp,
        
        [Parameter(Mandatory = $false)]
        [switch]$IncludeWatermark,
        
        [Parameter(Mandatory = $false)]
        [string]$WatermarkText = "Generated by Roadmap RAG"
    )
    
    # Vérifier si le chemin de visualisation est spécifié
    if ([string]::IsNullOrEmpty($VisualizationPath)) {
        # Afficher une boîte de dialogue pour sélectionner un fichier
        Add-Type -AssemblyName System.Windows.Forms
        $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
        $openFileDialog.Filter = "Visualization files (*.json)|*.json|All files (*.*)|*.*"
        $openFileDialog.Title = "Select a visualization file"
        
        if ($openFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
            $VisualizationPath = $openFileDialog.FileName
        } else {
            Write-Log "No visualization file selected" -Level "Warning"
            return $false
        }
    }
    
    # Charger la visualisation
    $visualization = Get-VisualizationFromFile -VisualizationPath $VisualizationPath
    
    if ($null -eq $visualization) {
        return $false
    }
    
    # Générer le HTML avec les scripts d'export
    $html = Get-ExportHtml -Visualization $visualization -Format $Format -Width $Width -Height $Height -IncludeTimestamp:$IncludeTimestamp -IncludeWatermark:$IncludeWatermark -WatermarkText $WatermarkText
    
    # Créer un fichier HTML temporaire
    $tempFile = [System.IO.Path]::GetTempFileName() -replace '\.tmp$', '.html'
    $html | Out-File -FilePath $tempFile -Encoding UTF8
    
    # Déterminer le chemin de sortie si non spécifié
    if ([string]::IsNullOrEmpty($OutputPath)) {
        $extension = $Format.ToLower()
        $OutputPath = [System.IO.Path]::ChangeExtension($VisualizationPath, $extension)
    }
    
    # Créer le répertoire de sortie s'il n'existe pas
    $outputDir = [System.IO.Path]::GetDirectoryName($OutputPath)
    if (-not (Test-Path -Path $outputDir)) {
        New-Item -Path $outputDir -ItemType Directory -Force | Out-Null
    }
    
    # Ouvrir le fichier HTML dans un navigateur pour déclencher l'export
    Write-Log "Opening visualization in browser for export..." -Level "Info"
    Write-Log "The browser will automatically close after export is complete" -Level "Info"
    Write-Log "Output will be saved to: $OutputPath" -Level "Info"
    
    Start-Process $tempFile
    
    # Attendre que l'utilisateur confirme que l'export est terminé
    $confirmation = Read-Host "Press Enter when the export is complete (browser should close automatically)"
    
    # Vérifier si le fichier a été créé
    if (Test-Path -Path $OutputPath) {
        Write-Log "Visualization exported successfully to: $OutputPath" -Level "Info"
        return $true
    } else {
        Write-Log "Export file not found. Make sure to save the file to: $OutputPath" -Level "Warning"
        return $false
    }
}

# Exécuter la fonction principale si le script est exécuté directement
if ($MyInvocation.InvocationName -eq $MyInvocation.MyCommand.Name) {
    Export-VisualizationImage -VisualizationPath $VisualizationPath -OutputPath $OutputPath -Format $Format -Width $Width -Height $Height -IncludeTimestamp:$IncludeTimestamp -IncludeWatermark:$IncludeWatermark -WatermarkText $WatermarkText
}
