# Makefile pour Error Resolution Pipeline Go Native
# Version 1.0.0

.PHONY: help build test clean install run metrics docker docs

# Variables
BINARY_NAME=pipeline
VERSION=1.0.0
BUILD_DIR=./build
CONFIG_FILE=src/config/pipeline_config.json
TARGET_PATH=../../.github/docs/algorithms

# Couleurs pour l'affichage
CYAN=\033[36m
GREEN=\033[32m
YELLOW=\033[33m
RED=\033[31m
NC=\033[0m # No Color

help: ## Affiche l'aide
	@echo "$(CYAN)Error Resolution Pipeline Go Native v$(VERSION)$(NC)"
	@echo "$(YELLOW)Commandes disponibles:$(NC)"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  $(GREEN)%-15s$(NC) %s\n", $$1, $$2}'

build: ## Compile le pipeline
	@echo "$(CYAN)üî® Compilation du pipeline...$(NC)"
	@go mod download
	@mkdir -p $(BUILD_DIR)
	@go build -ldflags="-X main.Version=$(VERSION)" -o $(BUILD_DIR)/$(BINARY_NAME) ./cmd/pipeline
	@echo "$(GREEN)‚úì Pipeline compil√© avec succ√®s dans $(BUILD_DIR)/$(BINARY_NAME)$(NC)"

build-windows: ## Compile pour Windows
	@echo "$(CYAN)üî® Compilation pour Windows...$(NC)"
	@mkdir -p $(BUILD_DIR)
	@GOOS=windows GOARCH=amd64 go build -ldflags="-X main.Version=$(VERSION)" -o $(BUILD_DIR)/$(BINARY_NAME).exe ./cmd/pipeline
	@echo "$(GREEN)‚úì Binary Windows cr√©√©: $(BUILD_DIR)/$(BINARY_NAME).exe$(NC)"

test: ## Lance les tests unitaires
	@echo "$(CYAN)üß™ Lancement des tests...$(NC)"
	@go test -v ./pkg/...
	@echo "$(GREEN)‚úì Tests termin√©s$(NC)"

test-coverage: ## Lance les tests avec couverture
	@echo "$(CYAN)üìä Tests avec couverture...$(NC)"
	@go test -coverprofile=coverage.out ./pkg/...
	@go tool cover -html=coverage.out -o coverage.html
	@echo "$(GREEN)‚úì Rapport de couverture g√©n√©r√©: coverage.html$(NC)"

clean: ## Nettoie les fichiers de build
	@echo "$(CYAN)üßπ Nettoyage...$(NC)"
	@rm -rf $(BUILD_DIR)
	@rm -f coverage.out coverage.html
	@rm -f *.exe
	@echo "$(GREEN)‚úì Nettoyage termin√©$(NC)"

install: build ## Installe le binary dans $GOPATH/bin
	@echo "$(CYAN)üì¶ Installation...$(NC)"
	@cp $(BUILD_DIR)/$(BINARY_NAME) $(GOPATH)/bin/
	@echo "$(GREEN)‚úì Pipeline install√© dans $(GOPATH)/bin/$(NC)"

run: build ## Lance le pipeline avec la config par d√©faut
	@echo "$(CYAN)üöÄ Lancement du pipeline...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -config $(CONFIG_FILE) -target $(TARGET_PATH)

run-dry: build ## Lance le pipeline en mode dry-run
	@echo "$(CYAN)üß™ Lancement en mode dry-run...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -config $(CONFIG_FILE) -target $(TARGET_PATH) -dry-run

run-verbose: build ## Lance le pipeline en mode verbose
	@echo "$(CYAN)üîç Lancement en mode verbose...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -config $(CONFIG_FILE) -target $(TARGET_PATH) -verbose

run-test: ## Lance le script de test PowerShell
	@echo "$(CYAN)üß™ Lancement du script de test...$(NC)"
	@powershell -ExecutionPolicy Bypass -File scripts/test-pipeline.ps1

metrics: ## D√©marre uniquement le serveur de m√©triques
	@echo "$(CYAN)üìä D√©marrage du serveur de m√©triques...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -metrics-only -port 9090

fmt: ## Formate le code Go
	@echo "$(CYAN)‚ú® Formatage du code...$(NC)"
	@go fmt ./...
	@echo "$(GREEN)‚úì Code format√©$(NC)"

lint: ## Lance le linter Go
	@echo "$(CYAN)üîç Linting...$(NC)"
	@golint ./...
	@go vet ./...
	@echo "$(GREEN)‚úì Linting termin√©$(NC)"

vet: ## Lance go vet
	@echo "$(CYAN)üîç Go vet...$(NC)"
	@go vet ./...
	@echo "$(GREEN)‚úì Go vet termin√©$(NC)"

deps: ## Met √† jour les d√©pendances
	@echo "$(CYAN)üì¶ Mise √† jour des d√©pendances...$(NC)"
	@go mod tidy
	@go mod download
	@echo "$(GREEN)‚úì D√©pendances mises √† jour$(NC)"

init-workspace: ## Initialise un nouveau workspace
	@echo "$(CYAN)üèóÔ∏è Initialisation du workspace...$(NC)"
	@mkdir -p src/config src/modules reports patches metrics
	@mkdir -p pkg/detector pkg/resolver pkg/monitor
	@mkdir -p cmd/pipeline cmd/analyzer
	@mkdir -p tests/unit tests/integration
	@mkdir -p docs/api docs/architecture
	@echo "$(GREEN)‚úì Workspace initialis√©$(NC)"

docker-build: ## Construit l'image Docker
	@echo "$(CYAN)üê≥ Construction de l'image Docker...$(NC)"
	@docker build -t error-resolution-pipeline:$(VERSION) .
	@echo "$(GREEN)‚úì Image Docker cr√©√©e$(NC)"

docker-run: docker-build ## Lance le pipeline dans Docker
	@echo "$(CYAN)üê≥ Lancement du pipeline dans Docker...$(NC)"
	@docker run --rm -v $(PWD)/$(TARGET_PATH):/data error-resolution-pipeline:$(VERSION)

benchmark: ## Lance les benchmarks
	@echo "$(CYAN)‚ö° Lancement des benchmarks...$(NC)"
	@go test -bench=. -benchmem ./pkg/...
	@echo "$(GREEN)‚úì Benchmarks termin√©s$(NC)"

profile: build ## Profile le pipeline
	@echo "$(CYAN)üìä Profiling du pipeline...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -config $(CONFIG_FILE) -target $(TARGET_PATH) -cpuprofile=cpu.prof -memprofile=mem.prof
	@echo "$(GREEN)‚úì Profils g√©n√©r√©s: cpu.prof, mem.prof$(NC)"

docs-gen: ## G√©n√®re la documentation
	@echo "$(CYAN)üìö G√©n√©ration de la documentation...$(NC)"
	@godoc -http=:6060 &
	@echo "$(GREEN)‚úì Documentation disponible sur http://localhost:6060$(NC)"

validate-config: ## Valide la configuration
	@echo "$(CYAN)‚úÖ Validation de la configuration...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -config $(CONFIG_FILE) -validate-config-only
	@echo "$(GREEN)‚úì Configuration valide$(NC)"

analyze-algorithms: build ## Analyse sp√©cifiquement les algorithmes existants
	@echo "$(CYAN)üîç Analyse des algorithmes existants...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -config $(CONFIG_FILE) -target ../../.github/docs/algorithms -mode algorithms-only

fix-errors: build ## Applique les fixes automatiques
	@echo "$(CYAN)üîß Application des fixes automatiques...$(NC)"
	@$(BUILD_DIR)/$(BINARY_NAME) -config $(CONFIG_FILE) -target $(TARGET_PATH) -auto-fix
	@echo "$(YELLOW)‚ö†Ô∏è V√©rifiez les modifications et les backups cr√©√©s$(NC)"

status: ## Affiche le statut du pipeline
	@echo "$(CYAN)üìä Statut du Error Resolution Pipeline$(NC)"
	@echo "Version: $(VERSION)"
	@echo "Configuration: $(CONFIG_FILE)"
	@echo "Cible par d√©faut: $(TARGET_PATH)"
	@if [ -f $(BUILD_DIR)/$(BINARY_NAME) ]; then echo "$(GREEN)‚úì Binary compil√©$(NC)"; else echo "$(RED)‚úó Binary non compil√©$(NC)"; fi
	@if [ -f $(CONFIG_FILE) ]; then echo "$(GREEN)‚úì Configuration trouv√©e$(NC)"; else echo "$(RED)‚úó Configuration manquante$(NC)"; fi

all: clean deps fmt vet test build ## Lance toutes les √©tapes (clean, deps, fmt, vet, test, build)
	@echo "$(GREEN)üéâ Build complet termin√© avec succ√®s!$(NC)"

# Cibles pour l'int√©gration continue
ci-test: deps fmt vet test ## Tests pour CI
ci-build: ci-test build ## Build pour CI

# Version information
version: ## Affiche la version
	@echo "Error Resolution Pipeline v$(VERSION)"

# Aide par d√©faut
.DEFAULT_GOAL := help
