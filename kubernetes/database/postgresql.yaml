# Enterprise Database Stack
# Ultra-Advanced 8-Level Branching Framework - Database Infrastructure
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgresql-enterprise-config
  namespace: branching-framework-enterprise
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: database
    app.kubernetes.io/version: "15.4"
    environment: production
    tier: enterprise
data:
  postgresql.conf: |
    # PostgreSQL Enterprise Configuration for Branching Framework
    
    # Connection Settings
    listen_addresses = '*'
    port = 5432
    max_connections = 1000
    superuser_reserved_connections = 10
    
    # Memory Settings
    shared_buffers = 4GB
    effective_cache_size = 12GB
    work_mem = 64MB
    maintenance_work_mem = 1GB
    max_wal_size = 4GB
    min_wal_size = 1GB
    
    # Performance Settings
    random_page_cost = 1.1
    effective_io_concurrency = 200
    max_worker_processes = 16
    max_parallel_workers_per_gather = 4
    max_parallel_workers = 16
    max_parallel_maintenance_workers = 4
    
    # Write-Ahead Logging
    wal_level = replica
    wal_buffers = 64MB
    checkpoint_completion_target = 0.9
    checkpoint_timeout = 10min
    max_wal_senders = 10
    hot_standby = on
    
    # Logging
    log_destination = 'stderr'
    logging_collector = on
    log_directory = '/var/log/postgresql'
    log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
    log_file_mode = 0644
    log_rotation_age = 1d
    log_rotation_size = 100MB
    log_min_duration_statement = 1000
    log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
    log_checkpoints = on
    log_connections = on
    log_disconnections = on
    log_lock_waits = on
    log_temp_files = 10MB
    
    # Security
    ssl = on
    ssl_cert_file = '/etc/ssl/certs/server.crt'
    ssl_key_file = '/etc/ssl/private/server.key'
    ssl_ca_file = '/etc/ssl/certs/ca.crt'
    ssl_ciphers = 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384'
    ssl_prefer_server_ciphers = on
    ssl_min_protocol_version = 'TLSv1.2'
    
    # Replication
    archive_mode = on
    archive_command = 'wal-g wal-push %p'
    restore_command = 'wal-g wal-fetch %f %p'
    
    # Monitoring
    track_activities = on
    track_counts = on
    track_io_timing = on
    track_functions = all
    stats_temp_directory = '/var/run/postgresql/stats_temp'
    
  pg_hba.conf: |
    # PostgreSQL Client Authentication Configuration
    
    # TYPE  DATABASE        USER            ADDRESS                 METHOD
    
    # "local" is for Unix domain socket connections only
    local   all             all                                     peer
    
    # IPv4 local connections:
    host    all             all             127.0.0.1/32            scram-sha-256
    
    # IPv6 local connections:
    host    all             all             ::1/128                 scram-sha-256
    
    # Allow replication connections from localhost, by a user with the
    # replication privilege.
    local   replication     all                                     peer
    host    replication     all             127.0.0.1/32            scram-sha-256
    host    replication     all             ::1/128                 scram-sha-256
    
    # Kubernetes pod network
    host    all             all             10.0.0.0/8              scram-sha-256
    host    all             all             172.16.0.0/12           scram-sha-256
    host    all             all             192.168.0.0/16          scram-sha-256
    
    # Enterprise authentication
    host    branching_framework_enterprise  branching_framework_enterprise  0.0.0.0/0  scram-sha-256
    host    replication     postgres        0.0.0.0/0               scram-sha-256
    
  init-database.sql: |
    -- Initialize Enterprise Database for Branching Framework
    
    -- Create enterprise database and user
    CREATE DATABASE branching_framework_enterprise WITH 
        ENCODING = 'UTF8'
        LC_COLLATE = 'en_US.UTF-8'
        LC_CTYPE = 'en_US.UTF-8'
        TEMPLATE = template0;
    
    -- Create enterprise user with restricted privileges
    CREATE USER branching_framework_enterprise WITH 
        PASSWORD 'CHANGE_ME_ENTERPRISE_POSTGRES_PASSWORD'
        CREATEDB
        NOSUPERUSER
        NOCREATEROLE;
    
    -- Grant necessary privileges
    GRANT ALL PRIVILEGES ON DATABASE branching_framework_enterprise TO branching_framework_enterprise;
    
    -- Connect to the enterprise database
    \c branching_framework_enterprise;
    
    -- Create extensions
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    CREATE EXTENSION IF NOT EXISTS "pg_trgm";
    CREATE EXTENSION IF NOT EXISTS "btree_gin";
    CREATE EXTENSION IF NOT EXISTS "btree_gist";
    CREATE EXTENSION IF NOT EXISTS "pgcrypto";
    CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";
    
    -- Create schemas
    CREATE SCHEMA IF NOT EXISTS branching;
    CREATE SCHEMA IF NOT EXISTS ai_models;
    CREATE SCHEMA IF NOT EXISTS enterprise;
    CREATE SCHEMA IF NOT EXISTS audit;
    CREATE SCHEMA IF NOT EXISTS monitoring;
    
    -- Grant schema permissions
    GRANT ALL ON SCHEMA branching TO branching_framework_enterprise;
    GRANT ALL ON SCHEMA ai_models TO branching_framework_enterprise;
    GRANT ALL ON SCHEMA enterprise TO branching_framework_enterprise;
    GRANT ALL ON SCHEMA audit TO branching_framework_enterprise;
    GRANT ALL ON SCHEMA monitoring TO branching_framework_enterprise;
    
    -- Create enterprise-specific tables
    CREATE TABLE IF NOT EXISTS enterprise.tenants (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        name VARCHAR(255) NOT NULL UNIQUE,
        domain VARCHAR(255) NOT NULL UNIQUE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        settings JSONB DEFAULT '{}',
        is_active BOOLEAN DEFAULT true
    );
    
    CREATE TABLE IF NOT EXISTS enterprise.users (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        tenant_id UUID REFERENCES enterprise.tenants(id) ON DELETE CASCADE,
        email VARCHAR(255) NOT NULL,
        name VARCHAR(255) NOT NULL,
        role VARCHAR(50) NOT NULL DEFAULT 'user',
        sso_provider VARCHAR(100),
        sso_id VARCHAR(255),
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        last_login TIMESTAMP WITH TIME ZONE,
        is_active BOOLEAN DEFAULT true,
        UNIQUE(tenant_id, email)
    );
    
    CREATE TABLE IF NOT EXISTS enterprise.subscriptions (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        tenant_id UUID REFERENCES enterprise.tenants(id) ON DELETE CASCADE,
        plan VARCHAR(50) NOT NULL,
        features JSONB DEFAULT '{}',
        limits JSONB DEFAULT '{}',
        billing_cycle VARCHAR(20) DEFAULT 'monthly',
        amount DECIMAL(10,2),
        currency VARCHAR(3) DEFAULT 'USD',
        status VARCHAR(20) DEFAULT 'active',
        started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        ends_at TIMESTAMP WITH TIME ZONE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );
    
    -- Create audit tables
    CREATE TABLE IF NOT EXISTS audit.activity_log (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        tenant_id UUID REFERENCES enterprise.tenants(id) ON DELETE CASCADE,
        user_id UUID REFERENCES enterprise.users(id) ON DELETE SET NULL,
        action VARCHAR(100) NOT NULL,
        resource_type VARCHAR(100),
        resource_id VARCHAR(255),
        details JSONB DEFAULT '{}',
        ip_address INET,
        user_agent TEXT,
        timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        session_id VARCHAR(255)
    );
    
    -- Create monitoring tables
    CREATE TABLE IF NOT EXISTS monitoring.performance_metrics (
        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
        tenant_id UUID REFERENCES enterprise.tenants(id) ON DELETE CASCADE,
        metric_name VARCHAR(100) NOT NULL,
        metric_value DECIMAL(15,6),
        labels JSONB DEFAULT '{}',
        timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );
    
    -- Create indexes for performance
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tenants_domain ON enterprise.tenants(domain);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tenants_active ON enterprise.tenants(is_active);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_tenant_email ON enterprise.users(tenant_id, email);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_sso ON enterprise.users(sso_provider, sso_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_subscriptions_tenant ON enterprise.subscriptions(tenant_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_subscriptions_status ON enterprise.subscriptions(status);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_activity_log_tenant_time ON audit.activity_log(tenant_id, timestamp);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_activity_log_user_time ON audit.activity_log(user_id, timestamp);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_activity_log_action ON audit.activity_log(action);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_performance_metrics_tenant_name_time ON monitoring.performance_metrics(tenant_id, metric_name, timestamp);
    
    -- Create GIN indexes for JSONB columns
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tenants_settings_gin ON enterprise.tenants USING GIN(settings);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_subscriptions_features_gin ON enterprise.subscriptions USING GIN(features);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_subscriptions_limits_gin ON enterprise.subscriptions USING GIN(limits);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_activity_log_details_gin ON audit.activity_log USING GIN(details);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_performance_metrics_labels_gin ON monitoring.performance_metrics USING GIN(labels);
    
    -- Create functions for updated_at triggers
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ language 'plpgsql';
    
    -- Create triggers for updated_at
    CREATE TRIGGER update_tenants_updated_at BEFORE UPDATE ON enterprise.tenants
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON enterprise.users
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON enterprise.subscriptions
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    
    -- Grant all necessary permissions to the enterprise user
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA branching TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA ai_models TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA enterprise TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA audit TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA monitoring TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA branching TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA ai_models TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA enterprise TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA audit TO branching_framework_enterprise;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA monitoring TO branching_framework_enterprise;
    
    -- Set default privileges for future objects
    ALTER DEFAULT PRIVILEGES IN SCHEMA branching GRANT ALL ON TABLES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA ai_models GRANT ALL ON TABLES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA enterprise GRANT ALL ON TABLES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA audit GRANT ALL ON TABLES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA monitoring GRANT ALL ON TABLES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA branching GRANT ALL ON SEQUENCES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA ai_models GRANT ALL ON SEQUENCES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA enterprise GRANT ALL ON SEQUENCES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA audit GRANT ALL ON SEQUENCES TO branching_framework_enterprise;
    ALTER DEFAULT PRIVILEGES IN SCHEMA monitoring GRANT ALL ON SEQUENCES TO branching_framework_enterprise;
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgresql-enterprise
  namespace: branching-framework-enterprise
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: database
    app.kubernetes.io/version: "15.4"
    environment: production
    tier: enterprise
spec:
  serviceName: postgresql-enterprise
  replicas: 3  # Primary + 2 read replicas
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 0
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/component: database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/component: database
        app.kubernetes.io/version: "15.4"
        environment: production
        tier: enterprise
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9187"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: postgresql-enterprise
      securityContext:
        runAsNonRoot: true
        runAsUser: 999
        runAsGroup: 999
        fsGroup: 999
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                - postgresql
            topologyKey: kubernetes.io/hostname
      containers:
      - name: postgresql
        image: postgres:15.4-alpine
        imagePullPolicy: IfNotPresent
        ports:
        - name: postgresql
          containerPort: 5432
          protocol: TCP
        env:
        - name: POSTGRES_DB
          value: "postgres"
        - name: POSTGRES_USER
          value: "postgres"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgresql-admin-credentials
              key: password
        - name: PGDATA
          value: "/var/lib/postgresql/data/pgdata"
        - name: POSTGRES_INITDB_ARGS
          value: "--encoding=UTF8 --lc-collate=en_US.UTF-8 --lc-ctype=en_US.UTF-8"
        resources:
          requests:
            memory: "8Gi"
            cpu: "2000m"
            ephemeral-storage: "10Gi"
          limits:
            memory: "16Gi"
            cpu: "4000m"
            ephemeral-storage: "20Gi"
        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U postgres -h localhost
          initialDelaySeconds: 30
          periodSeconds: 30
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U postgres -h localhost
          initialDelaySeconds: 5
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        startupProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U postgres -h localhost
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 30
        volumeMounts:
        - name: postgresql-data
          mountPath: /var/lib/postgresql/data
        - name: postgresql-config
          mountPath: /etc/postgresql
          readOnly: true
        - name: postgresql-init
          mountPath: /docker-entrypoint-initdb.d
          readOnly: true
        - name: postgresql-ssl
          mountPath: /etc/ssl
          readOnly: true
        - name: postgresql-logs
          mountPath: /var/log/postgresql
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 999
          runAsGroup: 999
      - name: postgres-exporter
        image: quay.io/prometheuscommunity/postgres-exporter:v0.13.2
        imagePullPolicy: IfNotPresent
        ports:
        - name: metrics
          containerPort: 9187
          protocol: TCP
        env:
        - name: DATA_SOURCE_NAME
          valueFrom:
            secretKeyRef:
              name: postgresql-admin-credentials
              key: data_source_name
        - name: PG_EXPORTER_EXTEND_QUERY_PATH
          value: "/etc/postgres-exporter/queries.yaml"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 5
          periodSeconds: 10
        volumeMounts:
        - name: postgres-exporter-config
          mountPath: /etc/postgres-exporter
          readOnly: true
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 65534
          runAsGroup: 65534
      volumes:
      - name: postgresql-config
        configMap:
          name: postgresql-enterprise-config
          defaultMode: 0444
      - name: postgresql-init
        configMap:
          name: postgresql-enterprise-config
          defaultMode: 0555
          items:
          - key: init-database.sql
            path: init-database.sql
      - name: postgresql-ssl
        secret:
          secretName: postgresql-ssl-certificates
          defaultMode: 0400
      - name: postgresql-logs
        emptyDir:
          sizeLimit: 10Gi
      - name: postgres-exporter-config
        configMap:
          name: postgres-exporter-config
          defaultMode: 0444
  volumeClaimTemplates:
  - metadata:
      name: postgresql-data
      labels:
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/component: database
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 500Gi
      storageClassName: fast-ssd
---
apiVersion: v1
kind: Service
metadata:
  name: postgresql-enterprise
  namespace: branching-framework-enterprise
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: database
    app.kubernetes.io/version: "15.4"
    environment: production
    tier: enterprise
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9187"
    prometheus.io/path: "/metrics"
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
  - name: postgresql
    port: 5432
    targetPort: postgresql
    protocol: TCP
  - name: metrics
    port: 9187
    targetPort: metrics
    protocol: TCP
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: database
---
apiVersion: v1
kind: Service
metadata:
  name: postgresql-enterprise-headless
  namespace: branching-framework-enterprise
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: database
    app.kubernetes.io/version: "15.4"
    environment: production
    tier: enterprise
spec:
  type: ClusterIP
  clusterIP: None
  publishNotReadyAddresses: true
  ports:
  - name: postgresql
    port: 5432
    targetPort: postgresql
    protocol: TCP
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/component: database
