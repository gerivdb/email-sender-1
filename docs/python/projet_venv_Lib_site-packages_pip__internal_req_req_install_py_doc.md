Help on module req_install:

NAME
    req_install

CLASSES
    builtins.object
        InstallRequirement

    class InstallRequirement(builtins.object)
     |  InstallRequirement(req: Optional[pip._vendor.packaging.requirements.Requirement], comes_from: Union[str, ForwardRef('InstallRequirement'), NoneType], editable: bool = False, link: Optional[pip._internal.models.link.Link] = None, markers: Optional[pip._vendor.packaging.markers.Marker] = None, use_pep517: Optional[bool] = None, isolated: bool = False, *, global_options: Optional[List[str]] = None, hash_options: Optional[Dict[str, List[str]]] = None, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None, constraint: bool = False, extras: Collection[str] = (), user_supplied: bool = False, permit_editable_wheels: bool = False) -> None
     |
     |  Represents something that may be installed later on, may have information
     |  about where to fetch the relevant requirement and also contains logic for
     |  installing the said requirement.
     |
     |  Methods defined here:
     |
     |  __init__(self, req: Optional[pip._vendor.packaging.requirements.Requirement], comes_from: Union[str, ForwardRef('InstallRequirement'), NoneType], editable: bool = False, link: Optional[pip._internal.models.link.Link] = None, markers: Optional[pip._vendor.packaging.markers.Marker] = None, use_pep517: Optional[bool] = None, isolated: bool = False, *, global_options: Optional[List[str]] = None, hash_options: Optional[Dict[str, List[str]]] = None, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None, constraint: bool = False, extras: Collection[str] = (), user_supplied: bool = False, permit_editable_wheels: bool = False) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  __repr__(self) -> str
     |      Return repr(self).
     |
     |  __str__(self) -> str
     |      Return str(self).
     |
     |  archive(self, build_dir: Optional[str]) -> None
     |      Saves archive to provided build_dir.
     |
     |      Used for saving downloaded VCS requirements as part of `pip download`.
     |
     |  assert_source_matches_version(self) -> None
     |
     |  check_if_exists(self, use_user_site: bool) -> None
     |      Find an installed distribution that satisfies or conflicts
     |      with this requirement, and set self.satisfied_by or
     |      self.should_reinstall appropriately.
     |
     |  ensure_build_location(self, build_dir: str, autodelete: bool, parallel_builds: bool) -> str
     |
     |  ensure_has_source_dir(self, parent_dir: str, autodelete: bool = False, parallel_builds: bool = False) -> None
     |      Ensure that a source_dir is set.
     |
     |      This will create a temporary build dir if the name of the requirement
     |      isn't known yet.
     |
     |      :param parent_dir: The ideal pip parent_dir for the source_dir.
     |          Generally src_dir for editables and build_dir for sdists.
     |      :return: self.source_dir
     |
     |  ensure_pristine_source_checkout(self) -> None
     |      Ensure the source directory has not yet been built in.
     |
     |  format_debug(self) -> str
     |      An un-tested helper for getting state, for debugging.
     |
     |  from_path(self) -> Optional[str]
     |      Format a nice indicator to show where this "comes from"
     |
     |  get_dist(self) -> pip._internal.metadata.base.BaseDistribution
     |
     |  hashes(self, trust_internet: bool = True) -> pip._internal.utils.hashes.Hashes
     |      Return a hash-comparer that considers my option- and URL-based
     |      hashes to be known-good.
     |
     |      Hashes in URLs--ones embedded in the requirements file, not ones
     |      downloaded from an index server--are almost peers with ones from
     |      flags. They satisfy --require-hashes (whether it was implicitly or
     |      explicitly activated) but do not activate it. md5 and sha224 are not
     |      allowed in flags, which should nudge people toward good algos. We
     |      always OR all hashes together, even ones from URLs.
     |
     |      :param trust_internet: Whether to trust URL-based (#md5=...) hashes
     |          downloaded from the internet, as by populate_link()
     |
     |  install(self, global_options: Optional[Sequence[str]] = None, root: Optional[str] = None, home: Optional[str] = None, prefix: Optional[str] = None, warn_script_location: bool = True, use_user_site: bool = False, pycompile: bool = True) -> None
     |
     |  isolated_editable_sanity_check(self) -> None
     |      Check that an editable requirement if valid for use with PEP 517/518.
     |
     |      This verifies that an editable that has a pyproject.toml either supports PEP 660
     |      or as a setup.py or a setup.cfg
     |
     |  load_pyproject_toml(self) -> None
     |      Load the pyproject.toml file.
     |
     |      After calling this routine, all of the attributes related to PEP 517
     |      processing for this requirement have been set. In particular, the
     |      use_pep517 attribute can be used to determine whether we should
     |      follow the PEP 517 or legacy (setup.py) code path.
     |
     |  match_markers(self, extras_requested: Optional[Iterable[str]] = None) -> bool
     |
     |  needs_unpacked_archive(self, archive_source: pathlib.Path) -> None
     |
     |  prepare_metadata(self) -> None
     |      Ensure that project metadata is available.
     |
     |      Under PEP 517 and PEP 660, call the backend hook to prepare the metadata.
     |      Under legacy processing, call setup.py egg-info.
     |
     |  supports_pyproject_editable = <functools.cached_property object>
     |  uninstall(self, auto_confirm: bool = False, verbose: bool = False) -> Optional[pip._internal.req.req_uninstall.UninstallPathSet]
     |      Uninstall the distribution currently satisfying this requirement.
     |
     |      Prompts before removing or modifying files unless
     |      ``auto_confirm`` is True.
     |
     |      Refuses to delete or modify files outside of ``sys.prefix`` -
     |      thus uninstallation within a virtual environment can only
     |      modify that virtual environment, even if the virtualenv is
     |      linked to global site-packages.
     |
     |  update_editable(self) -> None
     |      # For editable installations
     |
     |  warn_on_mismatching_name(self) -> None
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  has_hash_options
     |      Return whether any known-good hashes are specified as options.
     |
     |      These activate --require-hashes mode; hashes specified as part of a
     |      URL do not.
     |
     |  is_direct
     |      Whether this requirement was specified as a direct URL.
     |
     |  is_pinned
     |      Return whether I am pinned to an exact version.
     |
     |      For example, some-package==1.2 is pinned; some-package>1.2 is not.
     |
     |  is_wheel
     |
     |  is_wheel_from_cache
     |
     |  metadata
     |
     |  name
     |
     |  pyproject_toml_path
     |
     |  setup_cfg_path
     |
     |  setup_py_path
     |
     |  specifier
     |
     |  unpacked_source_directory
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

FUNCTIONS
    check_invalid_constraint_type(req: req_install.InstallRequirement) -> str

    check_legacy_setup_py_options(options: optparse.Values, reqs: List[req_install.InstallRequirement]) -> None

DATA
    Collection = typing.Collection
        A generic version of collections.abc.Collection.

    Dict = typing.Dict
        A generic version of dict.

    Iterable = typing.Iterable
        A generic version of collections.abc.Iterable.

    List = typing.List
        A generic version of list.

    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    Sequence = typing.Sequence
        A generic version of collections.abc.Sequence.

    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.

        On Python 3.10 and higher, the | operator
        can also be used to denote unions;
        X | Y means the same thing to the type checker as Union[X, Y].

        To define a union, use e.g. Union[int, str]. Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::

            assert Union[Union[int, str], float] == Union[int, str, float]

        - Unions of a single argument vanish, e.g.::

            assert Union[int] == int  # The constructor actually returns int

        - Redundant arguments are skipped, e.g.::

            assert Union[int, str, int] == Union[int, str]

        - When comparing unions, the argument order is ignored, e.g.::

            assert Union[int, str] == Union[str, int]

        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].

    logger = <VerboseLogger req_install (WARNING)>
    vcs = <pip._internal.vcs.versioncontrol.VcsSupport object>

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_internal\req\req_install.py


