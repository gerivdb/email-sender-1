Help on module check:

NAME
    check - Validation of dependencies of packages

CLASSES
    builtins.tuple(builtins.object)
        PackageDetails

    class PackageDetails(builtins.tuple)
     |  PackageDetails(version: pip._vendor.packaging.version.Version, dependencies: List[pip._vendor.packaging.requirements.Requirement])
     |
     |  PackageDetails(version, dependencies)
     |
     |  Method resolution order:
     |      PackageDetails
     |      builtins.tuple
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __getnewargs__(self) from collections.PackageDetails
     |      Return self as a plain tuple.  Used by copy and pickle.
     |
     |  __repr__(self) from collections.PackageDetails
     |      Return a nicely formatted representation string
     |
     |  _asdict(self) from collections.PackageDetails
     |      Return a new dict which maps field names to their values.
     |
     |  _replace(self, /, **kwds) from collections.PackageDetails
     |      Return a new PackageDetails object replacing specified fields with new values
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  _make(iterable) from collections.PackageDetails
     |      Make a new PackageDetails object from a sequence or iterable
     |
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |
     |  __new__(_cls, version: pip._vendor.packaging.version.Version, dependencies: List[pip._vendor.packaging.requirements.Requirement]) from namedtuple_PackageDetails.PackageDetails
     |      Create new instance of PackageDetails(version, dependencies)
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  version
     |      Alias for field number 0
     |
     |  dependencies
     |      Alias for field number 1
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'dependencies': typing.List[pip._vendor.packaging.r...
     |
     |  __match_args__ = ('version', 'dependencies')
     |
     |  __orig_bases__ = (<function NamedTuple>,)
     |
     |  _field_defaults = {}
     |
     |  _fields = ('version', 'dependencies')
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.tuple:
     |
     |  __add__(self, value, /)
     |      Return self+value.
     |
     |  __contains__(self, key, /)
     |      Return bool(key in self).
     |
     |  __eq__(self, value, /)
     |      Return self==value.
     |
     |  __ge__(self, value, /)
     |      Return self>=value.
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __getitem__(self, key, /)
     |      Return self[key].
     |
     |  __gt__(self, value, /)
     |      Return self>value.
     |
     |  __hash__(self, /)
     |      Return hash(self).
     |
     |  __iter__(self, /)
     |      Implement iter(self).
     |
     |  __le__(self, value, /)
     |      Return self<=value.
     |
     |  __len__(self, /)
     |      Return len(self).
     |
     |  __lt__(self, value, /)
     |      Return self<value.
     |
     |  __mul__(self, value, /)
     |      Return self*value.
     |
     |  __ne__(self, value, /)
     |      Return self!=value.
     |
     |  __rmul__(self, value, /)
     |      Return value*self.
     |
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |
     |      Raises ValueError if the value is not present.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.tuple:
     |
     |  __class_getitem__(...)
     |      See PEP 585

FUNCTIONS
    check_install_conflicts(to_install: List[pip._internal.req.req_install.InstallRequirement]) -> Tuple[Dict[pip._vendor.packaging.utils.NormalizedName, check.PackageDetails], Tuple[Dict[pip._vendor.packaging.utils.NormalizedName, List[Tuple[pip._vendor.packaging.utils.NormalizedName, pip._vendor.packaging.requirements.Requirement]]], Dict[pip._vendor.packaging.utils.NormalizedName, List[Tuple[pip._vendor.packaging.utils.NormalizedName, pip._vendor.packaging.version.Version, pip._vendor.packaging.requirements.Requirement]]]]]
        For checking if the dependency graph would be consistent after     installing given requirements

    check_package_set(package_set: Dict[pip._vendor.packaging.utils.NormalizedName, check.PackageDetails], should_ignore: Optional[Callable[[str], bool]] = None) -> Tuple[Dict[pip._vendor.packaging.utils.NormalizedName, List[Tuple[pip._vendor.packaging.utils.NormalizedName, pip._vendor.packaging.requirements.Requirement]]], Dict[pip._vendor.packaging.utils.NormalizedName, List[Tuple[pip._vendor.packaging.utils.NormalizedName, pip._vendor.packaging.version.Version, pip._vendor.packaging.requirements.Requirement]]]]
        Check if a package set is consistent

        If should_ignore is passed, it should be a callable that takes a
        package name and returns a boolean.

    check_unsupported(packages: Iterable[pip._internal.metadata.base.BaseDistribution], supported_tags: Iterable[pip._vendor.packaging.tags.Tag]) -> Generator[pip._internal.metadata.base.BaseDistribution, NoneType, NoneType]

    create_package_set_from_installed() -> Tuple[Dict[pip._vendor.packaging.utils.NormalizedName, check.PackageDetails], bool]
        Converts a list of distributions into a PackageSet.

    reduce(...)
        reduce(function, iterable[, initial]) -> value

        Apply a function of two arguments cumulatively to the items of a sequence
        or iterable, from left to right, so as to reduce the iterable to a single
        value.  For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the iterable in the calculation, and serves as a default when the
        iterable is empty.

DATA
    Callable = typing.Callable
        Deprecated alias to collections.abc.Callable.

        Callable[[int], str] signifies a function that takes a single
        parameter of type int and returns a str.

        The subscription syntax must always be used with exactly two
        values: the argument list and the return type.
        The argument list must be a list of types, a ParamSpec,
        Concatenate or ellipsis. The return type must be a single type.

        There is no syntax to indicate optional or keyword arguments;
        such function types are rarely used as callback types.

    CheckResult = typing.Tuple[typing.Dict[pip._vendor.packaging.u...ip._v...
    ConflictDetails = typing.Tuple[typing.Dict[pip._vendor.packaging.u...p...
    Conflicting = typing.Tuple[pip._vendor.packaging.utils.Normali..., pip...
    ConflictingDict = typing.Dict[pip._vendor.packaging.utils.Normaliz...p...
    Dict = typing.Dict
        A generic version of dict.

    FrozenSet = typing.FrozenSet
        A generic version of frozenset.

    Generator = typing.Generator
        A generic version of collections.abc.Generator.

    Iterable = typing.Iterable
        A generic version of collections.abc.Iterable.

    List = typing.List
        A generic version of list.

    Missing = typing.Tuple[pip._vendor.packaging.utils.Normali..., pip._ve...
    MissingDict = typing.Dict[pip._vendor.packaging.utils.Normaliz...pip._...
    NormalizedName = pip._vendor.packaging.utils.NormalizedName
    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    PackageSet = typing.Dict[pip._vendor.packaging.utils.NormalizedName, c...
    Set = typing.Set
        A generic version of set.

    Tuple = typing.Tuple
        Deprecated alias to builtins.tuple.

        Tuple[X, Y] is the cross-product type of X and Y.

        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.

        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].

    logger = <VerboseLogger check (WARNING)>

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_internal\operations\check.py


