Help on module __init__:

NAME
    __init__

DESCRIPTION
    Package resource API
    --------------------

    A resource is a logical file contained within a package, or a logical
    subdirectory thereof.  The package resource API expects resource names
    to have their path parts separated with ``/``, *not* whatever the local
    path separator is.  Do not use os.path operations to manipulate resource
    names being passed into the API.

    The package resource API is designed to work with normal filesystem packages,
    .egg files, and unpacked .egg files.  It can also work in a limited way with
    .zip files and with custom PEP 302 loaders that support the ``get_data()``
    method.

    This module is deprecated. Users are directed to :mod:`importlib.resources`,
    :mod:`importlib.metadata` and :pypi:`packaging` instead.

CLASSES
    builtins.Exception(builtins.BaseException)
        ResolutionError
            DistributionNotFound
            UnknownExtra
            VersionConflict
    builtins.RuntimeError(builtins.Exception)
        ExtractionError
    builtins.RuntimeWarning(builtins.Warning)
        PEP440Warning
    builtins.Warning(builtins.Exception)
        PkgResourcesDeprecationWarning
    builtins.object
        Distribution
        EntryPoint
        Environment
        NullProvider
            EggProvider
                DefaultProvider
                    PathMetadata
                ZipProvider
                    EggMetadata
            EmptyProvider
                FileMetadata
        ResourceManager
        WorkingSet
    pip._vendor.packaging.requirements.Requirement(builtins.object)
        Requirement
    pip._vendor.packaging.version._BaseVersion(builtins.object)
        pip._vendor.packaging.version.Version
    typing.Protocol(typing.Generic)
        IMetadataProvider
            IResourceProvider(IMetadataProvider, typing.Protocol)

    AvailableDistributions = class Environment(builtins.object)
     |  AvailableDistributions(search_path: 'Iterable[str] | None' = None, platform: 'str | None' = 'win-amd64', python: 'str | None' = '3.12')
     |
     |  Searchable snapshot of distributions on a search path
     |
     |  Methods defined here:
     |
     |  __add__(self, other: 'Distribution | Environment')
     |      Add an environment or distribution to an environment
     |
     |  __getitem__(self, project_name: 'str') -> 'list[Distribution]'
     |      Return a newest-to-oldest list of distributions for `project_name`
     |
     |      Uses case-insensitive `project_name` comparison, assuming all the
     |      project's distributions use their project's name converted to all
     |      lowercase as their key.
     |
     |  __iadd__(self, other: 'Distribution | Environment')
     |      In-place addition of a distribution or environment
     |
     |  __init__(self, search_path: 'Iterable[str] | None' = None, platform: 'str | None' = 'win-amd64', python: 'str | None' = '3.12')
     |      Snapshot distributions available on a search path
     |
     |      Any distributions found on `search_path` are added to the environment.
     |      `search_path` should be a sequence of ``sys.path`` items.  If not
     |      supplied, ``sys.path`` is used.
     |
     |      `platform` is an optional string specifying the name of the platform
     |      that platform-specific distributions must be compatible with.  If
     |      unspecified, it defaults to the current platform.  `python` is an
     |      optional string naming the desired version of Python (e.g. ``'3.6'``);
     |      it defaults to the current version.
     |
     |      You may explicitly set `platform` (and/or `python`) to ``None`` if you
     |      wish to map *all* distributions, not just those compatible with the
     |      running platform or Python version.
     |
     |  __iter__(self) -> 'Iterator[str]'
     |      Yield the unique project names of the available distributions
     |
     |  add(self, dist: 'Distribution')
     |      Add `dist` if we ``can_add()`` it and it has not already been added
     |
     |  best_match(self, req: 'Requirement', working_set: 'WorkingSet', installer: '_InstallerType | None | _InstallerTypeT[_DistributionT]' = None, replace_conflicting: 'bool' = False) -> 'Distribution | None'
     |      Find distribution best matching `req` and usable on `working_set`
     |
     |      This calls the ``find(req)`` method of the `working_set` to see if a
     |      suitable distribution is already active.  (This may raise
     |      ``VersionConflict`` if an unsuitable version of the project is already
     |      active in the specified `working_set`.)  If a suitable distribution
     |      isn't active, this method returns the newest distribution in the
     |      environment that meets the ``Requirement`` in `req`.  If no suitable
     |      distribution is found, and `installer` is supplied, then the result of
     |      calling the environment's ``obtain(req, installer)`` method will be
     |      returned.
     |
     |  can_add(self, dist: 'Distribution')
     |      Is distribution `dist` acceptable for this environment?
     |
     |      The distribution must match the platform and python version
     |      requirements specified when this environment was created, or False
     |      is returned.
     |
     |  obtain(self, requirement: 'Requirement', installer: 'Callable[[Requirement], None] | _InstallerType | None | _InstallerTypeT[_DistributionT]' = None) -> 'Distribution | None'
     |      Obtain a distribution matching `requirement` (e.g. via download)
     |
     |      Obtain a distro that matches requirement (e.g. via download).  In the
     |      base ``Environment`` class, this routine just returns
     |      ``installer(requirement)``, unless `installer` is None, in which case
     |      None is returned instead.  This method is a hook that allows subclasses
     |      to attempt other ways of obtaining a distribution before falling back
     |      to the `installer` argument.
     |
     |  remove(self, dist: 'Distribution')
     |      Remove `dist` from the environment
     |
     |  scan(self, search_path: 'Iterable[str] | None' = None)
     |      Scan `search_path` for distributions usable in this environment
     |
     |      Any distributions found are added to the environment.
     |      `search_path` should be a sequence of ``sys.path`` items.  If not
     |      supplied, ``sys.path`` is used.  Only distributions conforming to
     |      the platform/python version defined at initialization are added.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

    class DefaultProvider(EggProvider)
     |  DefaultProvider(module: '_ModuleLike')
     |
     |  Provides access to package resources in the filesystem
     |
     |  Method resolution order:
     |      DefaultProvider
     |      EggProvider
     |      NullProvider
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  get_resource_stream(self, manager: 'object', resource_name: 'str')
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from EggProvider:
     |
     |  __init__(self, module: '_ModuleLike')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from NullProvider:
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NullProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NullProvider:
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    class Distribution(builtins.object)
     |  Distribution(location: 'str | None' = None, metadata: '_MetadataType' = None, project_name: 'str | None' = None, version: 'str | None' = None, py_version: 'str | None' = '3.12', platform: 'str | None' = None, precedence: 'int' = 3)
     |
     |  Wrap an actual or potential sys.path entry w/metadata
     |
     |  Methods defined here:
     |
     |  __dir__(self)
     |      Default dir() implementation.
     |
     |  __eq__(self, other: 'object')
     |      Return self==value.
     |
     |  __ge__(self, other: 'Distribution')
     |      Return self>=value.
     |
     |  __getattr__(self, attr)
     |      Delegate all unrecognized public attributes to .metadata provider
     |
     |  __gt__(self, other: 'Distribution')
     |      Return self>value.
     |
     |  __hash__(self)
     |      Return hash(self).
     |
     |  __init__(self, location: 'str | None' = None, metadata: '_MetadataType' = None, project_name: 'str | None' = None, version: 'str | None' = None, py_version: 'str | None' = '3.12', platform: 'str | None' = None, precedence: 'int' = 3)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  __le__(self, other: 'Distribution')
     |      Return self<=value.
     |
     |  __lt__(self, other: 'Distribution')
     |      Return self<value.
     |
     |  __ne__(self, other: 'object')
     |      Return self!=value.
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  __str__(self)
     |      Return str(self).
     |
     |  activate(self, path: 'list[str] | None' = None, replace: 'bool' = False)
     |      Ensure distribution is importable on `path` (default=sys.path)
     |
     |  as_requirement(self)
     |      Return a ``Requirement`` that matches this distribution exactly
     |
     |  check_version_conflict(self)
     |
     |  clone(self, **kw: 'str | int | IResourceProvider | None')
     |      Copy this distribution, substituting in any changed keyword args
     |
     |  egg_name(self)
     |      Return what this distribution's standard .egg filename should be
     |
     |  get_entry_info(self, group: 'str', name: 'str')
     |      Return the EntryPoint object for `group`+`name`, or ``None``
     |
     |  get_entry_map(self, group: 'str | None' = None)
     |      Return the entry point map for `group`, or the full entry map
     |
     |  has_version(self)
     |
     |  insert_on(self, path: 'list[str]', loc=None, replace: 'bool' = False)
     |      Ensure self.location is on path
     |
     |      If replace=False (default):
     |          - If location is already in path anywhere, do nothing.
     |          - Else:
     |            - If it's an egg and its parent directory is on path,
     |              insert just ahead of the parent.
     |            - Else: add to the end of path.
     |      If replace=True:
     |          - If location is already on path anywhere (not eggs)
     |            or higher priority than its parent (eggs)
     |            do nothing.
     |          - Else:
     |            - If it's an egg and its parent directory is on path,
     |              insert just ahead of the parent,
     |              removing any lower-priority entries.
     |            - Else: add it to the front of path.
     |
     |  load_entry_point(self, group: 'str', name: 'str') -> '_ResolvedEntryPoint'
     |      Return the `name` entry point of `group` or raise ImportError
     |
     |  requires(self, extras: 'Iterable[str]' = ())
     |      List of Requirements needed for this distro if `extras` are used
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  from_filename(filename: 'StrPath', metadata: '_MetadataType' = None, **kw: 'int')
     |
     |  from_location(location: 'str', basename: 'StrPath', metadata: '_MetadataType' = None, **kw: 'int') -> 'Distribution'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  extras
     |
     |  hashcmp
     |
     |  key
     |
     |  parsed_version
     |
     |  version
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  PKG_INFO = 'PKG-INFO'

    class DistributionNotFound(ResolutionError)
     |  A requested distribution was not found
     |
     |  Method resolution order:
     |      DistributionNotFound
     |      ResolutionError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __str__(self)
     |      Return str(self).
     |
     |  report(self)
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  req
     |
     |  requirers
     |
     |  requirers_str
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from ResolutionError:
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ResolutionError:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |
     |  __new__(*args, **kwargs) class method of builtins.Exception
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __setstate__(...)
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class EggMetadata(ZipProvider)
     |  EggMetadata(importer: 'zipimport.zipimporter')
     |
     |  Metadata provider for .egg files
     |
     |  Method resolution order:
     |      EggMetadata
     |      ZipProvider
     |      EggProvider
     |      NullProvider
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, importer: 'zipimport.zipimporter')
     |      Create a metadata provider from a zipimporter
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from ZipProvider:
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from ZipProvider:
     |
     |  zipinfo
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ZipProvider:
     |
     |  eagers = None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from NullProvider:
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  get_resource_stream(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NullProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NullProvider:
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    class EggProvider(NullProvider)
     |  EggProvider(module: '_ModuleLike')
     |
     |  Provider based on a virtual filesystem
     |
     |  Method resolution order:
     |      EggProvider
     |      NullProvider
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, module: '_ModuleLike')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from NullProvider:
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_stream(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NullProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NullProvider:
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    class EmptyProvider(NullProvider)
     |  Provider that returns nothing for all requests
     |
     |  Method resolution order:
     |      EmptyProvider
     |      NullProvider
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'module_path': 'str | None'}
     |
     |  module_path = None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from NullProvider:
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_stream(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NullProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NullProvider:
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    class EntryPoint(builtins.object)
     |  EntryPoint(name: 'str', module_name: 'str', attrs: 'Iterable[str]' = (), extras: 'Iterable[str]' = (), dist: 'Distribution | None' = None)
     |
     |  Object representing an advertised importable object
     |
     |  Methods defined here:
     |
     |  __init__(self, name: 'str', module_name: 'str', attrs: 'Iterable[str]' = (), extras: 'Iterable[str]' = (), dist: 'Distribution | None' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  __str__(self)
     |      Return str(self).
     |
     |  load(self, require: 'bool' = True, *args: 'Environment | _InstallerType | None', **kwargs: 'Environment | _InstallerType | None') -> '_ResolvedEntryPoint'
     |      Require packages for this EntryPoint, then resolve it.
     |
     |  require(self, env: 'Environment | None' = None, installer: '_InstallerType | None' = None)
     |
     |  resolve(self) -> '_ResolvedEntryPoint'
     |      Resolve the entry point from its module and attrs.
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  parse(src: 'str', dist: 'Distribution | None' = None)
     |      Parse a single entry point from string `src`
     |
     |      Entry point syntax follows the form::
     |
     |          name = some.module:some.attr [extra1, extra2]
     |
     |      The entry name and module name are required, but the ``:attrs`` and
     |      ``[extras]`` parts are optional
     |
     |  parse_group(group: 'str', lines: '_NestedStr', dist: 'Distribution | None' = None)
     |      Parse an entry point group
     |
     |  parse_map(data: 'str | Iterable[str] | dict[str, str | Iterable[str]]', dist: 'Distribution | None' = None)
     |      Parse a map of entry point groups
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  pattern = re.compile('\\s*(?P<name>.+?)\\s*=\\s*(?P<module...P<attr>[\...

    class Environment(builtins.object)
     |  Environment(search_path: 'Iterable[str] | None' = None, platform: 'str | None' = 'win-amd64', python: 'str | None' = '3.12')
     |
     |  Searchable snapshot of distributions on a search path
     |
     |  Methods defined here:
     |
     |  __add__(self, other: 'Distribution | Environment')
     |      Add an environment or distribution to an environment
     |
     |  __getitem__(self, project_name: 'str') -> 'list[Distribution]'
     |      Return a newest-to-oldest list of distributions for `project_name`
     |
     |      Uses case-insensitive `project_name` comparison, assuming all the
     |      project's distributions use their project's name converted to all
     |      lowercase as their key.
     |
     |  __iadd__(self, other: 'Distribution | Environment')
     |      In-place addition of a distribution or environment
     |
     |  __init__(self, search_path: 'Iterable[str] | None' = None, platform: 'str | None' = 'win-amd64', python: 'str | None' = '3.12')
     |      Snapshot distributions available on a search path
     |
     |      Any distributions found on `search_path` are added to the environment.
     |      `search_path` should be a sequence of ``sys.path`` items.  If not
     |      supplied, ``sys.path`` is used.
     |
     |      `platform` is an optional string specifying the name of the platform
     |      that platform-specific distributions must be compatible with.  If
     |      unspecified, it defaults to the current platform.  `python` is an
     |      optional string naming the desired version of Python (e.g. ``'3.6'``);
     |      it defaults to the current version.
     |
     |      You may explicitly set `platform` (and/or `python`) to ``None`` if you
     |      wish to map *all* distributions, not just those compatible with the
     |      running platform or Python version.
     |
     |  __iter__(self) -> 'Iterator[str]'
     |      Yield the unique project names of the available distributions
     |
     |  add(self, dist: 'Distribution')
     |      Add `dist` if we ``can_add()`` it and it has not already been added
     |
     |  best_match(self, req: 'Requirement', working_set: 'WorkingSet', installer: '_InstallerType | None | _InstallerTypeT[_DistributionT]' = None, replace_conflicting: 'bool' = False) -> 'Distribution | None'
     |      Find distribution best matching `req` and usable on `working_set`
     |
     |      This calls the ``find(req)`` method of the `working_set` to see if a
     |      suitable distribution is already active.  (This may raise
     |      ``VersionConflict`` if an unsuitable version of the project is already
     |      active in the specified `working_set`.)  If a suitable distribution
     |      isn't active, this method returns the newest distribution in the
     |      environment that meets the ``Requirement`` in `req`.  If no suitable
     |      distribution is found, and `installer` is supplied, then the result of
     |      calling the environment's ``obtain(req, installer)`` method will be
     |      returned.
     |
     |  can_add(self, dist: 'Distribution')
     |      Is distribution `dist` acceptable for this environment?
     |
     |      The distribution must match the platform and python version
     |      requirements specified when this environment was created, or False
     |      is returned.
     |
     |  obtain(self, requirement: 'Requirement', installer: 'Callable[[Requirement], None] | _InstallerType | None | _InstallerTypeT[_DistributionT]' = None) -> 'Distribution | None'
     |      Obtain a distribution matching `requirement` (e.g. via download)
     |
     |      Obtain a distro that matches requirement (e.g. via download).  In the
     |      base ``Environment`` class, this routine just returns
     |      ``installer(requirement)``, unless `installer` is None, in which case
     |      None is returned instead.  This method is a hook that allows subclasses
     |      to attempt other ways of obtaining a distribution before falling back
     |      to the `installer` argument.
     |
     |  remove(self, dist: 'Distribution')
     |      Remove `dist` from the environment
     |
     |  scan(self, search_path: 'Iterable[str] | None' = None)
     |      Scan `search_path` for distributions usable in this environment
     |
     |      Any distributions found are added to the environment.
     |      `search_path` should be a sequence of ``sys.path`` items.  If not
     |      supplied, ``sys.path`` is used.  Only distributions conforming to
     |      the platform/python version defined at initialization are added.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

    class ExtractionError(builtins.RuntimeError)
     |  An error occurred extracting a resource
     |
     |  The following attributes are available from instances of this exception:
     |
     |  manager
     |      The resource manager that raised this exception
     |
     |  cache_path
     |      The base directory for resource extraction
     |
     |  original_error
     |      The exception instance that caused extraction to fail
     |
     |  Method resolution order:
     |      ExtractionError
     |      builtins.RuntimeError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'cache_path': 'str', 'manager': 'ResourceManager', ...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.RuntimeError:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.RuntimeError:
     |
     |  __new__(*args, **kwargs) class method of builtins.RuntimeError
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __repr__(self, /)
     |      Return repr(self).
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class FileMetadata(EmptyProvider)
     |  FileMetadata(path: 'StrPath')
     |
     |  Metadata handler for standalone PKG-INFO files
     |
     |  Usage::
     |
     |      metadata = FileMetadata("/path/to/PKG-INFO")
     |
     |  This provider rejects all data and metadata requests except for PKG-INFO,
     |  which is treated as existing, and will be the contents of the file at
     |  the provided location.
     |
     |  Method resolution order:
     |      FileMetadata
     |      EmptyProvider
     |      NullProvider
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, path: 'StrPath')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {}
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from EmptyProvider:
     |
     |  module_path = None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from NullProvider:
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_stream(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NullProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NullProvider:
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    class IMetadataProvider(typing.Protocol)
     |  IMetadataProvider(*args, **kwargs)
     |
     |  Method resolution order:
     |      IMetadataProvider
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs) from typing
     |
     |  get_metadata(self, name: 'str') -> 'str'
     |      The named metadata resource as a string
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |      Yield named metadata resource as list of non-blank non-comment lines
     |
     |      Leading and trailing whitespace is stripped from each line, and lines
     |      with ``#`` as the first non-blank character are omitted.
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |      Does the package's distribution contain the named metadata?
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |      Is the named metadata a directory?  (like ``os.path.isdir()``)
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |      List of metadata names in the directory (like ``os.listdir()``)
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]') -> 'None'
     |      Execute the named script in the supplied namespace dictionary
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  __subclasshook__ = _proto_hook(other) from typing
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __parameters__ = ()
     |
     |  __protocol_attrs__ = {'get_metadata', 'get_metadata_lines', 'has_metad...
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |
     |  __init_subclass__(*args, **kwargs)
     |      Function to initialize subclasses.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __class_getitem__(...)
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.

    class IResourceProvider(IMetadataProvider, typing.Protocol)
     |  IResourceProvider(*args, **kwargs)
     |
     |  An object that provides access to package resources
     |
     |  Method resolution order:
     |      IResourceProvider
     |      IMetadataProvider
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str') -> 'str'
     |      Return a true filesystem path for `resource_name`
     |
     |      `manager` must be a ``ResourceManager``
     |
     |  get_resource_stream(self, manager: 'ResourceManager', resource_name: 'str') -> '_ResourceStream'
     |      Return a readable file-like object for `resource_name`
     |
     |      `manager` must be a ``ResourceManager``
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |      Return the contents of `resource_name` as :obj:`bytes`
     |
     |      `manager` must be a ``ResourceManager``
     |
     |  has_resource(self, resource_name: 'str') -> 'bool'
     |      Does the package contain the named resource?
     |
     |  resource_isdir(self, resource_name: 'str') -> 'bool'
     |      Is the named resource a directory?  (like ``os.path.isdir()``)
     |
     |  resource_listdir(self, resource_name: 'str') -> 'list[str]'
     |      List of resource names in the directory (like ``os.listdir()``)
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  __subclasshook__ = _proto_hook(other) from typing
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __parameters__ = ()
     |
     |  __protocol_attrs__ = {'get_metadata', 'get_metadata_lines', 'get_resou...
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from IMetadataProvider:
     |
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs) from typing
     |
     |  get_metadata(self, name: 'str') -> 'str'
     |      The named metadata resource as a string
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |      Yield named metadata resource as list of non-blank non-comment lines
     |
     |      Leading and trailing whitespace is stripped from each line, and lines
     |      with ``#`` as the first non-blank character are omitted.
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |      Does the package's distribution contain the named metadata?
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |      Is the named metadata a directory?  (like ``os.path.isdir()``)
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |      List of metadata names in the directory (like ``os.listdir()``)
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]') -> 'None'
     |      Execute the named script in the supplied namespace dictionary
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from IMetadataProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |
     |  __init_subclass__(*args, **kwargs)
     |      Function to initialize subclasses.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __class_getitem__(...)
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.

    class NullProvider(builtins.object)
     |  NullProvider(module: '_ModuleLike')
     |
     |  Try to implement resources and metadata for arbitrary PEP 302 loaders
     |
     |  Methods defined here:
     |
     |  __init__(self, module: '_ModuleLike')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_stream(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'egg_info': 'str | None', 'egg_name': 'str | None',...
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    class PEP440Warning(builtins.RuntimeWarning)
     |  Used when there is an issue with a version or specifier not complying with
     |  PEP 440.
     |
     |  Method resolution order:
     |      PEP440Warning
     |      builtins.RuntimeWarning
     |      builtins.Warning
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.RuntimeWarning:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.RuntimeWarning:
     |
     |  __new__(*args, **kwargs) class method of builtins.RuntimeWarning
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __repr__(self, /)
     |      Return repr(self).
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class PathMetadata(DefaultProvider)
     |  PathMetadata(path: 'str', egg_info: 'str')
     |
     |  Metadata provider for egg directories
     |
     |  Usage::
     |
     |      # Development eggs:
     |
     |      egg_info = "/path/to/PackageName.egg-info"
     |      base_dir = os.path.dirname(egg_info)
     |      metadata = PathMetadata(base_dir, egg_info)
     |      dist_name = os.path.splitext(os.path.basename(egg_info))[0]
     |      dist = Distribution(basedir, project_name=dist_name, metadata=metadata)
     |
     |      # Unpacked egg directories:
     |
     |      egg_path = "/path/to/PackageName-ver-pyver-etc.egg"
     |      metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))
     |      dist = Distribution.from_filename(egg_path, metadata=metadata)
     |
     |  Method resolution order:
     |      PathMetadata
     |      DefaultProvider
     |      EggProvider
     |      NullProvider
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, path: 'str', egg_info: 'str')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from DefaultProvider:
     |
     |  get_resource_stream(self, manager: 'object', resource_name: 'str')
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from NullProvider:
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NullProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NullProvider:
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    class PkgResourcesDeprecationWarning(builtins.Warning)
     |  Base class for warning about deprecations in ``pkg_resources``
     |
     |  This class is not derived from ``DeprecationWarning``, and as such is
     |  visible by default.
     |
     |  Method resolution order:
     |      PkgResourcesDeprecationWarning
     |      builtins.Warning
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Warning:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Warning:
     |
     |  __new__(*args, **kwargs) class method of builtins.Warning
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __repr__(self, /)
     |      Return repr(self).
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class Requirement(pip._vendor.packaging.requirements.Requirement)
     |  Requirement(requirement_string: 'str')
     |
     |  Method resolution order:
     |      Requirement
     |      pip._vendor.packaging.requirements.Requirement
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __contains__(self, item: 'Distribution | str | tuple[str, ...]') -> 'bool'
     |
     |  __eq__(self, other: 'object')
     |      Return self==value.
     |
     |  __hash__(self)
     |      Return hash(self).
     |
     |  __init__(self, requirement_string: 'str')
     |      DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!
     |
     |  __ne__(self, other)
     |      Return self!=value.
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |
     |  parse(s: 'str | Iterable[str]')
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pip._vendor.packaging.requirements.Requirement:
     |
     |  __str__(self) -> 'str'
     |      Return str(self).
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pip._vendor.packaging.requirements.Requirement:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

    class ResolutionError(builtins.Exception)
     |  Abstract base for dependency resolution errors
     |
     |  Method resolution order:
     |      ResolutionError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |
     |  __new__(*args, **kwargs) class method of builtins.Exception
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class ResourceManager(builtins.object)
     |  Manage resource extraction and packages
     |
     |  Methods defined here:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  cleanup_resources(self, force: 'bool' = False) -> 'list[str]'
     |      Delete all extracted resource files and directories, returning a list
     |      of the file and directory names that could not be successfully removed.
     |      This function does not have any concurrency protection, so it should
     |      generally only be called when the extraction path is a temporary
     |      directory exclusive to a single process.  This method is not
     |      automatically called; you must call it explicitly or register it as an
     |      ``atexit`` function if you wish to ensure cleanup of a temporary
     |      directory used for extractions.
     |
     |  extraction_error(self) -> 'NoReturn'
     |      Give an error message for problems extracting file(s)
     |
     |  get_cache_path(self, archive_name: 'str', names: 'Iterable[StrPath]' = ())
     |      Return absolute location in cache for `archive_name` and `names`
     |
     |      The parent directory of the resulting path will be created if it does
     |      not already exist.  `archive_name` should be the base filename of the
     |      enclosing egg (which may not be the name of the enclosing zipfile!),
     |      including its ".egg" extension.  `names`, if provided, should be a
     |      sequence of path name parts "under" the egg's extraction location.
     |
     |      This method should only be called by resource providers that need to
     |      obtain an extraction location, and only for names they intend to
     |      extract, as it tracks the generated names for possible cleanup later.
     |
     |  postprocess(self, tempname: 'StrOrBytesPath', filename: 'StrOrBytesPath')
     |      Perform any platform-specific postprocessing of `tempname`
     |
     |      This is where Mac header rewrites should be done; other platforms don't
     |      have anything special they should do.
     |
     |      Resource providers should call this method ONLY after successfully
     |      extracting a compressed resource.  They must NOT call it on resources
     |      that are already in the filesystem.
     |
     |      `tempname` is the current (temporary) name of the file, and `filename`
     |      is the name it will be renamed to by the caller after this routine
     |      returns.
     |
     |  resource_exists(self, package_or_requirement: '_PkgReqType', resource_name: 'str')
     |      Does the named resource exist?
     |
     |  resource_filename(self, package_or_requirement: '_PkgReqType', resource_name: 'str')
     |      Return a true filesystem path for specified resource
     |
     |  resource_isdir(self, package_or_requirement: '_PkgReqType', resource_name: 'str')
     |      Is the named resource an existing directory?
     |
     |  resource_listdir(self, package_or_requirement: '_PkgReqType', resource_name: 'str')
     |      List the contents of the named resource directory
     |
     |  resource_stream(self, package_or_requirement: '_PkgReqType', resource_name: 'str')
     |      Return a readable file-like object for specified resource
     |
     |  resource_string(self, package_or_requirement: '_PkgReqType', resource_name: 'str') -> 'bytes'
     |      Return specified resource as :obj:`bytes`
     |
     |  set_extraction_path(self, path: 'str')
     |      Set the base path where resources will be extracted to, if needed.
     |
     |      If you do not call this routine before any extractions take place, the
     |      path defaults to the return value of ``get_default_cache()``.  (Which
     |      is based on the ``PYTHON_EGG_CACHE`` environment variable, with various
     |      platform-specific fallbacks.  See that routine's documentation for more
     |      details.)
     |
     |      Resources are extracted to subdirectories of this path based upon
     |      information given by the ``IResourceProvider``.  You may set this to a
     |      temporary directory, but then you must call ``cleanup_resources()`` to
     |      delete the extracted files when done.  There is no guarantee that
     |      ``cleanup_resources()`` will be able to remove all extracted files.
     |
     |      (Note: you may not change the extraction path for a given resource
     |      manager once resources have been extracted, unless you first call
     |      ``cleanup_resources()``.)
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'extraction_path': 'str | None'}
     |
     |  extraction_path = None

    class UnknownExtra(ResolutionError)
     |  Distribution doesn't have an "extra feature" of the given name
     |
     |  Method resolution order:
     |      UnknownExtra
     |      ResolutionError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Methods inherited from ResolutionError:
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ResolutionError:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |
     |  __new__(*args, **kwargs) class method of builtins.Exception
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class VersionConflict(ResolutionError)
     |  An already-installed version conflicts with the requested version.
     |
     |  Should be initialized with the installed Distribution and the requested
     |  Requirement.
     |
     |  Method resolution order:
     |      VersionConflict
     |      ResolutionError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  report(self)
     |
     |  with_context(self, required_by: 'set[Distribution | str]')
     |      If required_by is non-empty, return a version of self that is a
     |      ContextualVersionConflict.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  dist
     |
     |  req
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from ResolutionError:
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ResolutionError:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |
     |  __new__(*args, **kwargs) class method of builtins.Exception
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class WorkingSet(builtins.object)
     |  WorkingSet(entries: 'Iterable[str] | None' = None)
     |
     |  A collection of active distributions on sys.path (or a similar list)
     |
     |  Methods defined here:
     |
     |  __contains__(self, dist: 'Distribution') -> 'bool'
     |      True if `dist` is the active distribution for its project
     |
     |  __getstate__(self)
     |      Helper for pickle.
     |
     |  __init__(self, entries: 'Iterable[str] | None' = None)
     |      Create working set from list of path entries (default=sys.path)
     |
     |  __iter__(self) -> 'Iterator[Distribution]'
     |      Yield distributions for non-duplicate projects in the working set
     |
     |      The yield order is the order in which the items' path entries were
     |      added to the working set.
     |
     |  __setstate__(self, e_k_b_n_c)
     |
     |  add(self, dist: 'Distribution', entry: 'str | None' = None, insert: 'bool' = True, replace: 'bool' = False)
     |      Add `dist` to working set, associated with `entry`
     |
     |      If `entry` is unspecified, it defaults to the ``.location`` of `dist`.
     |      On exit from this routine, `entry` is added to the end of the working
     |      set's ``.entries`` (if it wasn't already present).
     |
     |      `dist` is only added to the working set if it's for a project that
     |      doesn't already have a distribution in the set, unless `replace=True`.
     |      If it's added, any callbacks registered with the ``subscribe()`` method
     |      will be called.
     |
     |  add_entry(self, entry: 'str')
     |      Add a path item to ``.entries``, finding any distributions on it
     |
     |      ``find_distributions(entry, True)`` is used to find distributions
     |      corresponding to the path entry, and they are added.  `entry` is
     |      always appended to ``.entries``, even if it is already present.
     |      (This is because ``sys.path`` can contain the same value more than
     |      once, and the ``.entries`` of the ``sys.path`` WorkingSet should always
     |      equal ``sys.path``.)
     |
     |  find(self, req: 'Requirement') -> 'Distribution | None'
     |      Find a distribution matching requirement `req`
     |
     |      If there is an active distribution for the requested project, this
     |      returns it as long as it meets the version requirement specified by
     |      `req`.  But, if there is an active distribution for the project and it
     |      does *not* meet the `req` requirement, ``VersionConflict`` is raised.
     |      If there is no active distribution for the requested project, ``None``
     |      is returned.
     |
     |  find_plugins(self, plugin_env: 'Environment', full_env: 'Environment | None' = None, installer: '_InstallerType | None | _InstallerTypeT[_DistributionT]' = None, fallback: 'bool' = True) -> 'tuple[list[Distribution] | list[_DistributionT], dict[Distribution, Exception]]'
     |      Find all activatable distributions in `plugin_env`
     |
     |      Example usage::
     |
     |          distributions, errors = working_set.find_plugins(
     |              Environment(plugin_dirlist)
     |          )
     |          # add plugins+libs to sys.path
     |          map(working_set.add, distributions)
     |          # display errors
     |          print('Could not load', errors)
     |
     |      The `plugin_env` should be an ``Environment`` instance that contains
     |      only distributions that are in the project's "plugin directory" or
     |      directories. The `full_env`, if supplied, should be an ``Environment``
     |      contains all currently-available distributions.  If `full_env` is not
     |      supplied, one is created automatically from the ``WorkingSet`` this
     |      method is called on, which will typically mean that every directory on
     |      ``sys.path`` will be scanned for distributions.
     |
     |      `installer` is a standard installer callback as used by the
     |      ``resolve()`` method. The `fallback` flag indicates whether we should
     |      attempt to resolve older versions of a plugin if the newest version
     |      cannot be resolved.
     |
     |      This method returns a 2-tuple: (`distributions`, `error_info`), where
     |      `distributions` is a list of the distributions found in `plugin_env`
     |      that were loadable, along with any other distributions that are needed
     |      to resolve their dependencies.  `error_info` is a dictionary mapping
     |      unloadable plugin distributions to an exception instance describing the
     |      error that occurred. Usually this will be a ``DistributionNotFound`` or
     |      ``VersionConflict`` instance.
     |
     |  iter_entry_points(self, group: 'str', name: 'str | None' = None)
     |      Yield entry point objects from `group` matching `name`
     |
     |      If `name` is None, yields all entry points in `group` from all
     |      distributions in the working set, otherwise only ones matching
     |      both `group` and `name` are yielded (in distribution order).
     |
     |  require(self, *requirements: '_NestedStr')
     |      Ensure that distributions matching `requirements` are activated
     |
     |      `requirements` must be a string or a (possibly-nested) sequence
     |      thereof, specifying the distributions and versions required.  The
     |      return value is a sequence of the distributions that needed to be
     |      activated to fulfill the requirements; all relevant distributions are
     |      included, even if they were already activated in this working set.
     |
     |  resolve(self, requirements: 'Iterable[Requirement]', env: 'Environment | None' = None, installer: '_InstallerType | None | _InstallerTypeT[_DistributionT]' = None, replace_conflicting: 'bool' = False, extras: 'tuple[str, ...] | None' = None) -> 'list[Distribution] | list[_DistributionT]'
     |      List all distributions needed to (recursively) meet `requirements`
     |
     |      `requirements` must be a sequence of ``Requirement`` objects.  `env`,
     |      if supplied, should be an ``Environment`` instance.  If
     |      not supplied, it defaults to all distributions available within any
     |      entry or distribution in the working set.  `installer`, if supplied,
     |      will be invoked with each requirement that cannot be met by an
     |      already-installed distribution; it should return a ``Distribution`` or
     |      ``None``.
     |
     |      Unless `replace_conflicting=True`, raises a VersionConflict exception
     |      if
     |      any requirements are found on the path that have the correct name but
     |      the wrong version.  Otherwise, if an `installer` is supplied it will be
     |      invoked to obtain the correct version of the requirement and activate
     |      it.
     |
     |      `extras` is a list of the extras to be used with these requirements.
     |      This is important because extra requirements may look like `my_req;
     |      extra = "my_extra"`, which would otherwise be interpreted as a purely
     |      optional requirement.  Instead, we want to be able to assert that these
     |      requirements are truly required.
     |
     |  run_script(self, requires: 'str', script_name: 'str')
     |      Locate distribution for `requires` and run `script_name` script
     |
     |  subscribe(self, callback: 'Callable[[Distribution], object]', existing: 'bool' = True)
     |      Invoke `callback` for all distributions
     |
     |      If `existing=True` (default),
     |      call on all existing ones, as well.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

    class ZipProvider(EggProvider)
     |  ZipProvider(module: '_ZipLoaderModule')
     |
     |  Resource support for zips and eggs
     |
     |  Method resolution order:
     |      ZipProvider
     |      EggProvider
     |      NullProvider
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, module: '_ZipLoaderModule')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  get_resource_filename(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  zipinfo
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'eagers': 'list[str] | None', 'loader': 'zipimport....
     |
     |  eagers = None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from NullProvider:
     |
     |  get_metadata(self, name: 'str')
     |
     |  get_metadata_lines(self, name: 'str') -> 'Iterator[str]'
     |
     |  get_resource_stream(self, manager: 'ResourceManager', resource_name: 'str')
     |
     |  get_resource_string(self, manager: 'ResourceManager', resource_name: 'str') -> 'bytes'
     |
     |  has_metadata(self, name: 'str') -> 'bool'
     |
     |  has_resource(self, resource_name: 'str')
     |
     |  metadata_isdir(self, name: 'str') -> 'bool'
     |
     |  metadata_listdir(self, name: 'str') -> 'list[str]'
     |
     |  resource_isdir(self, resource_name: 'str')
     |
     |  resource_listdir(self, resource_name: 'str')
     |
     |  run_script(self, script_name: 'str', namespace: 'dict[str, Any]')
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NullProvider:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NullProvider:
     |
     |  egg_info = None
     |
     |  egg_name = None
     |
     |  loader = None

    parse_version = class Version(_BaseVersion)
     |  parse_version(version: 'str') -> 'None'
     |
     |  This class abstracts handling of a project's versions.
     |
     |  A :class:`Version` instance is comparison aware and can be compared and
     |  sorted using the standard Python interfaces.
     |
     |  >>> v1 = Version("1.0a5")
     |  >>> v2 = Version("1.0")
     |  >>> v1
     |  <Version('1.0a5')>
     |  >>> v2
     |  <Version('1.0')>
     |  >>> v1 < v2
     |  True
     |  >>> v1 == v2
     |  False
     |  >>> v1 > v2
     |  False
     |  >>> v1 >= v2
     |  False
     |  >>> v1 <= v2
     |  True
     |
     |  Method resolution order:
     |      Version
     |      _BaseVersion
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, version: 'str') -> 'None'
     |      Initialize a Version object.
     |
     |      :param version:
     |          The string representation of a version which will be parsed and normalized
     |          before use.
     |      :raises InvalidVersion:
     |          If the ``version`` does not conform to PEP 440 in any way then this
     |          exception will be raised.
     |
     |  __repr__(self) -> 'str'
     |      A representation of the Version that shows all internal state.
     |
     |      >>> Version('1.0.0')
     |      <Version('1.0.0')>
     |
     |  __str__(self) -> 'str'
     |      A string representation of the version that can be rounded-tripped.
     |
     |      >>> str(Version("1.0a5"))
     |      '1.0a5'
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  base_version
     |      The "base version" of the version.
     |
     |      >>> Version("1.2.3").base_version
     |      '1.2.3'
     |      >>> Version("1.2.3+abc").base_version
     |      '1.2.3'
     |      >>> Version("1!1.2.3+abc.dev1").base_version
     |      '1!1.2.3'
     |
     |      The "base version" is the public version of the project without any pre or post
     |      release markers.
     |
     |  dev
     |      The development number of the version.
     |
     |      >>> print(Version("1.2.3").dev)
     |      None
     |      >>> Version("1.2.3.dev1").dev
     |      1
     |
     |  epoch
     |      The epoch of the version.
     |
     |      >>> Version("2.0.0").epoch
     |      0
     |      >>> Version("1!2.0.0").epoch
     |      1
     |
     |  is_devrelease
     |      Whether this version is a development release.
     |
     |      >>> Version("1.2.3").is_devrelease
     |      False
     |      >>> Version("1.2.3.dev1").is_devrelease
     |      True
     |
     |  is_postrelease
     |      Whether this version is a post-release.
     |
     |      >>> Version("1.2.3").is_postrelease
     |      False
     |      >>> Version("1.2.3.post1").is_postrelease
     |      True
     |
     |  is_prerelease
     |      Whether this version is a pre-release.
     |
     |      >>> Version("1.2.3").is_prerelease
     |      False
     |      >>> Version("1.2.3a1").is_prerelease
     |      True
     |      >>> Version("1.2.3b1").is_prerelease
     |      True
     |      >>> Version("1.2.3rc1").is_prerelease
     |      True
     |      >>> Version("1.2.3dev1").is_prerelease
     |      True
     |
     |  local
     |      The local version segment of the version.
     |
     |      >>> print(Version("1.2.3").local)
     |      None
     |      >>> Version("1.2.3+abc").local
     |      'abc'
     |
     |  major
     |      The first item of :attr:`release` or ``0`` if unavailable.
     |
     |      >>> Version("1.2.3").major
     |      1
     |
     |  micro
     |      The third item of :attr:`release` or ``0`` if unavailable.
     |
     |      >>> Version("1.2.3").micro
     |      3
     |      >>> Version("1").micro
     |      0
     |
     |  minor
     |      The second item of :attr:`release` or ``0`` if unavailable.
     |
     |      >>> Version("1.2.3").minor
     |      2
     |      >>> Version("1").minor
     |      0
     |
     |  post
     |      The post-release number of the version.
     |
     |      >>> print(Version("1.2.3").post)
     |      None
     |      >>> Version("1.2.3.post1").post
     |      1
     |
     |  pre
     |      The pre-release segment of the version.
     |
     |      >>> print(Version("1.2.3").pre)
     |      None
     |      >>> Version("1.2.3a1").pre
     |      ('a', 1)
     |      >>> Version("1.2.3b1").pre
     |      ('b', 1)
     |      >>> Version("1.2.3rc1").pre
     |      ('rc', 1)
     |
     |  public
     |      The public portion of the version.
     |
     |      >>> Version("1.2.3").public
     |      '1.2.3'
     |      >>> Version("1.2.3+abc").public
     |      '1.2.3'
     |      >>> Version("1.2.3+abc.dev1").public
     |      '1.2.3'
     |
     |  release
     |      The components of the "release" segment of the version.
     |
     |      >>> Version("1.2.3").release
     |      (1, 2, 3)
     |      >>> Version("2.0.0").release
     |      (2, 0, 0)
     |      >>> Version("1!2.0.0.post0").release
     |      (2, 0, 0)
     |
     |      Includes trailing zeroes but not the epoch or any pre-release / development /
     |      post-release suffixes.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'_key': 'CmpKey'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from _BaseVersion:
     |
     |  __eq__(self, other: 'object') -> 'bool'
     |      Return self==value.
     |
     |  __ge__(self, other: '_BaseVersion') -> 'bool'
     |      Return self>=value.
     |
     |  __gt__(self, other: '_BaseVersion') -> 'bool'
     |      Return self>value.
     |
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |
     |  __le__(self, other: '_BaseVersion') -> 'bool'
     |      Return self<=value.
     |
     |  __lt__(self, other: '_BaseVersion') -> 'bool'
     |      Return self<value.
     |
     |  __ne__(self, other: 'object') -> 'bool'
     |      Return self!=value.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from _BaseVersion:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

FUNCTIONS
    __getstate__() -> 'dict[str, Any]'

    __setstate__(state: 'dict[str, Any]') -> 'dict[str, Any]'

    add_activation_listener = subscribe(callback: 'Callable[[Distribution], object]', existing: 'bool' = True) method of WorkingSet instance
        Invoke `callback` for all distributions

        If `existing=True` (default),
        call on all existing ones, as well.

    cleanup_resources(force: 'bool' = False) -> 'list[str]' method of ResourceManager instance
        Delete all extracted resource files and directories, returning a list
        of the file and directory names that could not be successfully removed.
        This function does not have any concurrency protection, so it should
        generally only be called when the extraction path is a temporary
        directory exclusive to a single process.  This method is not
        automatically called; you must call it explicitly or register it as an
        ``atexit`` function if you wish to ensure cleanup of a temporary
        directory used for extractions.

    compatible_platforms(provided: 'str | None', required: 'str | None')
        Can code for the `provided` platform run on the `required` platform?

        Returns true if either platform is ``None``, or the platforms are equal.

        XXX Needs compatibility checks for Linux and other unixy OSes.

    declare_namespace(packageName: 'str')
        Declare that package 'packageName' is a namespace package

    ensure_directory(path: 'StrOrBytesPath')
        Ensure that the parent directory of `path` exists

    evaluate_marker(text: 'str', extra: 'str | None' = None) -> 'bool'
        Evaluate a PEP 508 environment marker.
        Return a boolean indicating the marker result in this environment.
        Raise SyntaxError if marker is invalid.

        This implementation uses the 'pyparsing' module.

    find_distributions(path_item: 'str', only: 'bool' = False)
        Yield distributions accessible via `path_item`

    fixup_namespace_packages(path_item: 'str', parent: 'str | None' = None)
        Ensure that previously-declared namespace packages include path_item

    get_default_cache() -> 'str'
        Return the ``PYTHON_EGG_CACHE`` environment variable
        or a platform-relevant user cache dir for an app
        named "Python-Eggs".

    get_distribution(dist: 'Distribution | _PkgReqType') -> 'Distribution'
        Return a current distribution object for a Requirement or string

    get_entry_info(dist: '_EPDistType', group: 'str', name: 'str')
        Return the EntryPoint object for `group`+`name`, or ``None``

    get_entry_map(dist: '_EPDistType', group: 'str | None' = None)
        Return the entry point map for `group`, or the full entry map

    get_importer(path_item)
        Retrieve a finder for the given path item

        The returned finder is cached in sys.path_importer_cache
        if it was newly created by a path hook.

        The cache (or part of it) can be cleared manually if a
        rescan of sys.path_hooks is necessary.

    get_platform = get_build_platform()
        Return this platform's string for platform-specific distributions

        XXX Currently this is the same as ``distutils.util.get_platform()``, but it
        needs some hacks for Linux and macOS.

    get_provider(moduleOrReq: 'str | Requirement') -> 'IResourceProvider | Distribution'
        Return an IResourceProvider for the named module or requirement

    invalid_marker(text: 'str')
        Validate text as a PEP 508 environment marker; return an exception
        if invalid or False otherwise.

    iter_entry_points(group: 'str', name: 'str | None' = None) method of WorkingSet instance
        Yield entry point objects from `group` matching `name`

        If `name` is None, yields all entry points in `group` from all
        distributions in the working set, otherwise only ones matching
        both `group` and `name` are yielded (in distribution order).

    load_entry_point(dist: '_EPDistType', group: 'str', name: 'str') -> '_ResolvedEntryPoint'
        Return `name` entry point of `group` for `dist` or raise ImportError

    normalize_path(filename: 'StrOrBytesPath')
        Normalize a file/dir name for comparison purposes

    parse_requirements(strs: '_NestedStr')
        Yield ``Requirement`` objects for each specification in `strs`.

        `strs` must be a string, or a (possibly-nested) iterable thereof.

    register_finder(importer_type: 'type[_T]', distribution_finder: '_DistFinderType[_T]')
        Register `distribution_finder` to find distributions in sys.path items

        `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
        handler), and `distribution_finder` is a callable that, passed a path
        item and the importer instance, yields ``Distribution`` instances found on
        that path item.  See ``pkg_resources.find_on_path`` for an example.

    register_loader_type(loader_type: 'type[_ModuleLike]', provider_factory: '_ProviderFactoryType')
        Register `provider_factory` to make providers for `loader_type`

        `loader_type` is the type or class of a PEP 302 ``module.__loader__``,
        and `provider_factory` is a function that, passed a *module* object,
        returns an ``IResourceProvider`` for that module.

    register_namespace_handler(importer_type: 'type[_T]', namespace_handler: '_NSHandlerType[_T]')
        Register `namespace_handler` to declare namespace packages

        `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
        handler), and `namespace_handler` is a callable like this::

            def namespace_handler(importer, path_entry, moduleName, module):
                # return a path_entry to use for child packages

        Namespace handlers are only called if the importer object has already
        agreed that it can handle the relevant path item, and they should only
        return a subpath if the module __path__ does not already contain an
        equivalent subpath.  For an example namespace handler, see
        ``pkg_resources.file_ns_handler``.

    require(*requirements: '_NestedStr') method of WorkingSet instance
        Ensure that distributions matching `requirements` are activated

        `requirements` must be a string or a (possibly-nested) sequence
        thereof, specifying the distributions and versions required.  The
        return value is a sequence of the distributions that needed to be
        activated to fulfill the requirements; all relevant distributions are
        included, even if they were already activated in this working set.

    resource_exists(package_or_requirement: '_PkgReqType', resource_name: 'str') method of ResourceManager instance
        Does the named resource exist?

    resource_filename(package_or_requirement: '_PkgReqType', resource_name: 'str') method of ResourceManager instance
        Return a true filesystem path for specified resource

    resource_isdir(package_or_requirement: '_PkgReqType', resource_name: 'str') method of ResourceManager instance
        Is the named resource an existing directory?

    resource_listdir(package_or_requirement: '_PkgReqType', resource_name: 'str') method of ResourceManager instance
        List the contents of the named resource directory

    resource_stream(package_or_requirement: '_PkgReqType', resource_name: 'str') method of ResourceManager instance
        Return a readable file-like object for specified resource

    resource_string(package_or_requirement: '_PkgReqType', resource_name: 'str') -> 'bytes' method of ResourceManager instance
        Return specified resource as :obj:`bytes`

    run_main = run_script(requires: 'str', script_name: 'str') method of WorkingSet instance
        Locate distribution for `requires` and run `script_name` script

    run_script(requires: 'str', script_name: 'str') method of WorkingSet instance
        Locate distribution for `requires` and run `script_name` script

    safe_extra(extra: 'str')
        Convert an arbitrary string to a standard 'extra' name

        Any runs of non-alphanumeric characters are replaced with a single '_',
        and the result is always lowercased.

    safe_name(name: 'str')
        Convert an arbitrary string to a standard distribution name

        Any runs of non-alphanumeric/. characters are replaced with a single '-'.

    safe_version(version: 'str')
        Convert an arbitrary string to a standard version string

    set_extraction_path(path: 'str') method of ResourceManager instance
        Set the base path where resources will be extracted to, if needed.

        If you do not call this routine before any extractions take place, the
        path defaults to the return value of ``get_default_cache()``.  (Which
        is based on the ``PYTHON_EGG_CACHE`` environment variable, with various
        platform-specific fallbacks.  See that routine's documentation for more
        details.)

        Resources are extracted to subdirectories of this path based upon
        information given by the ``IResourceProvider``.  You may set this to a
        temporary directory, but then you must call ``cleanup_resources()`` to
        delete the extracted files when done.  There is no guarantee that
        ``cleanup_resources()`` will be able to remove all extracted files.

        (Note: you may not change the extraction path for a given resource
        manager once resources have been extracted, unless you first call
        ``cleanup_resources()``.)

    split_sections(s: '_NestedStr') -> 'Iterator[tuple[str | None, list[str]]]'
        Split a string or iterable thereof into (section, content) pairs

        Each ``section`` is a stripped version of the section header ("[section]")
        and each ``content`` is a list of stripped lines excluding blank lines and
        comment-only lines.  If there are any such lines before the first section
        header, they're returned in a first ``section`` of ``None``.

    to_filename(name: 'str')
        Convert a project or version name to its filename-escaped form

        Any '-' characters are currently replaced with '_'.

    yield_lines(iterable)
        Yield valid lines of a string or iterable.

        >>> list(yield_lines(''))
        []
        >>> list(yield_lines(['foo', 'bar']))
        ['foo', 'bar']
        >>> list(yield_lines('foo\nbar'))
        ['foo', 'bar']
        >>> list(yield_lines('\nfoo\n#bar\nbaz #comment'))
        ['foo', 'baz #comment']
        >>> list(yield_lines(['foo\nbar', 'baz', 'bing\n\n\n']))
        ['foo', 'bar', 'baz', 'bing']

DATA
    BINARY_DIST = 2
    CHECKOUT_DIST = 0
    DEVELOP_DIST = -1
    EGG_DIST = 3
    SOURCE_DIST = 1
    __all__ = ['require', 'run_script', 'get_provider', 'get_distribution'...
    __annotations__ = {'_distribution_finders': 'dict[type, _DistFinderTyp...
    __warningregistry__ = {'version': 1}
    empty_provider = <__init__.EmptyProvider object>
    working_set = <__init__.WorkingSet object>

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_vendor\pkg_resources\__init__.py


