Help on module _compat:

NAME
    _compat

CLASSES
    builtins.ValueError(builtins.Exception)
        BadMetadata
    typing.Protocol(typing.Generic)
        BasePath

    class BadMetadata(builtins.ValueError)
     |  BadMetadata(dist: importlib.metadata.Distribution, *, reason: str) -> None
     |
     |  Method resolution order:
     |      BadMetadata
     |      builtins.ValueError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, dist: importlib.metadata.Distribution, *, reason: str) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  __str__(self) -> str
     |      Return str(self).
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.ValueError:
     |
     |  __new__(*args, **kwargs) class method of builtins.ValueError
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __repr__(self, /)
     |      Return repr(self).
     |
     |  __setstate__(...)
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

    class BasePath(typing.Protocol)
     |  BasePath(*args, **kwargs)
     |
     |  A protocol that various path objects conform.
     |
     |  This exists because importlib.metadata uses both ``pathlib.Path`` and
     |  ``zipfile.Path``, and we need a common base for type hints (Union does not
     |  work well since ``zipfile.Path`` is too new for our linter setup).
     |
     |  This does not mean to be exhaustive, but only contains things that present
     |  in both classes *that we need*.
     |
     |  Method resolution order:
     |      BasePath
     |      typing.Protocol
     |      typing.Generic
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__ = _no_init_or_replace_init(self, *args, **kwargs) from typing
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  __subclasshook__ = _proto_hook(other) from typing
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  name
     |
     |  parent
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  __annotations__ = {}
     |
     |  __parameters__ = ()
     |
     |  __protocol_attrs__ = {'name', 'parent'}
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Protocol:
     |
     |  __init_subclass__(*args, **kwargs)
     |      Function to initialize subclasses.
     |
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |
     |  __class_getitem__(...)
     |      Parameterizes a generic class.
     |
     |      At least, parameterizing a generic class is the *main* thing this
     |      method does. For example, for some generic class `Foo`, this is called
     |      when we do `Foo[int]` - there, with `cls=Foo` and `params=int`.
     |
     |      However, note that this method is also called when defining generic
     |      classes in the first place with `class Foo[T]: ...`.

FUNCTIONS
    get_dist_canonical_name(dist: importlib.metadata.Distribution) -> pip._vendor.packaging.utils.NormalizedName
        Get the distribution's normalized name.

        The ``name`` attribute is only available in Python 3.10 or later. We are
        targeting exactly that, but Mypy does not know this.

    get_info_location(d: importlib.metadata.Distribution) -> Optional[_compat.BasePath]
        Find the path to the distribution's metadata directory.

        HACK: This relies on importlib.metadata's private ``_path`` attribute. Not
        all distributions exist on disk, so importlib.metadata is correct to not
        expose the attribute as public. But pip's code base is old and not as clean,
        so we do this to avoid having to rewrite too many things. Hopefully we can
        eliminate this some day.

    parse_name_and_version_from_info_directory(dist: importlib.metadata.Distribution) -> Tuple[Optional[str], Optional[str]]
        Get a name and version from the metadata directory name.

        This is much faster than reading distribution metadata.

DATA
    NormalizedName = pip._vendor.packaging.utils.NormalizedName
    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    Tuple = typing.Tuple
        Deprecated alias to builtins.tuple.

        Tuple[X, Y] is the cross-product type of X and Y.

        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.

        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_internal\metadata\importlib\_compat.py


