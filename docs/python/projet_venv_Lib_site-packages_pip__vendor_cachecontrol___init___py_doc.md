Help on module __init__:

NAME
    __init__ - CacheControl import Interface.

DESCRIPTION
    Make it easy to import from cachecontrol without long namespaces.

CLASSES
    builtins.object
        pip._vendor.cachecontrol.controller.CacheController
    pip._vendor.requests.adapters.HTTPAdapter(pip._vendor.requests.adapters.BaseAdapter)
        pip._vendor.cachecontrol.adapter.CacheControlAdapter

    class CacheControlAdapter(pip._vendor.requests.adapters.HTTPAdapter)
     |  CacheControlAdapter(cache: 'BaseCache | None' = None, cache_etags: 'bool' = True, controller_class: 'type[CacheController] | None' = None, serializer: 'Serializer | None' = None, heuristic: 'BaseHeuristic | None' = None, cacheable_methods: 'Collection[str] | None' = None, *args: 'Any', **kw: 'Any') -> 'None'
     |
     |  Method resolution order:
     |      CacheControlAdapter
     |      pip._vendor.requests.adapters.HTTPAdapter
     |      pip._vendor.requests.adapters.BaseAdapter
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self, cache: 'BaseCache | None' = None, cache_etags: 'bool' = True, controller_class: 'type[CacheController] | None' = None, serializer: 'Serializer | None' = None, heuristic: 'BaseHeuristic | None' = None, cacheable_methods: 'Collection[str] | None' = None, *args: 'Any', **kw: 'Any') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  build_response(self, request: 'PreparedRequest', response: 'HTTPResponse', from_cache: 'bool' = False, cacheable_methods: 'Collection[str] | None' = None) -> 'Response'
     |      Build a response by making a request or using the cache.
     |
     |      This will end up calling send and returning a potentially
     |      cached response
     |
     |  close(self) -> 'None'
     |      Disposes of any internal state.
     |
     |      Currently, this closes the PoolManager and any active ProxyManager,
     |      which closes any pooled connections.
     |
     |  send(self, request: 'PreparedRequest', stream: 'bool' = False, timeout: 'None | float | tuple[float, float] | tuple[float, None]' = None, verify: 'bool | str' = True, cert: 'None | bytes | str | tuple[bytes | str, bytes | str]' = None, proxies: 'Mapping[str, str] | None' = None, cacheable_methods: 'Collection[str] | None' = None) -> 'Response'
     |      Send a request. Use the request information to see if it
     |      exists in the cache and cache the response if we need to and can.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  invalidating_methods = {'DELETE', 'PATCH', 'PUT'}
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pip._vendor.requests.adapters.HTTPAdapter:
     |
     |  __getstate__(self)
     |      Helper for pickle.
     |
     |  __setstate__(self, state)
     |
     |  add_headers(self, request, **kwargs)
     |      Add any headers needed by the connection. As of v2.0 this does
     |      nothing by default, but is left for overriding by users that subclass
     |      the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      This should not be called from user code, and is only exposed for use
     |      when subclassing the
     |      :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.
     |      :param kwargs: The keyword arguments from the call to send().
     |
     |  build_connection_pool_key_attributes(self, request, verify, cert=None)
     |      Build the PoolKey attributes used by urllib3 to return a connection.
     |
     |      This looks at the PreparedRequest, the user-specified verify value,
     |      and the value of the cert parameter to determine what PoolKey values
     |      to use to select a connection from a given urllib3 Connection Pool.
     |
     |      The SSL related pool key arguments are not consistently set. As of
     |      this writing, use the following to determine what keys may be in that
     |      dictionary:
     |
     |      * If ``verify`` is ``True``, ``"ssl_context"`` will be set and will be the
     |        default Requests SSL Context
     |      * If ``verify`` is ``False``, ``"ssl_context"`` will not be set but
     |        ``"cert_reqs"`` will be set
     |      * If ``verify`` is a string, (i.e., it is a user-specified trust bundle)
     |        ``"ca_certs"`` will be set if the string is not a directory recognized
     |        by :py:func:`os.path.isdir`, otherwise ``"ca_certs_dir"`` will be
     |        set.
     |      * If ``"cert"`` is specified, ``"cert_file"`` will always be set. If
     |        ``"cert"`` is a tuple with a second item, ``"key_file"`` will also
     |        be present
     |
     |      To override these settings, one may subclass this class, call this
     |      method and use the above logic to change parameters as desired. For
     |      example, if one wishes to use a custom :py:class:`ssl.SSLContext` one
     |      must both set ``"ssl_context"`` and based on what else they require,
     |      alter the other keys to ensure the desired behaviour.
     |
     |      :param request:
     |          The PreparedReqest being sent over the connection.
     |      :type request:
     |          :class:`~requests.models.PreparedRequest`
     |      :param verify:
     |          Either a boolean, in which case it controls whether
     |          we verify the server's TLS certificate, or a string, in which case it
     |          must be a path to a CA bundle to use.
     |      :param cert:
     |          (optional) Any user-provided SSL certificate for client
     |          authentication (a.k.a., mTLS). This may be a string (i.e., just
     |          the path to a file which holds both certificate and key) or a
     |          tuple of length 2 with the certificate file path and key file
     |          path.
     |      :returns:
     |          A tuple of two dictionaries. The first is the "host parameters"
     |          portion of the Pool Key including scheme, hostname, and port. The
     |          second is a dictionary of SSLContext related parameters.
     |
     |  cert_verify(self, conn, url, verify, cert)
     |      Verify a SSL certificate. This method should not be called from user
     |      code, and is only exposed for use when subclassing the
     |      :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param conn: The urllib3 connection object associated with the cert.
     |      :param url: The requested URL.
     |      :param verify: Either a boolean, in which case it controls whether we verify
     |          the server's TLS certificate, or a string, in which case it must be a path
     |          to a CA bundle to use
     |      :param cert: The SSL certificate to verify.
     |
     |  get_connection(self, url, proxies=None)
     |      DEPRECATED: Users should move to `get_connection_with_tls_context`
     |      for all subclasses of HTTPAdapter using Requests>=2.32.2.
     |
     |      Returns a urllib3 connection for the given URL. This should not be
     |      called from user code, and is only exposed for use when subclassing the
     |      :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param url: The URL to connect to.
     |      :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
     |      :rtype: urllib3.ConnectionPool
     |
     |  get_connection_with_tls_context(self, request, verify, proxies=None, cert=None)
     |      Returns a urllib3 connection for the given request and TLS settings.
     |      This should not be called from user code, and is only exposed for use
     |      when subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param request:
     |          The :class:`PreparedRequest <PreparedRequest>` object to be sent
     |          over the connection.
     |      :param verify:
     |          Either a boolean, in which case it controls whether we verify the
     |          server's TLS certificate, or a string, in which case it must be a
     |          path to a CA bundle to use.
     |      :param proxies:
     |          (optional) The proxies dictionary to apply to the request.
     |      :param cert:
     |          (optional) Any user-provided SSL certificate to be used for client
     |          authentication (a.k.a., mTLS).
     |      :rtype:
     |          urllib3.ConnectionPool
     |
     |  init_poolmanager(self, connections, maxsize, block=False, **pool_kwargs)
     |      Initializes a urllib3 PoolManager.
     |
     |      This method should not be called from user code, and is only
     |      exposed for use when subclassing the
     |      :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param connections: The number of urllib3 connection pools to cache.
     |      :param maxsize: The maximum number of connections to save in the pool.
     |      :param block: Block when no free connections are available.
     |      :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.
     |
     |  proxy_headers(self, proxy)
     |      Returns a dictionary of the headers to add to any request sent
     |      through a proxy. This works with urllib3 magic to ensure that they are
     |      correctly sent to the proxy, rather than in a tunnelled request if
     |      CONNECT is being used.
     |
     |      This should not be called from user code, and is only exposed for use
     |      when subclassing the
     |      :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param proxy: The url of the proxy being used for this request.
     |      :rtype: dict
     |
     |  proxy_manager_for(self, proxy, **proxy_kwargs)
     |      Return urllib3 ProxyManager for the given proxy.
     |
     |      This method should not be called from user code, and is only
     |      exposed for use when subclassing the
     |      :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param proxy: The proxy to return a urllib3 ProxyManager for.
     |      :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.
     |      :returns: ProxyManager
     |      :rtype: urllib3.ProxyManager
     |
     |  request_url(self, request, proxies)
     |      Obtain the url to use when making the final request.
     |
     |      If the message is being sent through a HTTP proxy, the full URL has to
     |      be used. Otherwise, we should only use the path portion of the URL.
     |
     |      This should not be called from user code, and is only exposed for use
     |      when subclassing the
     |      :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
     |
     |      :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
     |      :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.
     |      :rtype: str
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pip._vendor.requests.adapters.HTTPAdapter:
     |
     |  __attrs__ = ['max_retries', 'config', '_pool_connections', '_pool_maxs...
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pip._vendor.requests.adapters.BaseAdapter:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

    class CacheController(builtins.object)
     |  CacheController(cache: 'BaseCache | None' = None, cache_etags: 'bool' = True, serializer: 'Serializer | None' = None, status_codes: 'Collection[int] | None' = None)
     |
     |  An interface to see if request should cached or not.
     |
     |  Methods defined here:
     |
     |  __init__(self, cache: 'BaseCache | None' = None, cache_etags: 'bool' = True, serializer: 'Serializer | None' = None, status_codes: 'Collection[int] | None' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  cache_response(self, request: 'PreparedRequest', response: 'HTTPResponse', body: 'bytes | None' = None, status_codes: 'Collection[int] | None' = None) -> 'None'
     |      Algorithm for caching requests.
     |
     |      This assumes a requests Response object.
     |
     |  cached_request(self, request: 'PreparedRequest') -> 'HTTPResponse | Literal[False]'
     |      Return a cached response if it exists in the cache, otherwise
     |      return False.
     |
     |  conditional_headers(self, request: 'PreparedRequest') -> 'dict[str, str]'
     |
     |  parse_cache_control(self, headers: 'Mapping[str, str]') -> 'dict[str, int | None]'
     |
     |  update_cached_response(self, request: 'PreparedRequest', response: 'HTTPResponse') -> 'HTTPResponse'
     |      On a 304 we will get a new set of headers that we want to
     |      update our cached value with, assuming we have one.
     |
     |      This should only ever be called when we've sent an ETag and
     |      gotten a 304 as the response.
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  cache_url(uri: 'str') -> 'str'
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

FUNCTIONS
    CacheControl(sess: 'requests.Session', cache: 'BaseCache | None' = None, cache_etags: 'bool' = True, serializer: 'Serializer | None' = None, heuristic: 'BaseHeuristic | None' = None, controller_class: 'type[CacheController] | None' = None, adapter_class: 'type[CacheControlAdapter] | None' = None, cacheable_methods: 'Collection[str] | None' = None) -> 'requests.Session'

DATA
    __all__ = ['__author__', '__email__', '__version__', 'CacheControlAdap...
    __email__ = 'eric@ionrock.org'

VERSION
    0.14.0

AUTHOR
    Eric Larson

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_vendor\cachecontrol\__init__.py


