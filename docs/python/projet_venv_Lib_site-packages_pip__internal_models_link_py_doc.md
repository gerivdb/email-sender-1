Help on module link:

NAME
    link

CLASSES
    builtins.object
        Link
        LinkHash
        MetadataFile

    class Link(builtins.object)
     |  Link(url: str, comes_from: Union[str, ForwardRef('IndexContent'), NoneType] = None, requires_python: Optional[str] = None, yanked_reason: Optional[str] = None, metadata_file_data: Optional[link.MetadataFile] = None, cache_link_parsing: bool = True, hashes: Optional[Mapping[str, str]] = None) -> None
     |
     |  Represents a parsed link from a Package Index's simple URL
     |
     |  Methods defined here:
     |
     |  __eq__(self, other: Any) -> bool
     |      Return self==value.
     |
     |  __ge__(self, other) from functools
     |      Return a >= b.  Computed by @total_ordering from (not a < b).
     |
     |  __gt__(self, other) from functools
     |      Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).
     |
     |  __hash__(self) -> int
     |      Return hash(self).
     |
     |  __init__(self, url: str, comes_from: Union[str, ForwardRef('IndexContent'), NoneType] = None, requires_python: Optional[str] = None, yanked_reason: Optional[str] = None, metadata_file_data: Optional[link.MetadataFile] = None, cache_link_parsing: bool = True, hashes: Optional[Mapping[str, str]] = None) -> None
     |      :param url: url of the resource pointed to (href of the link)
     |      :param comes_from: instance of IndexContent where the link was found,
     |          or string.
     |      :param requires_python: String containing the `Requires-Python`
     |          metadata field, specified in PEP 345. This may be specified by
     |          a data-requires-python attribute in the HTML link tag, as
     |          described in PEP 503.
     |      :param yanked_reason: the reason the file has been yanked, if the
     |          file has been yanked, or None if the file hasn't been yanked.
     |          This is the value of the "data-yanked" attribute, if present, in
     |          a simple repository HTML link. If the file has been yanked but
     |          no reason was provided, this should be the empty string. See
     |          PEP 592 for more information and the specification.
     |      :param metadata_file_data: the metadata attached to the file, or None if
     |          no such metadata is provided. This argument, if not None, indicates
     |          that a separate metadata file exists, and also optionally supplies
     |          hashes for that file.
     |      :param cache_link_parsing: A flag that is used elsewhere to determine
     |          whether resources retrieved from this link should be cached. PyPI
     |          URLs should generally have this set to False, for example.
     |      :param hashes: A mapping of hash names to digests to allow us to
     |          determine the validity of a download.
     |
     |  __le__(self, other) from functools
     |      Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).
     |
     |  __lt__(self, other: Any) -> bool
     |      Return self<value.
     |
     |  __repr__(self) -> str
     |      Return repr(self).
     |
     |  __str__(self) -> str
     |      Return str(self).
     |
     |  as_hashes(self) -> pip._internal.utils.hashes.Hashes
     |
     |  is_existing_dir(self) -> bool
     |
     |  is_hash_allowed(self, hashes: Optional[pip._internal.utils.hashes.Hashes]) -> bool
     |      Return True if the link has a hash and it is allowed by `hashes`.
     |
     |  metadata_link(self) -> Optional[ForwardRef('Link')]
     |      Return a link to the associated core metadata file (if any).
     |
     |  splitext(self) -> Tuple[str, str]
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  from_element(anchor_attribs: Dict[str, Optional[str]], page_url: str, base_url: str) -> Optional[ForwardRef('Link')]
     |      Convert an anchor element's attributes in a simple repository page to a Link.
     |
     |  from_json(file_data: Dict[str, Any], page_url: str) -> Optional[ForwardRef('Link')]
     |      Convert an pypi json document from a simple repository page into a Link.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  ext
     |
     |  file_path
     |
     |  filename
     |
     |  has_hash
     |
     |  hash
     |
     |  hash_name
     |
     |  is_file
     |
     |  is_vcs
     |
     |  is_wheel
     |
     |  is_yanked
     |
     |  netloc
     |      This can contain auth information.
     |
     |  path
     |
     |  scheme
     |
     |  show_url
     |
     |  subdirectory_fragment
     |
     |  url
     |
     |  url_without_fragment
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  cache_link_parsing
     |
     |  comes_from
     |
     |  egg_fragment
     |
     |  metadata_file_data
     |
     |  requires_python
     |
     |  yanked_reason

    class LinkHash(builtins.object)
     |  LinkHash(name: str, value: str) -> None
     |
     |  Links to content may have embedded hash values. This class parses those.
     |
     |  `name` must be any member of `_SUPPORTED_HASHES`.
     |
     |  This class can be converted to and from `ArchiveInfo`. While ArchiveInfo intends to
     |  be JSON-serializable to conform to PEP 610, this class contains the logic for
     |  parsing a hash name and value for correctness, and then checking whether that hash
     |  conforms to a schema with `.is_hash_allowed()`.
     |
     |  Methods defined here:
     |
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other)
     |      Return self==value.
     |
     |  __hash__(self)
     |      Return hash(self).
     |
     |  __init__(self, name: str, value: str) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  __post_init__(self) -> None
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |
     |  as_dict(self) -> Dict[str, str]
     |
     |  as_hashes(self) -> pip._internal.utils.hashes.Hashes
     |      Return a Hashes instance which checks only for the current hash.
     |
     |  is_hash_allowed(self, hashes: Optional[pip._internal.utils.hashes.Hashes]) -> bool
     |      Return True if the current hash is allowed by `hashes`.
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  find_hash_url_fragment(url: str) -> Optional[ForwardRef('LinkHash')]
     |      Search a string for a checksum algorithm name and encoded output value.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'name': <class 'str'>, 'value': <class 'str'>}
     |
     |  __dataclass_fields__ = {'name': Field(name='name',type=<class 'str'>,d...
     |
     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...
     |
     |  __match_args__ = ('name', 'value')

    class MetadataFile(builtins.object)
     |  MetadataFile(hashes: Optional[Dict[str, str]]) -> None
     |
     |  Information about a core metadata file associated with a distribution.
     |
     |  Methods defined here:
     |
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |
     |  __eq__(self, other)
     |      Return self==value.
     |
     |  __hash__(self)
     |      Return hash(self).
     |
     |  __init__(self, hashes: Optional[Dict[str, str]]) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  __post_init__(self) -> None
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'hashes': typing.Optional[typing.Dict[str, str]]}
     |
     |  __dataclass_fields__ = {'hashes': Field(name='hashes',type=typing.Opti...
     |
     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...
     |
     |  __match_args__ = ('hashes',)

FUNCTIONS
    links_equivalent(link1: link.Link, link2: link.Link) -> bool

    supported_hashes(hashes: Optional[Dict[str, str]]) -> Optional[Dict[str, str]]

DATA
    Dict = typing.Dict
        A generic version of dict.

    List = typing.List
        A generic version of list.

    Mapping = typing.Mapping
        A generic version of collections.abc.Mapping.

    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    TYPE_CHECKING = False
    Tuple = typing.Tuple
        Deprecated alias to builtins.tuple.

        Tuple[X, Y] is the cross-product type of X and Y.

        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.

        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].

    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.

        On Python 3.10 and higher, the | operator
        can also be used to denote unions;
        X | Y means the same thing to the type checker as Union[X, Y].

        To define a union, use e.g. Union[int, str]. Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::

            assert Union[Union[int, str], float] == Union[int, str, float]

        - Unions of a single argument vanish, e.g.::

            assert Union[int] == int  # The constructor actually returns int

        - Redundant arguments are skipped, e.g.::

            assert Union[int, str, int] == Union[int, str]

        - When comparing unions, the argument order is ignored, e.g.::

            assert Union[int, str] == Union[str, int]

        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].

    WHEEL_EXTENSION = '.whl'
    logger = <VerboseLogger link (WARNING)>

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_internal\models\link.py


