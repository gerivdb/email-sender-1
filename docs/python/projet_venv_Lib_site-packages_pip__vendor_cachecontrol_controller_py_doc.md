Help on module controller:

NAME
    controller - The httplib2 algorithms ported for use with requests.

CLASSES
    builtins.object
        CacheController

    class CacheController(builtins.object)
     |  CacheController(cache: 'BaseCache | None' = None, cache_etags: 'bool' = True, serializer: 'Serializer | None' = None, status_codes: 'Collection[int] | None' = None)
     |
     |  An interface to see if request should cached or not.
     |
     |  Methods defined here:
     |
     |  __init__(self, cache: 'BaseCache | None' = None, cache_etags: 'bool' = True, serializer: 'Serializer | None' = None, status_codes: 'Collection[int] | None' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  cache_response(self, request: 'PreparedRequest', response: 'HTTPResponse', body: 'bytes | None' = None, status_codes: 'Collection[int] | None' = None) -> 'None'
     |      Algorithm for caching requests.
     |
     |      This assumes a requests Response object.
     |
     |  cached_request(self, request: 'PreparedRequest') -> 'HTTPResponse | Literal[False]'
     |      Return a cached response if it exists in the cache, otherwise
     |      return False.
     |
     |  conditional_headers(self, request: 'PreparedRequest') -> 'dict[str, str]'
     |
     |  parse_cache_control(self, headers: 'Mapping[str, str]') -> 'dict[str, int | None]'
     |
     |  update_cached_response(self, request: 'PreparedRequest', response: 'HTTPResponse') -> 'HTTPResponse'
     |      On a 304 we will get a new set of headers that we want to
     |      update our cached value with, assuming we have one.
     |
     |      This should only ever be called when we've sent an ETag and
     |      gotten a 304 as the response.
     |
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |
     |  cache_url(uri: 'str') -> 'str'
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

FUNCTIONS
    parse_uri(uri: 'str') -> 'tuple[str, str, str, str, str]'
        Parses a URI using the regex given in Appendix B of RFC 3986.

        (scheme, authority, path, query, fragment) = parse_uri(uri)

DATA
    Collection = typing.Collection
        A generic version of collections.abc.Collection.

    Mapping = typing.Mapping
        A generic version of collections.abc.Mapping.

    PERMANENT_REDIRECT_STATUSES = (301, 308)
    TYPE_CHECKING = False
    URI = re.compile('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#...
    logger = <VerboseLogger controller (WARNING)>

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_vendor\cachecontrol\controller.py


