Help on module build_env:

NAME
    build_env - Build Environment used for isolation during sdist building

CLASSES
    builtins.object
        BuildEnvironment
            NoOpBuildEnvironment

    class BuildEnvironment(builtins.object)
     |  BuildEnvironment() -> None
     |
     |  Creates and manages an isolated environment to install build deps
     |
     |  Methods defined here:
     |
     |  __enter__(self) -> None
     |
     |  __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[traceback]) -> None
     |
     |  __init__(self) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  check_requirements(self, reqs: Iterable[str]) -> Tuple[Set[Tuple[str, str]], Set[str]]
     |      Return 2 sets:
     |      - conflicting requirements: set of (installed, wanted) reqs tuples
     |      - missing requirements: set of reqs
     |
     |  install_requirements(self, finder: 'PackageFinder', requirements: Iterable[str], prefix_as_string: str, *, kind: str) -> None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

    class NoOpBuildEnvironment(BuildEnvironment)
     |  NoOpBuildEnvironment() -> None
     |
     |  A no-op drop-in replacement for BuildEnvironment
     |
     |  Method resolution order:
     |      NoOpBuildEnvironment
     |      BuildEnvironment
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __enter__(self) -> None
     |
     |  __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[traceback]) -> None
     |
     |  __init__(self) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  cleanup(self) -> None
     |
     |  install_requirements(self, finder: 'PackageFinder', requirements: Iterable[str], prefix_as_string: str, *, kind: str) -> None
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from BuildEnvironment:
     |
     |  check_requirements(self, reqs: Iterable[str]) -> Tuple[Set[Tuple[str, str]], Set[str]]
     |      Return 2 sets:
     |      - conflicting requirements: set of (installed, wanted) reqs tuples
     |      - missing requirements: set of reqs
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BuildEnvironment:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object

FUNCTIONS
    get_runnable_pip() -> str
        Get a file to pass to a Python executable, to run the currently-running pip.

        This is used to run a pip subprocess, for installing requirements into the build
        environment.

DATA
    Iterable = typing.Iterable
        A generic version of collections.abc.Iterable.

    List = typing.List
        A generic version of list.

    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    Set = typing.Set
        A generic version of set.

    TYPE_CHECKING = False
    Tuple = typing.Tuple
        Deprecated alias to builtins.tuple.

        Tuple[X, Y] is the cross-product type of X and Y.

        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.

        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].

    Type = typing.Type
        Deprecated alias to builtins.type.

        builtins.type or typing.Type can be used to annotate class objects.
        For example, suppose we have the following classes::

            class User: ...  # Abstract base for User classes
            class BasicUser(User): ...
            class ProUser(User): ...
            class TeamUser(User): ...

        And a function that takes a class argument that's a subclass of
        User and returns an instance of the corresponding class::

            def new_user[U](user_class: Type[U]) -> U:
                user = user_class()
                # (Here we could write the user object to a database)
                return user

            joe = new_user(BasicUser)

        At this point the type checker knows that joe has type BasicUser.

    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.

        On Python 3.10 and higher, the | operator
        can also be used to denote unions;
        X | Y means the same thing to the type checker as Union[X, Y].

        To define a union, use e.g. Union[int, str]. Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::

            assert Union[Union[int, str], float] == Union[int, str, float]

        - Unions of a single argument vanish, e.g.::

            assert Union[int] == int  # The constructor actually returns int

        - Redundant arguments are skipped, e.g.::

            assert Union[int, str, int] == Union[int, str]

        - When comparing unions, the argument order is ignored, e.g.::

            assert Union[int, str] == Union[str, int]

        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].

    VERBOSE = 15
    logger = <VerboseLogger build_env (WARNING)>
    pip_location = r'C:\Python312\Lib\site-packages\pip\__init__.py'

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_internal\build_env.py


