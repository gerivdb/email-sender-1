Help on module deprecation:

NAME
    deprecation - A module that implements tooling to enable easy warnings about deprecations.

CLASSES
    builtins.Warning(builtins.Exception)
        PipDeprecationWarning

    class PipDeprecationWarning(builtins.Warning)
     |  Method resolution order:
     |      PipDeprecationWarning
     |      builtins.Warning
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |
     |  Data descriptors defined here:
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Warning:
     |
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Warning:
     |
     |  __new__(*args, **kwargs) class method of builtins.Warning
     |      Create and return a new object.  See help(type) for accurate signature.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |
     |  __reduce__(...)
     |      Helper for pickle.
     |
     |  __repr__(self, /)
     |      Return repr(self).
     |
     |  __setstate__(...)
     |
     |  __str__(self, /)
     |      Return str(self).
     |
     |  add_note(...)
     |      Exception.add_note(note) --
     |      add a note to the exception
     |
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |
     |  __cause__
     |      exception cause
     |
     |  __context__
     |      exception context
     |
     |  __dict__
     |
     |  __suppress_context__
     |
     |  __traceback__
     |
     |  args

FUNCTIONS
    deprecated(*, reason: str, replacement: Optional[str], gone_in: Optional[str], feature_flag: Optional[str] = None, issue: Optional[int] = None) -> None
        Helper to deprecate existing functionality.

        reason:
            Textual reason shown to the user about why this functionality has
            been deprecated. Should be a complete sentence.
        replacement:
            Textual suggestion shown to the user about what alternative
            functionality they can use.
        gone_in:
            The version of pip does this functionality should get removed in.
            Raises an error if pip's current version is greater than or equal to
            this.
        feature_flag:
            Command-line flag of the form --use-feature={feature_flag} for testing
            upcoming functionality.
        issue:
            Issue number on the tracker that would serve as a useful place for
            users to find related discussion and provide feedback.

    install_warning_logger() -> None

DATA
    DEPRECATION_MSG_PREFIX = 'DEPRECATION: '
    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    Type = typing.Type
        Deprecated alias to builtins.type.

        builtins.type or typing.Type can be used to annotate class objects.
        For example, suppose we have the following classes::

            class User: ...  # Abstract base for User classes
            class BasicUser(User): ...
            class ProUser(User): ...
            class TeamUser(User): ...

        And a function that takes a class argument that's a subclass of
        User and returns an instance of the corresponding class::

            def new_user[U](user_class: Type[U]) -> U:
                user = user_class()
                # (Here we could write the user object to a database)
                return user

            joe = new_user(BasicUser)

        At this point the type checker knows that joe has type BasicUser.

    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.

        On Python 3.10 and higher, the | operator
        can also be used to denote unions;
        X | Y means the same thing to the type checker as Union[X, Y].

        To define a union, use e.g. Union[int, str]. Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::

            assert Union[Union[int, str], float] == Union[int, str, float]

        - Unions of a single argument vanish, e.g.::

            assert Union[int] == int  # The constructor actually returns int

        - Redundant arguments are skipped, e.g.::

            assert Union[int, str, int] == Union[int, str]

        - When comparing unions, the argument order is ignored, e.g.::

            assert Union[int, str] == Union[str, int]

        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].

    __annotations__ = {'_original_showwarning': typing.Any}
    current_version = '24.2'

FILE
    d:\do\web\n8n_tests\projets\email_sender_1\projet\venv\lib\site-packages\pip\_internal\utils\deprecation.py


