

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; EMAIL_SENDER_1 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            EMAIL_SENDER_1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contenu:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">Documentation des API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">EMAIL_SENDER_1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/plans/piliers/PILIER_2.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>Développement détaillé du <strong>PILIER 2 : Le Moteur de Processus N8N</strong>, en adoptant une perspective résolument technique destinée aux ingénieurs, tout en assurant la cohérence avec les autres piliers.</p>
<hr class="docutils" />
<p><strong>PILIER 2 : Le Moteur de Processus - Modulaire, Robuste, Intelligent et Orienté Utilisateur (Workflows N8N)</strong></p>
<p>Ce pilier est le système nerveux central de l’automatisation. Il orchestre les flux de données et les actions entre Notion (Pilier 1), les services externes (Google Workspace, API IA…), et le CMS (Pilier 4), en s’appuyant sur l’intelligence des équipes IA (Pilier 3). L’architecture doit être modulaire (micro-services via Execute Workflow), robuste (gestion d’erreurs, idempotence), et maintenable.</p>
<p><strong>3. Architecture N8N Modulaire (Micro-services Fonctionnels Étendus) :</strong></p>
<ul class="simple">
<li><p><strong>Objectif Technique :</strong> Décomposer la logique métier complexe en workflows plus petits, spécialisés et réutilisables (Execute Workflow). Chaque workflow a une responsabilité unique, des inputs/outputs définis, et une gestion d’erreurs encapsulée.</p></li>
<li><p><strong>3.1. Workflows Utilitaires Fondamentaux (Étendus) :</strong></p>
<ul>
<li><p>Ces workflows sont les briques de base, appelées par de nombreux autres workflows. Ils doivent être particulièrement robustes et optimisés.</p></li>
<li><p><strong>WF-Core-Config</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Service de configuration dynamique par artiste. Point d’entrée unique pour récupérer tous les IDs et paramètres spécifiques à un artiste.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “artistName”: “Nom Artiste” } ou { “artistId”: “UUID” }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Notion API Call (Get Database Pages) :</strong> Interroger Agence_Artistes.</p>
<ul>
<li><p>Filtre : Nom Artiste equals input.artistName OU artistId (propriété dédiée) equals input.artistId.</p></li>
<li><p>Limite : 2 (pour détecter les doublons).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Validation (Code Node / IF Node) :</strong></p>
<ul>
<li><p>Vérifier si items.length === 1.</p></li>
<li><p>Si 0 ou &gt;1 :</p>
<ul>
<li><p>Appeler WF-Monitoring : { “severity”: “Critical”, “message”: “Config Artiste introuvable/ambiguë pour: “ + (input.artistName || input.artistId), … }.</p></li>
<li><p><strong>Stopper le workflow (Stop and Error Node ou retourner { “error”: true, “message”: “…” })</strong>.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>Parsing Config (Code Node) :</strong></p>
<ul>
<li><p>const configJson = JSON.parse(items[0].json.properties[’N8N Config’].rich_text[0].plain_text); (dans un try…catch).</p></li>
<li><p>Si parsing échoue, appeler WF-Monitoring (Critical) et stopper.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Enrichissement (Optionnel mais recommandé) :</strong></p>
<ul>
<li><p>Extraire les IDs de relation Manager Référent et Booker Principal.</p></li>
<li><p><strong>Notion API Call (Get Database Pages) :</strong> Interroger Agence_Équipe (ou Agence_HR_Personnel) pour récupérer les Person ID Notion ou emails associés à ces relations. Nécessite potentiellement 2 appels Get Page.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Formatage Output (Set Node ou Code Node) :</strong></p>
<ul>
<li><p>Retourner un objet JSON unique contenant la configuration parsée et les informations enrichies.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “config”: { …parsed JSON… }, “manager”: { “notionUserId”: “…”, “email”: “…” }, “booker”: { … }, “error”: false } OU { “error”: true, “message”: “…” }.</p></li>
<li><p><em>Dépendances :</em> Agence_Artistes, Agence_Équipe, WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Monitoring</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Service centralisé de logging des événements et erreurs N8N vers Notion.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “workflowId”: string, “executionId”: string, “nodeName”: string, “severity”: “Info” | “Warning” | “Error” | “Critical”, “message”: string, “contextData”?: object }. Les IDs peuvent être récupérés via $workflow.id, $execution.id.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Préparation Données (Code Node) :</strong></p>
<ul>
<li><p>Stringifier contextData : JSON.stringify(input.contextData || {}, null, 2). Gérer la taille max (tronquer si nécessaire) et potentiellement masquer/anonymiser des données sensibles.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Notion API Call (Create Database Page) :</strong> Créer une page dans Agence_Monitoring_N8N.</p>
<ul>
<li><p>Mapper les inputs aux propriétés Notion correspondantes.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Alerte Critique (IF Node) :</strong> Si input.severity === “Critical”.</p>
<ul>
<li><p><strong>Appel WF-Notification-Dispatcher :</strong> Envoyer une alerte immédiate au groupe admin/dev défini (via un userId spécifique ou un groupe). Input : { “userId”: “ID_Admin_RH”, “message”: “CRITICAL ERROR in WF “ + input.workflowId + “: “ + input.message, “channelPreference”: “Signal”, “severity”: “Urgent” }.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Création Tâche (Optionnel - IF Node) :</strong> Si input.severity === “Error” || input.severity === “Critical”.</p>
<ul>
<li><p><strong>Appel WF-Notion-Helper :</strong> Créer une tâche dans Agence_Tâches_Admin. Input : { “operation”: “createTask”, “title”: “Error in WF “ + input.workflowId, “details”: input.message, “assigneeId”: “ID_Dev_Lead”, “priority”: “High” }.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “logCreated”: true, “notionPageId”: “…” } ou { “logCreated”: false, “error”: “…” }.</p></li>
<li><p><em>Dépendances :</em> Agence_Monitoring_N8N, WF-Notification-Dispatcher (potentiel), WF-Notion-Helper (potentiel).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-API-Key-Selector</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Gérer la sélection et la rotation des clés API pour les services externes (spécifiquement OpenRouter ici). Encapsule la logique de gestion des clés échouées (rate limits, erreurs serveur).</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “aiTeamName”: “Team1” | “Team2” | … }.</p></li>
<li><p><em>Logique Principale :</em> (Détaillée dans Pilier 3, mais implique la lecture/écriture de N8N Static Data via Workflow - Static Data node ou API N8N interne si auto-hébergé).</p></li>
<li><p><em>Output :</em> { “apiKeyName”: “Nom_Credential_N8N”, “modelUsed”: “nom/modele”, “error”: false } OU { “error”: true, “message”: “All keys unavailable” }.</p></li>
<li><p><em>Dépendances :</em> N8N Static Data.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-API-Retry-Logic</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Fournir une logique de retry standardisée pour les appels API externes échoués (erreurs 5xx, 429 si non géré par WF-API-Key-Selector). Décide s’il faut retenter et avec quel délai.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “failedNodeOutput”: object, “originalInput”: object, “retryCount”: number, “maxRetries”: number (default: 3), “baseDelaySeconds”: number (default: 5) }.</p></li>
<li><p><em>Logique Principale (Code Node) :</em></p>
<ul>
<li><p>Vérifier si input.retryCount &lt; input.maxRetries.</p></li>
<li><p>Si oui :</p>
<ul>
<li><p>Calculer délai (ex: delay = input.baseDelaySeconds * Math.pow(2, input.retryCount) + Math.random()).</p></li>
<li><p>Appeler WF-Monitoring (Severity: Warning, Message: “Retrying operation… Attempt “ + (input.retryCount + 1)).</p></li>
<li><p>Retourner { “shouldRetry”: true, “nextRetryCount”: input.retryCount + 1, “delaySeconds”: delay }.</p></li>
</ul>
</li>
<li></li>
<li><p>Si non :</p>
<ul>
<li><p>Appeler WF-Monitoring (Severity: Error/Critical, Message: “Max retries reached for operation. Final error: “ + JSON.stringify(input.failedNodeOutput)).</p></li>
<li><p>Retourner { “shouldRetry”: false, “error”: true, “message”: “Max retries reached”, “finalErrorOutput”: input.failedNodeOutput }.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “shouldRetry”: boolean, … }.</p></li>
<li><p><em>Implémentation :</em> Le workflow <em>appelant</em> doit implémenter la boucle de retry. Il appelle ce WF depuis sa branche d’erreur, vérifie shouldRetry, utilise un Wait node avec delaySeconds, puis re-route vers le nœud API initial avec nextRetryCount et originalInput.</p></li>
<li><p><em>Dépendances :</em> WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Notification-Dispatcher</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Service centralisé d’envoi de notifications multi-canaux basé sur les préférences utilisateur.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “userId”: “Notion_User_ID_from_HR_Personnel”, “message”: string, “channelPreference”: “Auto” | “Signal” | “Email” | “Telegram”, “severity”: “Info” | “Urgent” }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Notion API Call (Get Database Page) :</strong> Lire Agence_HR_Personnel via input.userId. Gérer erreur si user non trouvé.</p></li>
<li><p><strong>Extraction Coordonnées (Code Node) :</strong> Récupérer Préférences Communication Interne, Email, Phone (pour Signal), Telegram Chat ID.</p></li>
<li><p><strong>Sélection Canal (Code Node ou Switch Node) :</strong></p>
<ul>
<li><p>Déterminer le canal cible basé sur input.channelPreference et les données récupérées.</p></li>
<li><p>Logique de fallback : Si Auto et pref = Signal mais pas de numéro -&gt; Email. Si canal spécifique demandé mais coordonnée manquante -&gt; Email.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Routage (Switch Node basé sur canal cible) :</strong></p>
<ul>
<li><p>Branche Email : Gmail Send Node. Input : to: email, subject: “[Urgent/Info] Notification Agence”, body: input.message. Utiliser credential agence global ou spécifique.</p></li>
<li><p>Branche Signal : Signal Send Node. Input : recipient: phone, message: input.message. Utiliser credential Signal configuré.</p></li>
<li><p>Branche Telegram : Telegram Bot Node (Send Message). Input : chatId: telegramChatId, text: input.message. Utiliser credential Bot Telegram.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Gestion Erreurs Envoi (Code Node après chaque branche d’envoi) :</strong></p>
<ul>
<li><p>Si l’envoi principal échoue (vérifier output du nœud d’envoi) :</p>
<ul>
<li><p>Logguer via WF-Monitoring (Warning).</p></li>
<li><p>Si ce n’était pas déjà le fallback Email, tenter d’envoyer par Email.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “dispatchStatus”: “Success/Partial/Failed”, “channelUsed”: “Email/Signal/Telegram”, “error?”: “…” }.</p></li>
<li><p><em>Dépendances :</em> Agence_HR_Personnel, WF-Monitoring, Credentials Gmail/Signal/Telegram.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Data-Quality-Checker</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Détecteur proactif d’incohérences et d’erreurs dans les données Notion critiques.</p></li>
<li><p><em>Trigger :</em> Cron Node (ex: 0 3 * * * - tous les jours à 3h du matin).</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Définition des Règles (Set Node ou Code Node) :</strong> Stocker les règles de validation par base de données (ex: { “Agence_Contacts”: [{ field: “Email”, rule: “isEmail” }, { field: “Téléphone”, rule: “isMobilePhone”, params: [”fr-FR”] }, { field: “Consentement GDPR”, rule: “isNotEmpty” }], … }).</p></li>
<li><p><strong>Boucle sur les Bases (Loop Over Items ou Code Node) :</strong> Itérer sur les bases à vérifier.</p></li>
<li><p><em>Dans la boucle (par base) :</em></p>
<ul>
<li><p><strong>Notion API Call (Get Many Database Pages) :</strong> Récupérer les items (utiliser pagination si nécessaire avec start_cursor).</p></li>
<li><p><strong>SplitInBatches Node :</strong> Traiter par lots (ex: 100 items).</p></li>
<li><p><strong>Code Node (Validation Batch) :</strong></p>
<ul>
<li><p>Input : Batch d’items Notion, règles pour cette base.</p></li>
<li><p>Utiliser validator.js (si dispo) ou regex pour isEmail, isURL, isMobilePhone.</p></li>
<li><p>Vérifier champs non vides (property.type !== ‘empty’).</p></li>
<li><p>Vérifier validité JSON (JSON.parse dans try…catch).</p></li>
<li><p><em>Détection Doublons (Simple) :</em> Créer un Map des emails/noms dans le batch, détecter collisions. Plus avancé : comparer avec un échantillon externe via Redis/DB CMS.</p></li>
<li><p>Output : [{ notionItemId: “…”, field: “…”, errorDescription: “…”, value: “…” }] pour chaque anomalie.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>IF Node :</strong> Si output.length &gt; 0.</p></li>
<li><p><strong>Code Node (Format Task) :</strong> Agréger les erreurs par item, formater un message Markdown.</p></li>
<li><p><strong>WF-Notion-Helper (Execute Workflow) :</strong> Créer une page dans Agence_Data_Quality_Issues. Input : { operation: “createDataQualityIssue”, baseName: “…”, issues: [{ itemId: “…”, summary: “…” }, …] }.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> Log final via WF-Monitoring (Info, avec résumé des anomalies trouvées).</p></li>
<li><p><em>Dépendances :</em> Bases Notion cibles, WF-Notion-Helper, WF-Monitoring. Nécessite potentiellement validator.js (via NODE_FUNCTION_ALLOW_EXTERNAL si N8N auto-hébergé).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Notion-Helper</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Façade robuste pour les opérations Notion courantes, encapsulant la logique API, le parsing de la réponse, et la gestion d’erreur basique.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “operation”: string, …params }. Exemples d’opérations :</p>
<ul>
<li><p>findPage: { operation: “findPage”, dbId: “…”, filter: { property: “Name”, title: { equals: “…” } } }</p></li>
<li><p>createPage: { operation: “createPage”, dbId: “…”, properties: { …Notion API properties object… } }</p></li>
<li><p>updatePage: { operation: “updatePage”, pageId: “…”, properties: { …Notion API properties object… } }</p></li>
<li><p>getPage: { operation: “getPage”, pageId: “…” }</p></li>
</ul>
</li>
<li></li>
<li><p><em>Logique Principale (Switch Node basé sur input.operation) :</em></p>
<ul>
<li><p>Chaque branche contient le nœud Notion API correspondant (Get Many, Create, Update, Get).</p></li>
<li><p><strong>Gestion d’Erreur :</strong> Connecter la sortie d’erreur du nœud Notion à WF-API-Retry-Logic (si pertinent) ou directement à WF-Monitoring. Retourner un format d’erreur standardisé.</p></li>
<li><p><strong>Parsing Réponse (Code Node si nécessaire) :</strong> Simplifier la structure de la réponse Notion si besoin avant de la retourner.</p></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “success”: true, “data”: { …Notion API response data… } } OU { “success”: false, “error”: “…”, “details”: { …Error details… } }.</p></li>
<li><p><em>Dépendances :</em> Notion Credentials, WF-API-Retry-Logic, WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>3.2. Workflows Métier Principaux (Orchestrateurs Étendus) :</strong></p>
<ul>
<li><p>Ces workflows définissent la logique métier de haut niveau. Ils sont déclenchés par des événements externes ou internes et coordonnent l’appel des sous-workflows utilitaires et spécialisés.</p></li>
<li><p><strong>WF-Booking-Manager</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Orchestrateur du cycle de vie d’une opportunité de booking.</p></li>
<li><p><em>Triggers Possibles :</em></p>
<ul>
<li><p>Manual Trigger (pour tests).</p></li>
<li><p>Webhook Node (appelé par le CMS via API sécurisée - Pilier 4). Payload : { action: “startProspection”, artistId: “…”, lotName: “LOT1”, targetFilters: {…} } ou { action: “validateDeal”, lotItemId: “…” }.</p></li>
<li><p>Notion Trigger Node (sur mise à jour de [Artiste]_LOT_Booking, ex: Statut change). <em>Attention : fiabilité et délais des webhooks Notion peuvent varier.</em></p></li>
<li><p>Cron Node (pour des actions périodiques comme les relances - moins idéal pour un orchestrateur principal).</p></li>
</ul>
</li>
<li></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Identifier Contexte (Code Node) :</strong> Extraire artistId / lotItemId / action du trigger data.</p></li>
<li><p><strong>Appel WF-Core-Config (Execute Workflow) :</strong> Récupérer la config artiste. Gérer erreur si output.error.</p></li>
<li><p><strong>Routage (Switch Node basé sur action ou statut Notion) :</strong></p>
<ul>
<li><p>Cas “startProspection”:</p>
<ul>
<li><p>Appel WF-Disponibilites.</p></li>
<li><p>Appel WF-Booking-Prospection (passer config, dispos, targetFilters).</p></li>
</ul>
</li>
<li></li>
<li><p>Cas “responseReceived” (déclenché par WF-Booking-Response-Handler via Execute Workflow? Ou directement par trigger Gmail?):</p>
<ul>
<li><p>Logique de suivi post-analyse IA (créer tâche, notifier manager…).</p></li>
</ul>
</li>
<li></li>
<li><p>Cas “validateDeal”:</p>
<ul>
<li><p>Appel WF-Booking-Deal-Processor (passer config, lotItemId).</p></li>
</ul>
</li>
<li></li>
<li><p>Cas “remindLogistics”:</p>
<ul>
<li><p>Appel WF-Booking-Logistics-Reminder.</p></li>
</ul>
</li>
<li></li>
<li><p>Cas “sendPostConcert”:</p>
<ul>
<li><p>Appel WF-Booking-Post-Concert.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>Gestion des Retours (Set Node / Code Node) :</strong> Formater une réponse pour le trigger initial (ex: pour le webhook CMS) ou logguer le résultat final.</p></li>
</ul>
</li>
<li></li>
<li><p><em>Dépendances :</em> WF-Core-Config, tous les sous-workflows WF-Booking-*, WF-Disponibilites.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Promotion-Manager, WF-Production-Manager, WF-HR-Manager :</strong> Suivent une structure similaire d’orchestration, appelant leurs sous-workflows respectifs en fonction des triggers et du contexte.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>3.3. Sous-Workflows Spécialisés (Exécutants Détaillés) :</strong></p>
<ul>
<li><p>Ces workflows implémentent des étapes métier spécifiques. Ils sont appelés par les orchestrateurs et utilisent les workflows utilitaires.</p></li>
<li><p><strong>WF-Disponibilites</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Calculer les plages de disponibilité d’un artiste en agrégeant les données de GCal et Notion.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “config”: object }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Google Calendar Node (Get Many Events) :</strong> Lire config.gCalIndispoId. Paramètres : startDate (now), endDate (now + X months), timeZone.</p></li>
<li><p><strong>WF-Notion-Helper (Execute Workflow) :</strong> Lire config.notionDbDispo. Input : { operation: “findPage”, dbId: config.notionDbDispo, filter: { property: “Validé Par Manager”, checkbox: { equals: true } } }.</p></li>
<li><p><strong>Code Node (Consolidate Busy Dates) :</strong></p>
<ul>
<li><p>Input 0: GCal items, Input 1: Notion items.</p></li>
<li><p>Initialiser const busyDates = new Set();.</p></li>
<li><p>Traiter GCal events : gérer date vs dateTime, fuseaux horaires (convertir en UTC ou date locale cohérente), événements multi-jours (itérer du start au end). Ajouter YYYY-MM-DD au Set.</p></li>
<li><p>Traiter Notion pages : extraire Date Indispo (start/end), gérer fuseaux horaires, ajouter YYYY-MM-DD au Set.</p></li>
<li><p>Retourner [{ json: { busyDates: Array.from(busyDates) } }].</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Code Node (Calculate Free Slots) :</strong></p>
<ul>
<li><p>Input : Item de l’étape 3.</p></li>
<li><p>const busySet = new Set(items[0].json.busyDates);.</p></li>
<li><p>Itérer sur les N prochains jours (configurable?).</p></li>
<li><p>Pour chaque date : formater en YYYY-MM-DD. Vérifier si !busySet.has(date) ET dayOfWeek === 5 || dayOfWeek === 6.</p></li>
<li><p>Si disponible, ajouter { json: { date: “YYYY-MM-DD”, status: “available” } } à un tableau de résultats.</p></li>
<li><p>Retourner le tableau de résultats.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> Array d’items, chacun représentant un slot disponible : [{ json: { date: “YYYY-MM-DD”, status: “available” } }, …].</p></li>
<li><p><em>Dépendances :</em> WF-Notion-Helper, Google Calendar Credentials.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Prospection</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Gérer l’envoi massif et personnalisé d’emails de prospection.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { “config”: object, “availableDates”: string[], “targetFilters”?: object }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Appel WF-AI-Team-Executor (Team 1) :</strong> Générer message de base. Input : { aiTeamName: “Team1”, prompt: “Rédige email base pour artiste X proposant dates: “ + input.availableDates.join(’, ‘), … }. Gérer erreur.</p></li>
<li><p><strong>WF-Notion-Helper (Find Contacts) :</strong> Lire config.notionDbContactsId. Input : { operation: “findPage”, dbId: config.notionDbContactsId, filter: { and: [ { property: “Statut Email”, select: { does_not_equal: “PROSPECT📨 Envoyé” } }, …input.targetFilters ] } }. Gérer pagination si &gt; 100 contacts.</p></li>
<li><p><strong>SplitInBatches Node :</strong> Configurer batchSize (ex: 5 ou 10, potentiellement depuis config). Connecter la sortie “Done” pour terminer. Connecter la sortie de la dernière étape de la boucle à l’input “Execute Next Batch”.</p></li>
<li><p><em>Dans la boucle (sortie “Batch”) :</em></p>
<ul>
<li><p><strong>Code Node (Get Details) :</strong> Pour chaque item (contact), extraire pageId, email, prénom, structureId (relation lieu).</p></li>
<li><p><strong>(Optionnel) WF-Notion-Helper (Get Lieu Details) :</strong> Si structureId existe, récupérer détails du lieu (Agence_Lieux_Structures).</p></li>
<li><p><strong>Appel WF-AI-Team-Executor (Team 2) :</strong> Personnaliser message. Input : { aiTeamName: “Team2”, prompt: “Personnalise ce message base: [baseMsg] pour [Prénom] de [Structure] (infos lieu: [lieuDetails])…”, … }. Gérer erreur.</p></li>
<li><p><strong>Get Template (IF Node + WF-Notion-Helper / Gmail Get Draft) :</strong></p>
<ul>
<li><p>Si template dans Notion : WF-Notion-Helper { operation: “getPage”, pageId: config.templateId }. Extraire contenu.</p></li>
<li><p>Si template Gmail : Gmail Get Draft Node (filtrer par config.gmailTemplateSubject). Extraire bodyHtml.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Code Node (Inject Content) :</strong> Remplacer placeholder (ex: {{CONTENT}}) dans le template HTML/texte avec le message personnalisé de l’IA. Gérer échappement HTML si nécessaire.</p></li>
<li><p><strong>Gmail Create Draft Node :</strong> to: contact.email, subject: …, bodyType: HTML, message: finalHtml. Utiliser config.gmailCredentialName.</p></li>
<li><p><strong>WF-Notion-Helper (Update Status) :</strong> Mettre à jour la page contact Notion. Input : { operation: “updatePage”, pageId: contact.pageId, properties: { “Statut Email”: { select: { name: “PROSPECT📧 Brouillon créé” } }, “Date Dernier Contact N8N”: { date: { start: new Date().toISOString() } } } }. Gérer erreur.</p></li>
<li><p><strong>Wait Node :</strong> Délai randomisé (ex: {{ Math.random() * (60 - 30) + 30 }} secondes, min/max depuis config?).</p></li>
</ul>
</li>
<li></li>
<li><p><em>Après la boucle (sortie “Done” de SplitInBatches) :</em></p>
<ul>
<li><p><strong>Appel WF-Monitoring :</strong> Logguer la fin de la campagne avec le nombre total traité.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “status”: “Completed”, “totalProcessed”: number }.</p></li>
<li><p><em>Dépendances :</em> WF-AI-Team-Executor, WF-Notion-Helper, Gmail Credentials, Agence_Templates (si utilisé).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Response-Handler</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Traiter les réponses emails, qualifier avec l’IA, mettre à jour Notion et notifier.</p></li>
<li><p><em>Trigger :</em> Gmail Trigger (On Message) OU (Cron + Gmail Search/List + Code pour éviter retraitement). <em>Gmail Trigger est plus temps réel mais peut nécessiter gestion état pour éviter doublons si N8N redémarre.</em></p></li>
<li><p><em>Input :</em> Gmail message object.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Extraction (Code Node) :</strong> senderEmail, subject, plainBody, threadId, messageId.</p></li>
<li><p><strong>Context Identification (Code Node) :</strong></p>
<ul>
<li><p>Rechercher senderEmail dans Agence_Contacts. Si trouvé, récupérer contactId.</p></li>
<li><p>Rechercher dans toutes les bases [Artiste]_LOT_Booking (nécessite de lister les artistes actifs et leurs DB IDs via Agence_Artistes) un item lié à contactId OU dont le threadId (si stocké lors de l’envoi) correspond. <em>Logique potentiellement complexe et coûteuse en appels Notion.</em></p></li>
<li><p>Si match trouvé, récupérer lotItemId et artistId.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>IF Node :</strong> Contexte trouvé (lotItemId et artistId) ?</p>
<ul>
<li><p><em>Branche Oui :</em></p>
<ul>
<li><p><strong>Appel WF-Core-Config</strong>. Gérer erreur.</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update Status) :</strong> Mettre à jour LOT item { operation: “updatePage”, pageId: lotItemId, properties: { “Statut Email”: { select: { name: “PROSPECT🧐 Réponse reçue” } } } }.</p></li>
<li><p><strong>Appel WF-AI-Team-Executor (Team 1 ou 3) :</strong> Analyser email. Input : { aiTeamName: “Team1”, prompt: “Analyse cet email: [plainBody]. Extrait: sentiment (Positif/Négatif/Neutre), intention (Info/Négo/Refus), dates proposées, questions clés. Réponds en JSON: { sentiment: ‘…’, intention: ‘…’, dates: […], questions: […] }”, … }. Gérer erreur.</p></li>
<li><p><strong>Code Node (Parse AI Response) :</strong> Extraire le JSON de la réponse IA. Gérer parsing error.</p></li>
<li><p><strong>Code Node (Determine Final Status) :</strong> Logique pour mapper sentiment/intention vers un statut Notion final (ex: “Négo”, “Refus Poli”, “A recontacter”).</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update Details) :</strong> Mettre à jour LOT item avec AI Sentiment Réponse, AI Résumé Réponse (généré par IA ou extrait), et le Statut Email final.</p></li>
<li><p><strong>Appel WF-Notification-Dispatcher :</strong> Alerter Booker/Manager. Input : { userId: config.booker.notionUserId, message: “Réponse reçue pour [Contact] / [Artiste]. Sentiment: “ + aiSentiment + “. Statut: “ + finalStatus, … }.</p></li>
</ul>
</li>
<li></li>
<li><p><em>Branche Non :</em></p>
<ul>
<li><p><strong>Appel WF-Monitoring :</strong> Logguer (Warning) “Email reçu de [senderEmail] non associé à une prospection active.”</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “processingStatus”: “Success/Skipped/Error”, “lotItemId?”: “…”, “artistId?”: “…” }.</p></li>
<li><p><em>Dépendances :</em> Gmail Trigger/Credentials, Agence_Contacts, [Artiste]_LOT_Booking (tous), WF-Core-Config, WF-Notion-Helper, WF-AI-Team-Executor, WF-Notification-Dispatcher, WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Deal-Processor</strong></p>
<ul>
<li><p><em>Rôle Technique :</em> Synchroniser un accord de booking (DEAL) entre Notion LOT, Notion Agenda et Google Calendar.</p></li>
<li><p><em>Trigger :</em> Execute Workflow (appelé par WF-Booking-Manager).</p></li>
<li><p><em>Input :</em> { “config”: object, “lotItemId”: string }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Appel WF-Notion-Helper (Get LOT Item) :</strong> Récupérer les détails du lotItemId (Date, Lieu Relation, Artiste…).</p></li>
<li><p><strong>Validation (IF Node) :</strong> Vérifier que le statut est bien “DEAL” ou similaire.</p></li>
<li><p><strong>Génération ID Synchro (Code Node) :</strong> const syncId = “notion_” + input.lotItemId;.</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update LOT Item) :</strong> Stocker syncId dans un champ GCal_Sync_ID sur le LOT item.</p></li>
<li><p><strong>Google Calendar Node (List Events) :</strong> Rechercher dans config.gCalBookingId un événement avec privateExtendedProperty ou description contenant syncId.</p></li>
<li><p><strong>Préparation Event Data (Code Node) :</strong> Formater les données pour GCal (start/end dateTime avec timezone, summary, description, location…). Inclure syncId dans extendedProperties.private.syncId ou description.</p></li>
<li><p><strong>IF Node :</strong> Événement GCal trouvé à l’étape 5 ?</p>
<ul>
<li><p><em>Branche Oui :</em> <strong>Google Calendar Node (Update Event)</strong>. Utiliser l’eventId trouvé.</p></li>
<li><p><em>Branche Non :</em> <strong>Google Calendar Node (Create Event)</strong>.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Code Node (Extract GCal ID) :</strong> Récupérer l’eventId retourné par GCal (Create ou Update).</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update LOT Item) :</strong> Stocker eventId dans GCal_Event_ID.</p></li>
<li><p><strong>Appel WF-Notion-Helper (Create/Update Agenda Notion) :</strong></p>
<ul>
<li><p>Chercher page dans config.notionDbAgenda avec GCal_Sync_ID == syncId.</p></li>
<li><p>Si trouvée, mettre à jour.</p></li>
<li><p>Si non trouvée, créer une nouvelle page, en liant au LOT item et en stockant GCal_Event_ID et GCal_Sync_ID.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>(Optionnel) Appel WF-Notion-Helper (Create Task) :</strong> Créer tâche logistique dans config.notionDbTaches.</p></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { “syncStatus”: “Success/Error”, “gCalEventId?”: “…”, “notionAgendaPageId?”: “…” }.</p></li>
<li><p><em>Dépendances :</em> WF-Notion-Helper, Google Calendar Credentials, [Artiste]_LOT_Booking, [Artiste]_Agenda_Booking, [Artiste]_Tâches.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Logistics-Reminder, WF-Booking-Post-Concert, WF-Musician-Availability-Reminder, WF-Musician-Itinerary-Sender, WF-Task-Reminder, WF-HR-Onboarding, WF-HR-Payroll-Prep :</strong> Suivent des logiques similaires : déclencheur (Cron/Webhook/GCal), récupération de contexte (Notion/GCal), potentiellement appel IA (Team 2/4/6), action finale (Notification/Email/Update Notion/Création Tâche). La clé est l’utilisation systématique des workflows utilitaires (WF-Core-Config, WF-Notion-Helper, WF-Notification-Dispatcher, WF-AI-Team-Executor, WF-Monitoring).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4. Robustesse, Tests et Documentation (Intégrés et Approfondis) :</strong></p>
<ul>
<li><p><strong>4.1. Gestion d’Erreurs Systématique et Graduée :</strong></p>
<ul>
<li><p><strong>try…catch dans Code Nodes :</strong> Essentiel pour parser JSON, manipuler dates, logique complexe. Le catch doit appeler WF-Monitoring et retourner/throw une erreur structurée.</p></li>
<li><p><strong>Connexion Sorties Erreur :</strong> Systématique.</p>
<ul>
<li><p>Nœuds API (Notion, GCal, Gmail, HTTP Request vers IA) : Connecter sortie erreur vers WF-API-Retry-Logic. Si WF-API-Retry-Logic retourne shouldRetry: false, connecter vers WF-Monitoring.</p></li>
<li><p>Nœuds Execute Workflow : Connecter sortie erreur vers WF-Monitoring. Le WF appelé doit gérer ses propres erreurs internes.</p></li>
<li><p>Autres nœuds (Set, IF, Switch…) : Les erreurs sont rares mais si elles surviennent (ex: expression invalide), elles arrêtent l’exécution et sont gérées par l’Error Trigger global.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Error Trigger Global :</strong> Configuré pour appeler WF-Monitoring avec Severity: Critical. Capture les erreurs non interceptées.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4.2. Idempotence Renforcée :</strong></p>
<ul>
<li><p><strong>Stratégie :</strong> “Check-then-Act” ou utilisation d’identifiants uniques.</p></li>
<li><p><em>Exemple GCal Sync (WF-Booking-Deal-Processor) :</em> Utilisation de GCal_Sync_ID (basé sur lotItemId) pour rechercher l’événement <em>avant</em> de créer. Si trouvé, on met à jour. Garantit qu’un seul événement GCal est créé même si le WF est déclenché plusieurs fois.</p></li>
<li><p><em>Exemple Envoi Email (WF-Booking-Prospection) :</em> Le statut Notion (”Brouillon créé”, “Envoyé”) empêche de renvoyer au même contact.</p></li>
<li><p><em>Exemple Création Tâche :</em> Si une tâche a un titre/identifiant prévisible, rechercher si elle existe avant de la créer.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4.3. Validation des Données Stricte (Schémas) :</strong></p>
<ul>
<li><p><strong>Nœud Schema Validation ou Code + zod :</strong></p>
<ul>
<li><p>Placer au début des workflows déclenchés par des sources externes non fiables (Webhook, Gmail Trigger). Valider le payload/message entrant.</p></li>
<li><p>Placer avant les appels Execute Workflow pour s’assurer que les inputs sont corrects.</p></li>
<li><p>Placer avant les nœuds API critiques (ex: Create GCal Event, Notion Create Page) pour valider les données formatées.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Définition Schémas :</strong> Stocker les schémas Zod/JSON Schema dans Agence_Documentation ou un repo Git dédié. Versionner les schémas.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4.4. Stratégie de Test Multi-Niveaux (Détaillée) :</strong></p>
<ul>
<li><p><strong>Unitaire (Test Step) :</strong> Isoler un nœud. Utiliser “Edit Input Data” pour fournir des cas de test variés (données valides, invalides, limites). Vérifier “Output Data”.</p></li>
<li><p><strong>Intégration (Sous-WF via “Test Harness”) :</strong></p>
<ul>
<li><p>Créer un WF Test_[Nom_Sous_WF].</p></li>
<li><p>Manual Trigger.</p></li>
<li><p>Set Node(s) pour simuler les inputs requis par le sous-WF (y compris l’objet config).</p></li>
<li><p>Execute Workflow Node appelant le sous-WF.</p></li>
<li><p>Code Node (Assertions) : Vérifier si l’output du sous-WF correspond aux attentes (expect(output.data.status).toBe(’Success’);). Throw error si assertion échoue.</p></li>
<li><p>Vérifier manuellement les effets de bord (Notion, GCal…).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Intégration (Manager WF / End-to-End) :</strong></p>
<ul>
<li><p>Nécessite un environnement de test isolé (Staging N8N, Notion “Test Artist”, GCal “Test”, Gmail “Test”).</p></li>
<li><p>Préparer les données initiales (ex: contact Notion à prospecter).</p></li>
<li><p>Déclencher le Manager WF (manuellement ou via webhook de test).</p></li>
<li><p>Suivre l’exécution dans N8N.</p></li>
<li><p>Vérifier les états finaux dans Notion, GCal, Gmail.</p></li>
<li><p>Nettoyer les données de test.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Tests de Charge (Basique N8N) :</strong></p>
<ul>
<li><p>Créer un WF simple : Manual Trigger -&gt; Loop Over Items (ex: 1000 itérations) -&gt; Execute Workflow (appelant le WF à tester via Webhook si possible, ou directement).</p></li>
<li><p>Monitorer l’utilisation CPU/RAM de l’instance N8N.</p></li>
<li><p>Vérifier les logs Agence_Monitoring_N8N pour les erreurs de rate limit (429).</p></li>
<li><p>Mesurer le temps total d’exécution.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Tests Utilisateur (UAT) :</strong></p>
<ul>
<li><p>Définir des scénarios utilisateur clairs (ex: “Prospecter 10 contacts pour Gribitch”, “Valider le deal pour le concert X”, “Soumettre mes indisponibilités pour le mois prochain”).</p></li>
<li><p>Fournir un accès à l’environnement Staging (CMS/Notion/N8N si pertinent).</p></li>
<li><p>Utiliser un outil de suivi de feedback (Trello, Jira, Notion DB).</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>4.5. Documentation Vivante et Accessible :</strong></p></li>
</ul>
</li>
</ul>
<p><strong>Sticky Notes :</strong> Utiliser Markdown :<br />#### WF-Booking-Prospection Loop Item</p>
<p>**// OBJECTIF:** Personnaliser et envoyer un email de prospection à un contact.<br />**// INPUT:** Item du SplitInBatches (données contact Notion), Message Base IA (depuis nœud précédent).<br />**// OUTPUT:** Statut de l’envoi/mise à jour Notion pour ce contact.<br />**// LOGIQUE CLÉ:**<br />1. Récupérer détails lieu (si pertinent).<br />2. Appel Team 2 pour personnalisation.<br />3. Récupérer template Gmail/Notion.<br />4. Injecter contenu personnalisé.<br />5. Créer Brouillon Gmail.<br />6. Mettre à jour statut contact Notion via WF-Notion-Helper.<br />7. Attendre délai randomisé.<br />**// ERREURS:** Gérées par WF-API-Retry-Logic / WF-Monitoring.</p>
<ul class="simple">
<li><ul>
<li><p><strong>Nommage :</strong> Préfixes Util_, Booking_, HR_, Notion_, GCal_, AI_. Suffixes _Main (Orchestrateur), _Sub (Exécutant).</p>
<ul>
<li><p><strong>Organisation Visuelle :</strong> Cadres (Sticky Note large, couleur par phase/type). Alignement logique des nœuds.</p></li>
<li><p><strong>Documentation Externe (Agence_Documentation - Notion DB) :</strong></p>
<ul>
<li><p><em>Type de Page :</em> Workflow Spec, Architecture Diagram, Convention Guide, API Endpoint, Glossary Term.</p></li>
<li><p><em>Propriétés Workflow Spec :</em> Nom Workflow (Title), ID N8N (Text), Lien N8N Editor (URL), Version (Text), Statut (Select: Dev, Staging, Prod, Deprecated), Responsable Dev (Relation -&gt; Agence_Équipe), Description (Text), Triggers (Multi-Select), Inputs Schema (Text - JSON Schema/Zod), Outputs Schema (Text - JSON Schema/Zod), Dépendances WF (Relation -&gt; Agence_Documentation), Dépendances Externes (Multi-Select: Notion, GCal, Team1…), Notes Techniques (Text).</p></li>
<li><p>Utiliser des synced blocks Notion pour partager des diagrammes ou conventions entre plusieurs pages.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>Matrices ACRI :</strong> Les matrices fournies sont un excellent point de départ. Les affiner pour chaque sous-processus critique (ex: Gestion erreur API, Validation données qualité) et les intégrer dans Agence_Documentation.</p></li>
</ul>
</li>
<li></li>
</ul>
<hr class="docutils" />
<p>Ce développement approfondi du Pilier 2 fournit aux ingénieurs une vision technique détaillée de l’architecture N8N proposée, des interactions entre workflows, de la gestion des données et des erreurs, ainsi que des stratégies de test et de documentation nécessaires pour construire et maintenir un système robuste et évolutif.</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, EMAIL_SENDER_1 Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>