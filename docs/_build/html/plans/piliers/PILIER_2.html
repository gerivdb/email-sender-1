

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; EMAIL_SENDER_1 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            EMAIL_SENDER_1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contenu:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">Documentation des API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">EMAIL_SENDER_1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/plans/piliers/PILIER_2.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>DÃ©veloppement dÃ©taillÃ© du <strong>PILIER 2 : Le Moteur de Processus N8N</strong>, en adoptant une perspective rÃ©solument technique destinÃ©e aux ingÃ©nieurs, tout en assurant la cohÃ©rence avec les autres piliers.</p>
<hr class="docutils" />
<p><strong>PILIER 2 : Le Moteur de Processus - Modulaire, Robuste, Intelligent et OrientÃ© Utilisateur (Workflows N8N)</strong></p>
<p>Ce pilier est le systÃ¨me nerveux central de lâ€™automatisation. Il orchestre les flux de donnÃ©es et les actions entre Notion (Pilier 1), les services externes (Google Workspace, API IAâ€¦), et le CMS (Pilier 4), en sâ€™appuyant sur lâ€™intelligence des Ã©quipes IA (Pilier 3). Lâ€™architecture doit Ãªtre modulaire (micro-services via Execute Workflow), robuste (gestion dâ€™erreurs, idempotence), et maintenable.</p>
<p><strong>3. Architecture N8N Modulaire (Micro-services Fonctionnels Ã‰tendus) :</strong></p>
<ul class="simple">
<li><p><strong>Objectif Technique :</strong> DÃ©composer la logique mÃ©tier complexe en workflows plus petits, spÃ©cialisÃ©s et rÃ©utilisables (Execute Workflow). Chaque workflow a une responsabilitÃ© unique, des inputs/outputs dÃ©finis, et une gestion dâ€™erreurs encapsulÃ©e.</p></li>
<li><p><strong>3.1. Workflows Utilitaires Fondamentaux (Ã‰tendus) :</strong></p>
<ul>
<li><p>Ces workflows sont les briques de base, appelÃ©es par de nombreux autres workflows. Ils doivent Ãªtre particuliÃ¨rement robustes et optimisÃ©s.</p></li>
<li><p><strong>WF-Core-Config</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Service de configuration dynamique par artiste. Point dâ€™entrÃ©e unique pour rÃ©cupÃ©rer tous les IDs et paramÃ¨tres spÃ©cifiques Ã  un artiste.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œartistNameâ€: â€œNom Artisteâ€ } ou { â€œartistIdâ€: â€œUUIDâ€ }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Notion API Call (Get Database Pages) :</strong> Interroger Agence_Artistes.</p>
<ul>
<li><p>Filtre : Nom Artiste equals input.artistName OU artistId (propriÃ©tÃ© dÃ©diÃ©e) equals input.artistId.</p></li>
<li><p>Limite : 2 (pour dÃ©tecter les doublons).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Validation (Code Node / IF Node) :</strong></p>
<ul>
<li><p>VÃ©rifier si items.length === 1.</p></li>
<li><p>Si 0 ou &gt;1 :</p>
<ul>
<li><p>Appeler WF-Monitoring : { â€œseverityâ€: â€œCriticalâ€, â€œmessageâ€: â€œConfig Artiste introuvable/ambiguÃ« pour: â€œ + (input.artistName || input.artistId), â€¦ }.</p></li>
<li><p><strong>Stopper le workflow (Stop and Error Node ou retourner { â€œerrorâ€: true, â€œmessageâ€: â€œâ€¦â€ })</strong>.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>Parsing Config (Code Node) :</strong></p>
<ul>
<li><p>const configJson = JSON.parse(items[0].json.properties[â€™N8N Configâ€™].rich_text[0].plain_text); (dans un tryâ€¦catch).</p></li>
<li><p>Si parsing Ã©choue, appeler WF-Monitoring (Critical) et stopper.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Enrichissement (Optionnel mais recommandÃ©) :</strong></p>
<ul>
<li><p>Extraire les IDs de relation Manager RÃ©fÃ©rent et Booker Principal.</p></li>
<li><p><strong>Notion API Call (Get Database Pages) :</strong> Interroger Agence_Ã‰quipe (ou Agence_HR_Personnel) pour rÃ©cupÃ©rer les Person ID Notion ou emails associÃ©s Ã  ces relations. NÃ©cessite potentiellement 2 appels Get Page.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Formatage Output (Set Node ou Code Node) :</strong></p>
<ul>
<li><p>Retourner un objet JSON unique contenant la configuration parsÃ©e et les informations enrichies.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œconfigâ€: { â€¦parsed JSONâ€¦ }, â€œmanagerâ€: { â€œnotionUserIdâ€: â€œâ€¦â€, â€œemailâ€: â€œâ€¦â€ }, â€œbookerâ€: { â€¦ }, â€œerrorâ€: false } OU { â€œerrorâ€: true, â€œmessageâ€: â€œâ€¦â€ }.</p></li>
<li><p><em>DÃ©pendances :</em> Agence_Artistes, Agence_Ã‰quipe, WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Monitoring</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Service centralisÃ© de logging des Ã©vÃ©nements et erreurs N8N vers Notion.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œworkflowIdâ€: string, â€œexecutionIdâ€: string, â€œnodeNameâ€: string, â€œseverityâ€: â€œInfoâ€ | â€œWarningâ€ | â€œErrorâ€ | â€œCriticalâ€, â€œmessageâ€: string, â€œcontextDataâ€?: object }. Les IDs peuvent Ãªtre rÃ©cupÃ©rÃ©s via $workflow.id, $execution.id.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>PrÃ©paration DonnÃ©es (Code Node) :</strong></p>
<ul>
<li><p>Stringifier contextData : JSON.stringify(input.contextData || {}, null, 2). GÃ©rer la taille max (tronquer si nÃ©cessaire) et potentiellement masquer/anonymiser des donnÃ©es sensibles.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Notion API Call (Create Database Page) :</strong> CrÃ©er une page dans Agence_Monitoring_N8N.</p>
<ul>
<li><p>Mapper les inputs aux propriÃ©tÃ©s Notion correspondantes.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Alerte Critique (IF Node) :</strong> Si input.severity === â€œCriticalâ€.</p>
<ul>
<li><p><strong>Appel WF-Notification-Dispatcher :</strong> Envoyer une alerte immÃ©diate au groupe admin/dev dÃ©fini (via un userId spÃ©cifique ou un groupe). Input : { â€œuserIdâ€: â€œID_Admin_RHâ€, â€œmessageâ€: â€œCRITICAL ERROR in WF â€œ + input.workflowId + â€œ: â€œ + input.message, â€œchannelPreferenceâ€: â€œSignalâ€, â€œseverityâ€: â€œUrgentâ€ }.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>CrÃ©ation TÃ¢che (Optionnel - IF Node) :</strong> Si input.severity === â€œErrorâ€ || input.severity === â€œCriticalâ€.</p>
<ul>
<li><p><strong>Appel WF-Notion-Helper :</strong> CrÃ©er une tÃ¢che dans Agence_TÃ¢ches_Admin. Input : { â€œoperationâ€: â€œcreateTaskâ€, â€œtitleâ€: â€œError in WF â€œ + input.workflowId, â€œdetailsâ€: input.message, â€œassigneeIdâ€: â€œID_Dev_Leadâ€, â€œpriorityâ€: â€œHighâ€ }.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œlogCreatedâ€: true, â€œnotionPageIdâ€: â€œâ€¦â€ } ou { â€œlogCreatedâ€: false, â€œerrorâ€: â€œâ€¦â€ }.</p></li>
<li><p><em>DÃ©pendances :</em> Agence_Monitoring_N8N, WF-Notification-Dispatcher (potentiel), WF-Notion-Helper (potentiel).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-API-Key-Selector</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> GÃ©rer la sÃ©lection et la rotation des clÃ©s API pour les services externes (spÃ©cifiquement OpenRouter ici). Encapsule la logique de gestion des clÃ©s Ã©chouÃ©es (rate limits, erreurs serveur).</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œaiTeamNameâ€: â€œTeam1â€ | â€œTeam2â€ | â€¦ }.</p></li>
<li><p><em>Logique Principale :</em> (DÃ©taillÃ©e dans Pilier 3, mais implique la lecture/Ã©criture de N8N Static Data via Workflow - Static Data node ou API N8N interne si auto-hÃ©bergÃ©).</p></li>
<li><p><em>Output :</em> { â€œapiKeyNameâ€: â€œNom_Credential_N8Nâ€, â€œmodelUsedâ€: â€œnom/modeleâ€, â€œerrorâ€: false } OU { â€œerrorâ€: true, â€œmessageâ€: â€œAll keys unavailableâ€ }.</p></li>
<li><p><em>DÃ©pendances :</em> N8N Static Data.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-API-Retry-Logic</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Fournir une logique de retry standardisÃ©e pour les appels API externes Ã©chouÃ©s (erreurs 5xx, 429 si non gÃ©rÃ© par WF-API-Key-Selector). DÃ©cide sâ€™il faut retenter et avec quel dÃ©lai.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œfailedNodeOutputâ€: object, â€œoriginalInputâ€: object, â€œretryCountâ€: number, â€œmaxRetriesâ€: number (default: 3), â€œbaseDelaySecondsâ€: number (default: 5) }.</p></li>
<li><p><em>Logique Principale (Code Node) :</em></p>
<ul>
<li><p>VÃ©rifier si input.retryCount &lt; input.maxRetries.</p></li>
<li><p>Si oui :</p>
<ul>
<li><p>Calculer dÃ©lai (ex: delay = input.baseDelaySeconds * Math.pow(2, input.retryCount) + Math.random()).</p></li>
<li><p>Appeler WF-Monitoring (Severity: Warning, Message: â€œRetrying operationâ€¦ Attempt â€œ + (input.retryCount + 1)).</p></li>
<li><p>Retourner { â€œshouldRetryâ€: true, â€œnextRetryCountâ€: input.retryCount + 1, â€œdelaySecondsâ€: delay }.</p></li>
</ul>
</li>
<li></li>
<li><p>Si non :</p>
<ul>
<li><p>Appeler WF-Monitoring (Severity: Error/Critical, Message: â€œMax retries reached for operation. Final error: â€œ + JSON.stringify(input.failedNodeOutput)).</p></li>
<li><p>Retourner { â€œshouldRetryâ€: false, â€œerrorâ€: true, â€œmessageâ€: â€œMax retries reachedâ€, â€œfinalErrorOutputâ€: input.failedNodeOutput }.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œshouldRetryâ€: boolean, â€¦ }.</p></li>
<li><p><em>ImplÃ©mentation :</em> Le workflow <em>appelant</em> doit implÃ©menter la boucle de retry. Il appelle ce WF depuis sa branche dâ€™erreur, vÃ©rifie shouldRetry, utilise un Wait node avec delaySeconds, puis re-route vers le nÅ“ud API initial avec nextRetryCount et originalInput.</p></li>
<li><p><em>DÃ©pendances :</em> WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Notification-Dispatcher</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Service centralisÃ© dâ€™envoi de notifications multi-canaux basÃ© sur les prÃ©fÃ©rences utilisateur.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œuserIdâ€: â€œNotion_User_ID_from_HR_Personnelâ€, â€œmessageâ€: string, â€œchannelPreferenceâ€: â€œAutoâ€ | â€œSignalâ€ | â€œEmailâ€ | â€œTelegramâ€, â€œseverityâ€: â€œInfoâ€ | â€œUrgentâ€ }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Notion API Call (Get Database Page) :</strong> Lire Agence_HR_Personnel via input.userId. GÃ©rer erreur si user non trouvÃ©.</p></li>
<li><p><strong>Extraction CoordonnÃ©es (Code Node) :</strong> RÃ©cupÃ©rer PrÃ©fÃ©rences Communication Interne, Email, Phone (pour Signal), Telegram Chat ID.</p></li>
<li><p><strong>SÃ©lection Canal (Code Node ou Switch Node) :</strong></p>
<ul>
<li><p>DÃ©terminer le canal cible basÃ© sur input.channelPreference et les donnÃ©es rÃ©cupÃ©rÃ©es.</p></li>
<li><p>Logique de fallback : Si Auto et pref = Signal mais pas de numÃ©ro -&gt; Email. Si canal spÃ©cifique demandÃ© mais coordonnÃ©e manquante -&gt; Email.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Routage (Switch Node basÃ© sur canal cible) :</strong></p>
<ul>
<li><p>Branche Email : Gmail Send Node. Input : to: email, subject: â€œ[Urgent/Info] Notification Agenceâ€, body: input.message. Utiliser credential agence global ou spÃ©cifique.</p></li>
<li><p>Branche Signal : Signal Send Node. Input : recipient: phone, message: input.message. Utiliser credential Signal configurÃ©.</p></li>
<li><p>Branche Telegram : Telegram Bot Node (Send Message). Input : chatId: telegramChatId, text: input.message. Utiliser credential Bot Telegram.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Gestion Erreurs Envoi (Code Node aprÃ¨s chaque branche dâ€™envoi) :</strong></p>
<ul>
<li><p>Si lâ€™envoi principal Ã©choue (vÃ©rifier output du nÅ“ud dâ€™envoi) :</p>
<ul>
<li><p>Logguer via WF-Monitoring (Warning).</p></li>
<li><p>Si ce nâ€™Ã©tait pas dÃ©jÃ  le fallback Email, tenter dâ€™envoyer par Email.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œdispatchStatusâ€: â€œSuccess/Partial/Failedâ€, â€œchannelUsedâ€: â€œEmail/Signal/Telegramâ€, â€œerror?â€: â€œâ€¦â€ }.</p></li>
<li><p><em>DÃ©pendances :</em> Agence_HR_Personnel, WF-Monitoring, Credentials Gmail/Signal/Telegram.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Data-Quality-Checker</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> DÃ©tecteur proactif dâ€™incohÃ©rences et dâ€™erreurs dans les donnÃ©es Notion critiques.</p></li>
<li><p><em>Trigger :</em> Cron Node (ex: 0 3 * * * - tous les jours Ã  3h du matin).</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>DÃ©finition des RÃ¨gles (Set Node ou Code Node) :</strong> Stocker les rÃ¨gles de validation par base de donnÃ©es (ex: { â€œAgence_Contactsâ€: [{ field: â€œEmailâ€, rule: â€œisEmailâ€ }, { field: â€œTÃ©lÃ©phoneâ€, rule: â€œisMobilePhoneâ€, params: [â€fr-FRâ€] }, { field: â€œConsentement GDPRâ€, rule: â€œisNotEmptyâ€ }], â€¦ }).</p></li>
<li><p><strong>Boucle sur les Bases (Loop Over Items ou Code Node) :</strong> ItÃ©rer sur les bases Ã  vÃ©rifier.</p></li>
<li><p><em>Dans la boucle (par base) :</em></p>
<ul>
<li><p><strong>Notion API Call (Get Many Database Pages) :</strong> RÃ©cupÃ©rer les items (utiliser pagination si nÃ©cessaire avec start_cursor).</p></li>
<li><p><strong>SplitInBatches Node :</strong> Traiter par lots (ex: 100 items).</p></li>
<li><p><strong>Code Node (Validation Batch) :</strong></p>
<ul>
<li><p>Input : Batch dâ€™items Notion, rÃ¨gles pour cette base.</p></li>
<li><p>Utiliser validator.js (si dispo) ou regex pour isEmail, isURL, isMobilePhone.</p></li>
<li><p>VÃ©rifier champs non vides (property.type !== â€˜emptyâ€™).</p></li>
<li><p>VÃ©rifier validitÃ© JSON (JSON.parse dans tryâ€¦catch).</p></li>
<li><p><em>DÃ©tection Doublons (Simple) :</em> CrÃ©er un Map des emails/noms dans le batch, dÃ©tecter collisions. Plus avancÃ© : comparer avec un Ã©chantillon externe via Redis/DB CMS.</p></li>
<li><p>Output : [{ notionItemId: â€œâ€¦â€, field: â€œâ€¦â€, errorDescription: â€œâ€¦â€, value: â€œâ€¦â€ }] pour chaque anomalie.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>IF Node :</strong> Si output.length &gt; 0.</p></li>
<li><p><strong>Code Node (Format Task) :</strong> AgrÃ©ger les erreurs par item, formater un message Markdown.</p></li>
<li><p><strong>WF-Notion-Helper (Execute Workflow) :</strong> CrÃ©er une page dans Agence_Data_Quality_Issues. Input : { operation: â€œcreateDataQualityIssueâ€, baseName: â€œâ€¦â€, issues: [{ itemId: â€œâ€¦â€, summary: â€œâ€¦â€ }, â€¦] }.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> Log final via WF-Monitoring (Info, avec rÃ©sumÃ© des anomalies trouvÃ©es).</p></li>
<li><p><em>DÃ©pendances :</em> Bases Notion cibles, WF-Notion-Helper, WF-Monitoring. NÃ©cessite potentiellement validator.js (via NODE_FUNCTION_ALLOW_EXTERNAL si N8N auto-hÃ©bergÃ©).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Notion-Helper</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> FaÃ§ade robuste pour les opÃ©rations Notion courantes, encapsulant la logique API, le parsing de la rÃ©ponse, et la gestion dâ€™erreur basique.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œoperationâ€: string, â€¦params }. Exemples dâ€™opÃ©rations :</p>
<ul>
<li><p>findPage: { operation: â€œfindPageâ€, dbId: â€œâ€¦â€, filter: { property: â€œNameâ€, title: { equals: â€œâ€¦â€ } } }</p></li>
<li><p>createPage: { operation: â€œcreatePageâ€, dbId: â€œâ€¦â€, properties: { â€¦Notion API properties objectâ€¦ } }</p></li>
<li><p>updatePage: { operation: â€œupdatePageâ€, pageId: â€œâ€¦â€, properties: { â€¦Notion API properties objectâ€¦ } }</p></li>
<li><p>getPage: { operation: â€œgetPageâ€, pageId: â€œâ€¦â€ }</p></li>
</ul>
</li>
<li></li>
<li><p><em>Logique Principale (Switch Node basÃ© sur input.operation) :</em></p>
<ul>
<li><p>Chaque branche contient le nÅ“ud Notion API correspondant (Get Many, Create, Update, Get).</p></li>
<li><p><strong>Gestion dâ€™Erreur :</strong> Connecter la sortie dâ€™erreur du nÅ“ud Notion Ã  WF-API-Retry-Logic (si pertinent) ou directement Ã  WF-Monitoring. Retourner un format dâ€™erreur standardisÃ©.</p></li>
<li><p><strong>Parsing RÃ©ponse (Code Node si nÃ©cessaire) :</strong> Simplifier la structure de la rÃ©ponse Notion si besoin avant de la retourner.</p></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œsuccessâ€: true, â€œdataâ€: { â€¦Notion API response dataâ€¦ } } OU { â€œsuccessâ€: false, â€œerrorâ€: â€œâ€¦â€, â€œdetailsâ€: { â€¦Error detailsâ€¦ } }.</p></li>
<li><p><em>DÃ©pendances :</em> Notion Credentials, WF-API-Retry-Logic, WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>3.2. Workflows MÃ©tier Principaux (Orchestrateurs Ã‰tendus) :</strong></p>
<ul>
<li><p>Ces workflows dÃ©finissent la logique mÃ©tier de haut niveau. Ils sont dÃ©clenchÃ©s par des Ã©vÃ©nements externes ou internes et coordonnent lâ€™appel des sous-workflows utilitaires et spÃ©cialisÃ©s.</p></li>
<li><p><strong>WF-Booking-Manager</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Orchestrateur du cycle de vie dâ€™une opportunitÃ© de booking.</p></li>
<li><p><em>Triggers Possibles :</em></p>
<ul>
<li><p>Manual Trigger (pour tests).</p></li>
<li><p>Webhook Node (appelÃ© par le CMS via API sÃ©curisÃ©e - Pilier 4). Payload : { action: â€œstartProspectionâ€, artistId: â€œâ€¦â€, lotName: â€œLOT1â€, targetFilters: {â€¦} } ou { action: â€œvalidateDealâ€, lotItemId: â€œâ€¦â€ }.</p></li>
<li><p>Notion Trigger Node (sur mise Ã  jour de [Artiste]_LOT_Booking, ex: Statut change). <em>Attention : fiabilitÃ© et dÃ©lais des webhooks Notion peuvent varier.</em></p></li>
<li><p>Cron Node (pour des actions pÃ©riodiques comme les relances - moins idÃ©al pour un orchestrateur principal).</p></li>
</ul>
</li>
<li></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Identifier Contexte (Code Node) :</strong> Extraire artistId / lotItemId / action du trigger data.</p></li>
<li><p><strong>Appel WF-Core-Config (Execute Workflow) :</strong> RÃ©cupÃ©rer la config artiste. GÃ©rer erreur si output.error.</p></li>
<li><p><strong>Routage (Switch Node basÃ© sur action ou statut Notion) :</strong></p>
<ul>
<li><p>Cas â€œstartProspectionâ€:</p>
<ul>
<li><p>Appel WF-Disponibilites.</p></li>
<li><p>Appel WF-Booking-Prospection (passer config, dispos, targetFilters).</p></li>
</ul>
</li>
<li></li>
<li><p>Cas â€œresponseReceivedâ€ (dÃ©clenchÃ© par WF-Booking-Response-Handler via Execute Workflow? Ou directement par trigger Gmail?):</p>
<ul>
<li><p>Logique de suivi post-analyse IA (crÃ©er tÃ¢che, notifier managerâ€¦).</p></li>
</ul>
</li>
<li></li>
<li><p>Cas â€œvalidateDealâ€:</p>
<ul>
<li><p>Appel WF-Booking-Deal-Processor (passer config, lotItemId).</p></li>
</ul>
</li>
<li></li>
<li><p>Cas â€œremindLogisticsâ€:</p>
<ul>
<li><p>Appel WF-Booking-Logistics-Reminder.</p></li>
</ul>
</li>
<li></li>
<li><p>Cas â€œsendPostConcertâ€:</p>
<ul>
<li><p>Appel WF-Booking-Post-Concert.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>Gestion des Retours (Set Node / Code Node) :</strong> Formater une rÃ©ponse pour le trigger initial (ex: pour le webhook CMS) ou logguer le rÃ©sultat final.</p></li>
</ul>
</li>
<li></li>
<li><p><em>DÃ©pendances :</em> WF-Core-Config, tous les sous-workflows WF-Booking-*, WF-Disponibilites.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Promotion-Manager, WF-Production-Manager, WF-HR-Manager :</strong> Suivent une structure similaire dâ€™orchestration, appelant leurs sous-workflows respectifs en fonction des triggers et du contexte.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>3.3. Sous-Workflows SpÃ©cialisÃ©s (ExÃ©cutants DÃ©taillÃ©s) :</strong></p>
<ul>
<li><p>Ces workflows implÃ©mentent des Ã©tapes mÃ©tier spÃ©cifiques. Ils sont appelÃ©s par les orchestrateurs et utilisent les workflows utilitaires.</p></li>
<li><p><strong>WF-Disponibilites</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Calculer les plages de disponibilitÃ© dâ€™un artiste en agrÃ©geant les donnÃ©es de GCal et Notion.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œconfigâ€: object }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Google Calendar Node (Get Many Events) :</strong> Lire config.gCalIndispoId. ParamÃ¨tres : startDate (now), endDate (now + X months), timeZone.</p></li>
<li><p><strong>WF-Notion-Helper (Execute Workflow) :</strong> Lire config.notionDbDispo. Input : { operation: â€œfindPageâ€, dbId: config.notionDbDispo, filter: { property: â€œValidÃ© Par Managerâ€, checkbox: { equals: true } } }.</p></li>
<li><p><strong>Code Node (Consolidate Busy Dates) :</strong></p>
<ul>
<li><p>Input 0: GCal items, Input 1: Notion items.</p></li>
<li><p>Initialiser const busyDates = new Set();.</p></li>
<li><p>Traiter GCal events : gÃ©rer date vs dateTime, fuseaux horaires (convertir en UTC ou date locale cohÃ©rente), Ã©vÃ©nements multi-jours (itÃ©rer du start au end). Ajouter YYYY-MM-DD au Set.</p></li>
<li><p>Traiter Notion pages : extraire Date Indispo (start/end), gÃ©rer fuseaux horaires, ajouter YYYY-MM-DD au Set.</p></li>
<li><p>Retourner [{ json: { busyDates: Array.from(busyDates) } }].</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Code Node (Calculate Free Slots) :</strong></p>
<ul>
<li><p>Input : Item de lâ€™Ã©tape 3.</p></li>
<li><p>const busySet = new Set(items[0].json.busyDates);.</p></li>
<li><p>ItÃ©rer sur les N prochains jours (configurable?).</p></li>
<li><p>Pour chaque date : formater en YYYY-MM-DD. VÃ©rifier si !busySet.has(date) ET dayOfWeek === 5 || dayOfWeek === 6.</p></li>
<li><p>Si disponible, ajouter { json: { date: â€œYYYY-MM-DDâ€, status: â€œavailableâ€ } } Ã  un tableau de rÃ©sultats.</p></li>
<li><p>Retourner le tableau de rÃ©sultats.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> Array dâ€™items, chacun reprÃ©sentant un slot disponible : [{ json: { date: â€œYYYY-MM-DDâ€, status: â€œavailableâ€ } }, â€¦].</p></li>
<li><p><em>DÃ©pendances :</em> WF-Notion-Helper, Google Calendar Credentials.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Prospection</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> GÃ©rer lâ€™envoi massif et personnalisÃ© dâ€™emails de prospection.</p></li>
<li><p><em>Trigger :</em> Execute Workflow.</p></li>
<li><p><em>Input :</em> { â€œconfigâ€: object, â€œavailableDatesâ€: string[], â€œtargetFiltersâ€?: object }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Appel WF-AI-Team-Executor (Team 1) :</strong> GÃ©nÃ©rer message de base. Input : { aiTeamName: â€œTeam1â€, prompt: â€œRÃ©dige email base pour artiste X proposant dates: â€œ + input.availableDates.join(â€™, â€˜), â€¦ }. GÃ©rer erreur.</p></li>
<li><p><strong>WF-Notion-Helper (Find Contacts) :</strong> Lire config.notionDbContactsId. Input : { operation: â€œfindPageâ€, dbId: config.notionDbContactsId, filter: { and: [ { property: â€œStatut Emailâ€, select: { does_not_equal: â€œPROSPECTğŸ“¨ EnvoyÃ©â€ } }, â€¦input.targetFilters ] } }. GÃ©rer pagination si &gt; 100 contacts.</p></li>
<li><p><strong>SplitInBatches Node :</strong> Configurer batchSize (ex: 5 ou 10, potentiellement depuis config). Connecter la sortie â€œDoneâ€ pour terminer. Connecter la sortie de la derniÃ¨re Ã©tape de la boucle Ã  lâ€™input â€œExecute Next Batchâ€.</p></li>
<li><p><em>Dans la boucle (sortie â€œBatchâ€) :</em></p>
<ul>
<li><p><strong>Code Node (Get Details) :</strong> Pour chaque item (contact), extraire pageId, email, prÃ©nom, structureId (relation lieu).</p></li>
<li><p><strong>(Optionnel) WF-Notion-Helper (Get Lieu Details) :</strong> Si structureId existe, rÃ©cupÃ©rer dÃ©tails du lieu (Agence_Lieux_Structures).</p></li>
<li><p><strong>Appel WF-AI-Team-Executor (Team 2) :</strong> Personnaliser message. Input : { aiTeamName: â€œTeam2â€, prompt: â€œPersonnalise ce message base: [baseMsg] pour [PrÃ©nom] de [Structure] (infos lieu: [lieuDetails])â€¦â€, â€¦ }. GÃ©rer erreur.</p></li>
<li><p><strong>Get Template (IF Node + WF-Notion-Helper / Gmail Get Draft) :</strong></p>
<ul>
<li><p>Si template dans Notion : WF-Notion-Helper { operation: â€œgetPageâ€, pageId: config.templateId }. Extraire contenu.</p></li>
<li><p>Si template Gmail : Gmail Get Draft Node (filtrer par config.gmailTemplateSubject). Extraire bodyHtml.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Code Node (Inject Content) :</strong> Remplacer placeholder (ex: {{CONTENT}}) dans le template HTML/texte avec le message personnalisÃ© de lâ€™IA. GÃ©rer Ã©chappement HTML si nÃ©cessaire.</p></li>
<li><p><strong>Gmail Create Draft Node :</strong> to: contact.email, subject: â€¦, bodyType: HTML, message: finalHtml. Utiliser config.gmailCredentialName.</p></li>
<li><p><strong>WF-Notion-Helper (Update Status) :</strong> Mettre Ã  jour la page contact Notion. Input : { operation: â€œupdatePageâ€, pageId: contact.pageId, properties: { â€œStatut Emailâ€: { select: { name: â€œPROSPECTğŸ“§ Brouillon crÃ©Ã©â€ } }, â€œDate Dernier Contact N8Nâ€: { date: { start: new Date().toISOString() } } } }. GÃ©rer erreur.</p></li>
<li><p><strong>Wait Node :</strong> DÃ©lai randomisÃ© (ex: {{ Math.random() * (60 - 30) + 30 }} secondes, min/max depuis config?).</p></li>
</ul>
</li>
<li></li>
<li><p><em>AprÃ¨s la boucle (sortie â€œDoneâ€ de SplitInBatches) :</em></p>
<ul>
<li><p><strong>Appel WF-Monitoring :</strong> Logguer la fin de la campagne avec le nombre total traitÃ©.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œstatusâ€: â€œCompletedâ€, â€œtotalProcessedâ€: number }.</p></li>
<li><p><em>DÃ©pendances :</em> WF-AI-Team-Executor, WF-Notion-Helper, Gmail Credentials, Agence_Templates (si utilisÃ©).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Response-Handler</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Traiter les rÃ©ponses emails, qualifier avec lâ€™IA, mettre Ã  jour Notion et notifier.</p></li>
<li><p><em>Trigger :</em> Gmail Trigger (On Message) OU (Cron + Gmail Search/List + Code pour Ã©viter retraitement). <em>Gmail Trigger est plus temps rÃ©el mais peut nÃ©cessiter gestion Ã©tat pour Ã©viter doublons si N8N redÃ©marre.</em></p></li>
<li><p><em>Input :</em> Gmail message object.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Extraction (Code Node) :</strong> senderEmail, subject, plainBody, threadId, messageId.</p></li>
<li><p><strong>Context Identification (Code Node) :</strong></p>
<ul>
<li><p>Rechercher senderEmail dans Agence_Contacts. Si trouvÃ©, rÃ©cupÃ©rer contactId.</p></li>
<li><p>Rechercher dans toutes les bases [Artiste]_LOT_Booking (nÃ©cessite de lister les artistes actifs et leurs DB IDs via Agence_Artistes) un item liÃ© Ã  contactId OU dont le threadId (si stockÃ© lors de lâ€™envoi) correspond. <em>Logique potentiellement complexe et coÃ»teuse en appels Notion.</em></p></li>
<li><p>Si match trouvÃ©, rÃ©cupÃ©rer lotItemId et artistId.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>IF Node :</strong> Contexte trouvÃ© (lotItemId et artistId) ?</p>
<ul>
<li><p><em>Branche Oui :</em></p>
<ul>
<li><p><strong>Appel WF-Core-Config</strong>. GÃ©rer erreur.</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update Status) :</strong> Mettre Ã  jour LOT item { operation: â€œupdatePageâ€, pageId: lotItemId, properties: { â€œStatut Emailâ€: { select: { name: â€œPROSPECTğŸ§ RÃ©ponse reÃ§ueâ€ } } } }.</p></li>
<li><p><strong>Appel WF-AI-Team-Executor (Team 1 ou 3) :</strong> Analyser email. Input : { aiTeamName: â€œTeam1â€, prompt: â€œAnalyse cet email: [plainBody]. Extrait: sentiment (Positif/NÃ©gatif/Neutre), intention (Info/NÃ©go/Refus), dates proposÃ©es, questions clÃ©s. RÃ©ponds en JSON: { sentiment: â€˜â€¦â€™, intention: â€˜â€¦â€™, dates: [â€¦], questions: [â€¦] }â€, â€¦ }. GÃ©rer erreur.</p></li>
<li><p><strong>Code Node (Parse AI Response) :</strong> Extraire le JSON de la rÃ©ponse IA. GÃ©rer parsing error.</p></li>
<li><p><strong>Code Node (Determine Final Status) :</strong> Logique pour mapper sentiment/intention vers un statut Notion final (ex: â€œNÃ©goâ€, â€œRefus Poliâ€, â€œA recontacterâ€).</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update Details) :</strong> Mettre Ã  jour LOT item avec AI Sentiment RÃ©ponse, AI RÃ©sumÃ© RÃ©ponse (gÃ©nÃ©rÃ© par IA ou extrait), et le Statut Email final.</p></li>
<li><p><strong>Appel WF-Notification-Dispatcher :</strong> Alerter Booker/Manager. Input : { userId: config.booker.notionUserId, message: â€œRÃ©ponse reÃ§ue pour [Contact] / [Artiste]. Sentiment: â€œ + aiSentiment + â€œ. Statut: â€œ + finalStatus, â€¦ }.</p></li>
</ul>
</li>
<li></li>
<li><p><em>Branche Non :</em></p>
<ul>
<li><p><strong>Appel WF-Monitoring :</strong> Logguer (Warning) â€œEmail reÃ§u de [senderEmail] non associÃ© Ã  une prospection active.â€</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œprocessingStatusâ€: â€œSuccess/Skipped/Errorâ€, â€œlotItemId?â€: â€œâ€¦â€, â€œartistId?â€: â€œâ€¦â€ }.</p></li>
<li><p><em>DÃ©pendances :</em> Gmail Trigger/Credentials, Agence_Contacts, [Artiste]_LOT_Booking (tous), WF-Core-Config, WF-Notion-Helper, WF-AI-Team-Executor, WF-Notification-Dispatcher, WF-Monitoring.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Deal-Processor</strong></p>
<ul>
<li><p><em>RÃ´le Technique :</em> Synchroniser un accord de booking (DEAL) entre Notion LOT, Notion Agenda et Google Calendar.</p></li>
<li><p><em>Trigger :</em> Execute Workflow (appelÃ© par WF-Booking-Manager).</p></li>
<li><p><em>Input :</em> { â€œconfigâ€: object, â€œlotItemIdâ€: string }.</p></li>
<li><p><em>Logique Principale :</em></p>
<ul>
<li><p><strong>Appel WF-Notion-Helper (Get LOT Item) :</strong> RÃ©cupÃ©rer les dÃ©tails du lotItemId (Date, Lieu Relation, Artisteâ€¦).</p></li>
<li><p><strong>Validation (IF Node) :</strong> VÃ©rifier que le statut est bien â€œDEALâ€ ou similaire.</p></li>
<li><p><strong>GÃ©nÃ©ration ID Synchro (Code Node) :</strong> const syncId = â€œnotion_â€ + input.lotItemId;.</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update LOT Item) :</strong> Stocker syncId dans un champ GCal_Sync_ID sur le LOT item.</p></li>
<li><p><strong>Google Calendar Node (List Events) :</strong> Rechercher dans config.gCalBookingId un Ã©vÃ©nement avec privateExtendedProperty ou description contenant syncId.</p></li>
<li><p><strong>PrÃ©paration Event Data (Code Node) :</strong> Formater les donnÃ©es pour GCal (start/end dateTime avec timezone, summary, description, locationâ€¦). Inclure syncId dans extendedProperties.private.syncId ou description.</p></li>
<li><p><strong>IF Node :</strong> Ã‰vÃ©nement GCal trouvÃ© Ã  lâ€™Ã©tape 5 ?</p>
<ul>
<li><p><em>Branche Oui :</em> <strong>Google Calendar Node (Update Event)</strong>. Utiliser lâ€™eventId trouvÃ©.</p></li>
<li><p><em>Branche Non :</em> <strong>Google Calendar Node (Create Event)</strong>.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Code Node (Extract GCal ID) :</strong> RÃ©cupÃ©rer lâ€™eventId retournÃ© par GCal (Create ou Update).</p></li>
<li><p><strong>Appel WF-Notion-Helper (Update LOT Item) :</strong> Stocker eventId dans GCal_Event_ID.</p></li>
<li><p><strong>Appel WF-Notion-Helper (Create/Update Agenda Notion) :</strong></p>
<ul>
<li><p>Chercher page dans config.notionDbAgenda avec GCal_Sync_ID == syncId.</p></li>
<li><p>Si trouvÃ©e, mettre Ã  jour.</p></li>
<li><p>Si non trouvÃ©e, crÃ©er une nouvelle page, en liant au LOT item et en stockant GCal_Event_ID et GCal_Sync_ID.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>(Optionnel) Appel WF-Notion-Helper (Create Task) :</strong> CrÃ©er tÃ¢che logistique dans config.notionDbTaches.</p></li>
</ul>
</li>
<li></li>
<li><p><em>Output :</em> { â€œsyncStatusâ€: â€œSuccess/Errorâ€, â€œgCalEventId?â€: â€œâ€¦â€, â€œnotionAgendaPageId?â€: â€œâ€¦â€ }.</p></li>
<li><p><em>DÃ©pendances :</em> WF-Notion-Helper, Google Calendar Credentials, [Artiste]_LOT_Booking, [Artiste]_Agenda_Booking, [Artiste]_TÃ¢ches.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>WF-Booking-Logistics-Reminder, WF-Booking-Post-Concert, WF-Musician-Availability-Reminder, WF-Musician-Itinerary-Sender, WF-Task-Reminder, WF-HR-Onboarding, WF-HR-Payroll-Prep :</strong> Suivent des logiques similaires : dÃ©clencheur (Cron/Webhook/GCal), rÃ©cupÃ©ration de contexte (Notion/GCal), potentiellement appel IA (Team 2/4/6), action finale (Notification/Email/Update Notion/CrÃ©ation TÃ¢che). La clÃ© est lâ€™utilisation systÃ©matique des workflows utilitaires (WF-Core-Config, WF-Notion-Helper, WF-Notification-Dispatcher, WF-AI-Team-Executor, WF-Monitoring).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4. Robustesse, Tests et Documentation (IntÃ©grÃ©s et Approfondis) :</strong></p>
<ul>
<li><p><strong>4.1. Gestion dâ€™Erreurs SystÃ©matique et GraduÃ©e :</strong></p>
<ul>
<li><p><strong>tryâ€¦catch dans Code Nodes :</strong> Essentiel pour parser JSON, manipuler dates, logique complexe. Le catch doit appeler WF-Monitoring et retourner/throw une erreur structurÃ©e.</p></li>
<li><p><strong>Connexion Sorties Erreur :</strong> SystÃ©matique.</p>
<ul>
<li><p>NÅ“uds API (Notion, GCal, Gmail, HTTP Request vers IA) : Connecter sortie erreur vers WF-API-Retry-Logic. Si WF-API-Retry-Logic retourne shouldRetry: false, connecter vers WF-Monitoring.</p></li>
<li><p>NÅ“uds Execute Workflow : Connecter sortie erreur vers WF-Monitoring. Le WF appelÃ© doit gÃ©rer ses propres erreurs internes.</p></li>
<li><p>Autres nÅ“uds (Set, IF, Switchâ€¦) : Les erreurs sont rares mais si elles surviennent (ex: expression invalide), elles arrÃªtent lâ€™exÃ©cution et sont gÃ©rÃ©es par lâ€™Error Trigger global.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Error Trigger Global :</strong> ConfigurÃ© pour appeler WF-Monitoring avec Severity: Critical. Capture les erreurs non interceptÃ©es.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4.2. Idempotence RenforcÃ©e :</strong></p>
<ul>
<li><p><strong>StratÃ©gie :</strong> â€œCheck-then-Actâ€ ou utilisation dâ€™identifiants uniques.</p></li>
<li><p><em>Exemple GCal Sync (WF-Booking-Deal-Processor) :</em> Utilisation de GCal_Sync_ID (basÃ© sur lotItemId) pour rechercher lâ€™Ã©vÃ©nement <em>avant</em> de crÃ©er. Si trouvÃ©, on met Ã  jour. Garantit quâ€™un seul Ã©vÃ©nement GCal est crÃ©Ã© mÃªme si le WF est dÃ©clenchÃ© plusieurs fois.</p></li>
<li><p><em>Exemple Envoi Email (WF-Booking-Prospection) :</em> Le statut Notion (â€Brouillon crÃ©Ã©â€, â€œEnvoyÃ©â€) empÃªche de renvoyer au mÃªme contact.</p></li>
<li><p><em>Exemple CrÃ©ation TÃ¢che :</em> Si une tÃ¢che a un titre/identifiant prÃ©visible, rechercher si elle existe avant de la crÃ©er.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4.3. Validation des DonnÃ©es Stricte (SchÃ©mas) :</strong></p>
<ul>
<li><p><strong>NÅ“ud Schema Validation ou Code + zod :</strong></p>
<ul>
<li><p>Placer au dÃ©but des workflows dÃ©clenchÃ©s par des sources externes non fiables (Webhook, Gmail Trigger). Valider le payload/message entrant.</p></li>
<li><p>Placer avant les appels Execute Workflow pour sâ€™assurer que les inputs sont corrects.</p></li>
<li><p>Placer avant les nÅ“uds API critiques (ex: Create GCal Event, Notion Create Page) pour valider les donnÃ©es formatÃ©es.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>DÃ©finition SchÃ©mas :</strong> Stocker les schÃ©mas Zod/JSON Schema dans Agence_Documentation ou un repo Git dÃ©diÃ©. Versionner les schÃ©mas.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>4.4. StratÃ©gie de Test Multi-Niveaux (DÃ©taillÃ©e) :</strong></p>
<ul>
<li><p><strong>Unitaire (Test Step) :</strong> Isoler un nÅ“ud. Utiliser â€œEdit Input Dataâ€ pour fournir des cas de test variÃ©s (donnÃ©es valides, invalides, limites). VÃ©rifier â€œOutput Dataâ€.</p></li>
<li><p><strong>IntÃ©gration (Sous-WF via â€œTest Harnessâ€) :</strong></p>
<ul>
<li><p>CrÃ©er un WF Test_[Nom_Sous_WF].</p></li>
<li><p>Manual Trigger.</p></li>
<li><p>Set Node(s) pour simuler les inputs requis par le sous-WF (y compris lâ€™objet config).</p></li>
<li><p>Execute Workflow Node appelant le sous-WF.</p></li>
<li><p>Code Node (Assertions) : VÃ©rifier si lâ€™output du sous-WF correspond aux attentes (expect(output.data.status).toBe(â€™Successâ€™);). Throw error si assertion Ã©choue.</p></li>
<li><p>VÃ©rifier manuellement les effets de bord (Notion, GCalâ€¦).</p></li>
</ul>
</li>
<li></li>
<li><p><strong>IntÃ©gration (Manager WF / End-to-End) :</strong></p>
<ul>
<li><p>NÃ©cessite un environnement de test isolÃ© (Staging N8N, Notion â€œTest Artistâ€, GCal â€œTestâ€, Gmail â€œTestâ€).</p></li>
<li><p>PrÃ©parer les donnÃ©es initiales (ex: contact Notion Ã  prospecter).</p></li>
<li><p>DÃ©clencher le Manager WF (manuellement ou via webhook de test).</p></li>
<li><p>Suivre lâ€™exÃ©cution dans N8N.</p></li>
<li><p>VÃ©rifier les Ã©tats finaux dans Notion, GCal, Gmail.</p></li>
<li><p>Nettoyer les donnÃ©es de test.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Tests de Charge (Basique N8N) :</strong></p>
<ul>
<li><p>CrÃ©er un WF simple : Manual Trigger -&gt; Loop Over Items (ex: 1000 itÃ©rations) -&gt; Execute Workflow (appelant le WF Ã  tester via Webhook si possible, ou directement).</p></li>
<li><p>Monitorer lâ€™utilisation CPU/RAM de lâ€™instance N8N.</p></li>
<li><p>VÃ©rifier les logs Agence_Monitoring_N8N pour les erreurs de rate limit (429).</p></li>
<li><p>Mesurer le temps total dâ€™exÃ©cution.</p></li>
</ul>
</li>
<li></li>
<li><p><strong>Tests Utilisateur (UAT) :</strong></p>
<ul>
<li><p>DÃ©finir des scÃ©narios utilisateur clairs (ex: â€œProspecter 10 contacts pour Gribitchâ€, â€œValider le deal pour le concert Xâ€, â€œSoumettre mes indisponibilitÃ©s pour le mois prochainâ€).</p></li>
<li><p>Fournir un accÃ¨s Ã  lâ€™environnement Staging (CMS/Notion/N8N si pertinent).</p></li>
<li><p>Utiliser un outil de suivi de feedback (Trello, Jira, Notion DB).</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>4.5. Documentation Vivante et Accessible :</strong></p></li>
</ul>
</li>
</ul>
<p><strong>Sticky Notes :</strong> Utiliser Markdown :<br />#### WF-Booking-Prospection Loop Item</p>
<p>**// OBJECTIF:** Personnaliser et envoyer un email de prospection Ã  un contact.<br />**// INPUT:** Item du SplitInBatches (donnÃ©es contact Notion), Message Base IA (depuis nÅ“ud prÃ©cÃ©dent).<br />**// OUTPUT:** Statut de lâ€™envoi/mise Ã  jour Notion pour ce contact.<br />**// LOGIQUE CLÃ‰:**<br />1. RÃ©cupÃ©rer dÃ©tails lieu (si pertinent).<br />2. Appel Team 2 pour personnalisation.<br />3. RÃ©cupÃ©rer template Gmail/Notion.<br />4. Injecter contenu personnalisÃ©.<br />5. CrÃ©er Brouillon Gmail.<br />6. Mettre Ã  jour statut contact Notion via WF-Notion-Helper.<br />7. Attendre dÃ©lai randomisÃ©.<br />**// ERREURS:** GÃ©rÃ©es par WF-API-Retry-Logic / WF-Monitoring.</p>
<ul class="simple">
<li><ul>
<li><p><strong>Nommage :</strong> PrÃ©fixes Util_, Booking_, HR_, Notion_, GCal_, AI_. Suffixes _Main (Orchestrateur), _Sub (ExÃ©cutant).</p>
<ul>
<li><p><strong>Organisation Visuelle :</strong> Cadres (Sticky Note large, couleur par phase/type). Alignement logique des nÅ“uds.</p></li>
<li><p><strong>Documentation Externe (Agence_Documentation - Notion DB) :</strong></p>
<ul>
<li><p><em>Type de Page :</em> Workflow Spec, Architecture Diagram, Convention Guide, API Endpoint, Glossary Term.</p></li>
<li><p><em>PropriÃ©tÃ©s Workflow Spec :</em> Nom Workflow (Title), ID N8N (Text), Lien N8N Editor (URL), Version (Text), Statut (Select: Dev, Staging, Prod, Deprecated), Responsable Dev (Relation -&gt; Agence_Ã‰quipe), Description (Text), Triggers (Multi-Select), Inputs Schema (Text - JSON Schema/Zod), Outputs Schema (Text - JSON Schema/Zod), DÃ©pendances WF (Relation -&gt; Agence_Documentation), DÃ©pendances Externes (Multi-Select: Notion, GCal, Team1â€¦), Notes Techniques (Text).</p></li>
<li><p>Utiliser des synced blocks Notion pour partager des diagrammes ou conventions entre plusieurs pages.</p></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
<li><p><strong>Matrices ACRI :</strong> Les matrices fournies sont un excellent point de dÃ©part. Les affiner pour chaque sous-processus critique (ex: Gestion erreur API, Validation donnÃ©es qualitÃ©) et les intÃ©grer dans Agence_Documentation.</p></li>
</ul>
</li>
<li></li>
</ul>
<hr class="docutils" />
<p>Ce dÃ©veloppement approfondi du Pilier 2 fournit aux ingÃ©nieurs une vision technique dÃ©taillÃ©e de lâ€™architecture N8N proposÃ©e, des interactions entre workflows, de la gestion des donnÃ©es et des erreurs, ainsi que des stratÃ©gies de test et de documentation nÃ©cessaires pour construire et maintenir un systÃ¨me robuste et Ã©volutif.</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, EMAIL_SENDER_1 Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>