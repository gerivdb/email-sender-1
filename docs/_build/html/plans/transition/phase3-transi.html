

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plan de Développement Détaillé - Phase 3 : Intégration avec le Plan Magistral V5 &mdash; EMAIL_SENDER_1 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            EMAIL_SENDER_1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contenu:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">Documentation des API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">EMAIL_SENDER_1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Plan de Développement Détaillé - Phase 3 : Intégration avec le Plan Magistral V5</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/plans/transition/phase3-transi.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="plan-de-developpement-detaille-phase-3-integration-avec-le-plan-magistral-v5">
<h1>Plan de Développement Détaillé - Phase 3 : Intégration avec le Plan Magistral V5<a class="headerlink" href="#plan-de-developpement-detaille-phase-3-integration-avec-le-plan-magistral-v5" title="Link to this heading"></a></h1>
<p>Je vais analyser en détail la Phase 3 du plan de transition et développer un plan d’implémentation exhaustif pour préparer le workflow à l’initialisation du Plan Magistral V5.</p>
<section id="analyse-preliminaire">
<h2>Analyse préliminaire<a class="headerlink" href="#analyse-preliminaire" title="Link to this heading"></a></h2>
<p>Commençons par examiner le contenu du fichier PILIER_1.md pour comprendre le contexte du Plan Magistral V5.<br />Read file<br />PILIER_1.mdplans/pour le futur<br />Maintenant que j’ai une meilleure compréhension du Plan Magistral V5, je vais développer un plan détaillé pour la Phase 3 du plan de transition.</p>
</section>
<section id="plan-de-developpement-detaille-phase-3">
<h2>Plan de Développement Détaillé - Phase 3<a class="headerlink" href="#plan-de-developpement-detaille-phase-3" title="Link to this heading"></a></h2>
<section id="vue-d-ensemble-de-la-phase-3">
<h3>Vue d’ensemble de la Phase 3<a class="headerlink" href="#vue-d-ensemble-de-la-phase-3" title="Link to this heading"></a></h3>
<p>Copy<br />┌─────────────────────────────────────────────────────────────────────┐<br />│                                                                     │<br />│                PHASE 3: INTÉGRATION AVEC LE PLAN MAGISTRAL V5       │<br />│                                                                     │<br />│  ┌───────────────┐    ┌───────────────┐    ┌───────────────────┐   │<br />│  │  ÉTAPE 3.1    │    │  ÉTAPE 3.2    │    │    ÉTAPE 3.3      │   │<br />│  │ Structures de │───&gt;│  Migration    │───&gt;│   Système de      │   │<br />│  │     Base      │    │Fonctionnalités│    │    Monitoring     │   │<br />│  └───────────────┘    └───────────────┘    └───────────────────┘   │<br />│                                                                     │<br />└─────────────────────────────────────────────────────────────────────┘</p>
</section>
</section>
<section id="etape-3-1-creation-des-structures-de-base">
<h2>Étape 3.1: Création des Structures de Base<a class="headerlink" href="#etape-3-1-creation-des-structures-de-base" title="Link to this heading"></a></h2>
<section id="mise-en-place-des-piliers">
<h3>3.1.1 Mise en Place des Piliers<a class="headerlink" href="#mise-en-place-des-piliers" title="Link to this heading"></a></h3>
<section id="workflows-a-developper">
<h4>Workflows à Développer<a class="headerlink" href="#workflows-a-developper" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-PILIER-INITIALIZER</p>
<ul class="simple">
<li><p>Objectif: Créer et configurer les workflows de base pour chaque pilier du Plan Magistral V5</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
<li><p>Copy</p></li>
</ol>
<p>{<br />”name”: “WF-PILIER-INITIALIZER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “pilierName”,<br />”value”: “==$input.item.json.pilierName || ‘PILIER_1’”<br />},<br />{<br />”name”: “pilierDescription”,<br />”value”: “==$input.item.json.pilierDescription || ‘La Donnée Stratégique’”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Pilier”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Génération du squelette du workflow pilier\nconst pilierName = $input.item.json.pilierName;\nconst pilierDescription = $input.item.json.pilierDescription;\n\n// Structure de base du workflow\nconst workflowStructure = {\n  name: pilierName,\n  nodes: [\n    {\n      parameters: {\n        triggerTimes: {\n          item: [\n            {\n              mode: \”manual\”\n            }\n          ]\n        }\n      },\n      name: \”Déclencheur Manuel\”,\n      type: \”n8n-nodes-base.manualTrigger\”,\n      position: [100, 300]\n    },\n    {\n      parameters: {\n        values: {\n          string: [\n            {\n              name: \”pilierName\”,\n              value: pilierName\n            },\n            {\n              name: \”pilierDescription\”,\n              value: pilierDescription\n            }\n          ]\n        }\n      },\n      name: \”Configuration Pilier\”,\n      type: \”n8n-nodes-base.set\”,\n      position: [300, 300]\n    },\n    {\n      parameters: {\n        functionCode: \”// Code de configuration spécifique au pilier\\nreturn $input.item;\”\n      },\n      name: \”Logique Pilier\”,\n      type: \”n8n-nodes-base.function\”,\n      position: [500, 300]\n    }\n  ],\n  connections: {\n    \”Déclencheur Manuel\”: {\n      main: [\n        [\n          {\n            node: \”Configuration Pilier\”,\n            type: \”main\”,\n            index: 0\n          }\n        ]\n      ]\n    },\n    \”Configuration Pilier\”: {\n      main: [\n        [\n          {\n            node: \”Logique Pilier\”,\n            type: \”main\”,\n            index: 0\n          }\n        ]\n      ]\n    }\n  }\n};\n\nreturn {\n  json: {\n    workflowStructure,\n    pilierName,\n    pilierDescription\n  }\n};”<br />},<br />”name”: “Générer Structure Workflow”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “workflows/piliers/{{$json.pilierName}}.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Structure Workflow”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”url”: “http://localhost:5678/rest/workflows”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”sendBody”: true,<br />”bodyParameters”: {<br />”parameters”: [<br />{<br />”name”: “name”,<br />”value”: “={{$json.pilierName}}”<br />},<br />{<br />”name”: “nodes”,<br />”value”: “={{$json.workflowStructure.nodes}}”<br />},<br />{<br />”name”: “connections”,<br />”value”: “={{$json.workflowStructure.connections}}”<br />},<br />{<br />”name”: “active”,<br />”value”: false<br />},<br />{<br />”name”: “settings”,<br />”value”: “{}”<br />}<br />]<br />},<br />”options”: {}<br />},<br />”name”: “Créer Workflow dans N8N”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [900, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.statusCode}}”,<br />”operation”: “startsWith”,<br />”value2”: “2”<br />}<br />]<br />}<br />},<br />”name”: “Vérifier Création”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “success”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Pilier {{$json.pilierName}} créé avec succès”<br />}<br />]<br />}<br />},<br />”name”: “Succès”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1300, 200]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “error”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Erreur lors de la création du pilier {{$json.pilierName}}: {{$json.statusCode}} - {{$json.statusMessage}}”<br />}<br />]<br />}<br />},<br />”name”: “Erreur”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1300, 400]<br />}<br />],<br />”connections”: {<br />”Déclencheur Manuel”: {<br />”main”: [<br />[<br />{<br />”node”: “Configuration Pilier”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Configuration Pilier”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Structure Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Générer Structure Workflow”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Structure Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Sauvegarder Structure Workflow”: {<br />”main”: [<br />[<br />{<br />”node”: “Créer Workflow dans N8N”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Créer Workflow dans N8N”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Création”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Vérifier Création”: {<br />”main”: [<br />[<br />{<br />”node”: “Succès”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Erreur”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
<p>2. WF-PILIER-CONFIG-GENERATOR</p>
<ul class="simple">
<li><p>Objectif: Générer les configurations spécifiques pour chaque pilier</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>{<br />”name”: “WF-PILIER-CONFIG-GENERATOR”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “pilierName”,<br />”value”: “==$input.item.json.pilierName || ‘PILIER_1’”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Entrée”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.pilierName}}”,<br />”operation”: “equal”,<br />”value2”: “PILIER_1”<br />}<br />]<br />}<br />},<br />”name”: “Vérifier Pilier”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “configType”,<br />”value”: “donnee_strategique”<br />}<br />],<br />”object”: [<br />{<br />”name”: “configData”,<br />”value”: {<br />”notionDatabases”: [<br />{<br />”name”: “Agence_Artistes”,<br />”id”: “{{$env.NOTION_DB_ARTISTES}}”<br />},<br />{<br />”name”: “Agence_Contacts”,<br />”id”: “{{$env.NOTION_DB_CONTACTS}}”<br />}<br />],<br />”gDriveFolders”: [<br />{<br />”name”: “Agence”,<br />”id”: “{{$env.GDRIVE_FOLDER_AGENCE}}”<br />}<br />]<br />}<br />}<br />]<br />}<br />},<br />”name”: “Config Pilier 1”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [700, 200]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “configType”,<br />”value”: “autre_pilier”<br />}<br />],<br />”object”: [<br />{<br />”name”: “configData”,<br />”value”: {<br />”defaultConfig”: true<br />}<br />}<br />]<br />}<br />},<br />”name”: “Config Autre Pilier”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [700, 400]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Génération du fichier de configuration\nconst pilierName = $input.item.json.pilierName;\nconst configType = $input.item.json.configType;\nconst configData = $input.item.json.configData;\n\n// Structure de configuration\nconst configStructure = {\n  pilierName,\n  configType,\n  configData,\n  timestamp: new Date().toISOString(),\n  version: \”1.0.0\”\n};\n\n// Convertir en JSON formaté\nconst configJson = JSON.stringify(configStructure, null, 2);\n\nreturn {\n  json: {\n    pilierName,\n    configType,\n    configJson\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(configJson).toString(’base64’),\n      fileName: `${pilierName}_config.json`\n    }\n  }\n};”<br />},<br />”name”: “Générer Config JSON”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/piliers/{{$json.pilierName}}_config.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Config”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1100, 300]<br />}<br />],<br />”connections”: {<br />”Déclencheur Manuel”: {<br />”main”: [<br />[<br />{<br />”node”: “Configuration Entrée”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Configuration Entrée”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Pilier”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Vérifier Pilier”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Pilier 1”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Config Autre Pilier”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Pilier 1”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Config JSON”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Autre Pilier”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Config JSON”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Générer Config JSON”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
<p>WF-PILIER-STRUCTURE-VALIDATOR</p>
<ul class="simple">
<li><p>Objectif: Valider que les structures de base nécessaires pour chaque pilier sont correctement configurées</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>{<br />”name”: “WF-PILIER-STRUCTURE-VALIDATOR”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”rule”: {<br />”interval”: [<br />{<br />”field”: “hours”,<br />”hour”: 9<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Cron”,<br />”type”: “n8n-nodes-base.cron”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Liste des piliers à valider\nconst piliers = [\n  { name: ‘PILIER_1’, description: ‘La Donnée Stratégique’ },\n  { name: ‘PILIER_2’, description: ‘Les Processus Automatisés’ },\n  { name: ‘PILIER_3’, description: ‘L\\’Intelligence Augmentée’ },\n  { name: ‘PILIER_4’, description: ‘Les Interfaces Utilisateur’ }\n];\n\nreturn piliers.map(pilier =&gt; ({ json: pilier }));”<br />},<br />”name”: “Définir Piliers”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”url”: “=http://localhost:5678/rest/workflows?filter={{$json.name}}”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”options”: {}<br />},<br />”name”: “Vérifier Existence Workflow”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”number”: [<br />{<br />”value1”: “={{$json.data.length}}”,<br />”operation”: “equal”,<br />”value2”: 0<br />}<br />]<br />}<br />},<br />”name”: “Workflow Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “missing”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Le workflow pour le pilier {{$json.name}} n’existe pas et doit être créé”<br />}<br />]<br />}<br />},<br />”name”: “Workflow Manquant”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “exists”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Le workflow pour le pilier {{$json.name}} existe”<br />}<br />]<br />}<br />},<br />”name”: “Workflow Existe”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [900, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/piliers/{{$json.name}}_config.json”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Vérifier Config”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.status}}”,<br />”operation”: “equal”,<br />”value2”: “missing”<br />}<br />]<br />}<br />},<br />”name”: “Config Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1300, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “configStatus”,<br />”value”: “missing”<br />},<br />{<br />”name”: “configMessage”,<br />”value”: “=La configuration pour le pilier {{$json.name}} n’existe pas et doit être créée”<br />}<br />]<br />}<br />},<br />”name”: “Config Manquante”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1500, 200]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “configStatus”,<br />”value”: “exists”<br />},<br />{<br />”name”: “configMessage”,<br />”value”: “=La configuration pour le pilier {{$json.name}} existe”<br />}<br />]<br />}<br />},<br />”name”: “Config Existe”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1500, 400]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.status}}”,<br />”operation”: “equal”,<br />”value2”: “missing”<br />}<br />]<br />}<br />},<br />”name”: “Action Nécessaire?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1700, 300]<br />},<br />{<br />”parameters”: {<br />”chatId”: “{{$env.TELEGRAM_CHAT_ID}}”,<br />”text”: “=⚠️ ALERTE STRUCTURE PILIER\n\nLe pilier {{$json.name}} ({{$json.description}}) nécessite une action:\n- Workflow: {{$json.status}} - {{$json.message}}\n- Configuration: {{$json.configStatus}} - {{$json.configMessage}}\n\nVeuillez exécuter les workflows de configuration appropriés.”,<br />”additionalFields”: {}<br />},<br />”name”: “Envoyer Alerte”,<br />”type”: “n8n-nodes-base.telegram”,<br />”position”: [1900, 200]<br />}<br />],<br />”connections”: {<br />”Déclencheur Cron”: {<br />”main”: [<br />[<br />{<br />”node”: “Définir Piliers”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Définir Piliers”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Existence Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Vérifier Existence Workflow”: {<br />”main”: [<br />[<br />{<br />”node”: “Workflow Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Workflow Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Workflow Manquant”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Workflow Existe”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Workflow Manquant”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Workflow Existe”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Vérifier Config”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Manquante”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Config Existe”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Manquante”: {<br />”main”: [<br />[<br />{<br />”node”: “Action Nécessaire?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Existe”: {<br />”main”: [<br />[<br />{<br />”node”: “Action Nécessaire?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Action Nécessaire?”: {<br />”main”: [<br />[<br />{<br />”node”: “Envoyer Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[]<br />]<br />}<br />}<br />}</p>
</section>
<section id="diagramme-ascii-des-piliers">
<h4>Diagramme ASCII des Piliers<a class="headerlink" href="#diagramme-ascii-des-piliers" title="Link to this heading"></a></h4>
<p>Copy<br />┌───────────────────────────────────────────────────────────────────────────┐<br />│                                                                           │<br />│                        ARCHITECTURE DES PILIERS                           │<br />│                                                                           │<br />│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────┐  │<br />│  │  PILIER 1   │     │  PILIER 2   │     │  PILIER 3   │     │ PILIER 4│  │<br />│  │  Données    │────&gt;│  Processus  │────&gt;│ Intelligence│────&gt;│Interfaces│  │<br />│  │ Stratégiques│     │ Automatisés │     │  Augmentée  │     │Utilisateur│ │<br />│  └─────────────┘     └─────────────┘     └─────────────┘     └─────────┘  │<br />│         │                   │                   │                 │        │<br />│         ▼                   ▼                   ▼                 ▼        │<br />│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────┐  │<br />│  │  Notion DB  │     │  Workflows  │     │  AI Teams   │     │   CMS   │  │<br />│  │  GDrive     │     │    N8N      │     │ OpenRouter  │     │  API    │  │<br />│  └─────────────┘     └─────────────┘     └─────────────┘     └─────────┘  │<br />│                                                                           │<br />└───────────────────────────────────────────────────────────────────────────┘</p>
</section>
</section>
<section id="configuration-des-webhooks-et-points-d-integration">
<h3>3.1.2 Configuration des Webhooks et Points d’Intégration<a class="headerlink" href="#configuration-des-webhooks-et-points-d-integration" title="Link to this heading"></a></h3>
<section id="id1">
<h4>Workflows à Développer<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-WEBHOOK-MANAGER</p>
<ul class="simple">
<li><p>Objectif: Créer et gérer les webhooks pour la communication entre les piliers</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
<li><p>Copy</p></li>
</ol>
<p>{<br />”name”: “WF-WEBHOOK-MANAGER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “action”,<br />”value”: “==$input.item.json.action || ‘list’”<br />},<br />{<br />”name”: “webhookPath”,<br />”value”: “==$input.item.json.webhookPath”<br />},<br />{<br />”name”: “sourcePilier”,<br />”value”: “==$input.item.json.sourcePilier”<br />},<br />{<br />”name”: “targetPilier”,<br />”value”: “==$input.item.json.targetPilier”<br />},<br />{<br />”name”: “description”,<br />”value”: “==$input.item.json.description || ‘Communication inter-piliers’”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Entrée”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.action}}”,<br />”operation”: “equal”,<br />”value2”: “create”<br />}<br />]<br />}<br />},<br />”name”: “Action?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “{{$json.webhookPath}}”,<br />”responseMode”: “lastNode”,<br />”options”: {<br />”responseHeaders”: {<br />”entries”: [<br />{<br />”name”: “Content-Type”,<br />”value”: “application/json”<br />}<br />]<br />}<br />}<br />},<br />”name”: “Créer Webhook”,<br />”type”: “n8n-nodes-base.webhook”,<br />”position”: [700, 200]<br />},<br />{<br />”parameters”: {<br />”url”: “http://localhost:5678/rest/webhooks”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”options”: {}<br />},<br />”name”: “Lister Webhooks”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [700, 400]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Traitement après création du webhook\nconst webhookData = {\n  path: $input.item.json.webhookPath,\n  method: ‘POST’,\n  sourcePilier: $input.item.json.sourcePilier,\n  targetPilier: $input.item.json.targetPilier,\n  description: $input.item.json.description,\n  createdAt: new Date().toISOString(),\n  webhookUrl: `${$env.N8N_BASE_URL}/webhook/${$input.item.json.webhookPath}`\n};\n\n// Sauvegarder les informations du webhook\nreturn {\n  json: webhookData\n};”<br />},<br />”name”: “Traiter Création Webhook”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”path”: “webhooks/{{$json.path}}.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Info Webhook”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1100, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Traitement de la liste des webhooks\nconst webhooks = $input.item.json.data || [];\n\n// Formater les informations\nconst formattedWebhooks = webhooks.map(webhook =&gt; ({\n  id: webhook.id,\n  name: webhook.name,\n  path: webhook.webhookPath,\n  httpMethod: webhook.httpMethod,\n  webhookUrl: `${$env.N8N_BASE_URL}/webhook/${webhook.webhookPath}`\n}));\n\nreturn {\n  json: {\n    count: formattedWebhooks.length,\n    webhooks: formattedWebhooks\n  }\n};”<br />},<br />”name”: “Traiter Liste Webhooks”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 400]<br />}</p>
<p>2.WF-INTEGRATION-POINTS-VALIDATOR</p>
<ul class="simple">
<li><p>Objectif: Valider que tous les points d’intégration entre les piliers sont correctement configurés</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>{<br />”name”: “WF-INTEGRATION-POINTS-VALIDATOR”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”rule”: {<br />”interval”: [<br />{<br />”field”: “hours”,<br />”hour”: 8<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Cron”,<br />”type”: “n8n-nodes-base.cron”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Définir les points d’intégration attendus\nconst expectedIntegrationPoints = [\n  { source: ‘PILIER_1’, target: ‘PILIER_2’, path: ‘pilier1-to-pilier2’ },\n  { source: ‘PILIER_2’, target: ‘PILIER_3’, path: ‘pilier2-to-pilier3’ },\n  { source: ‘PILIER_3’, target: ‘PILIER_4’, path: ‘pilier3-to-pilier4’ },\n  { source: ‘PILIER_4’, target: ‘PILIER_1’, path: ‘pilier4-to-pilier1’ }\n];\n\nreturn expectedIntegrationPoints.map(point =&gt; ({ json: point }));”<br />},<br />”name”: “Définir Points d’Intégration”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “webhooks/{{$json.path}}.json”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Vérifier Webhook”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.errorMessage}}”,<br />”operation”: “exists”<br />}<br />]<br />}<br />},<br />”name”: “Webhook Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “missing”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Le webhook pour l’intégration {{$json.source}} -&gt; {{$json.target}} n’existe pas”<br />}<br />]<br />}<br />},<br />”name”: “Webhook Manquant”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “exists”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Le webhook pour l’intégration {{$json.source}} -&gt; {{$json.target}} existe”<br />}<br />]<br />}<br />},<br />”name”: “Webhook Existe”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [900, 400]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.status}}”,<br />”operation”: “equal”,<br />”value2”: “missing”<br />}<br />]<br />}<br />},<br />”name”: “Action Nécessaire?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”chatId”: “{{$env.TELEGRAM_CHAT_ID}}”,<br />”text”: “=⚠️ ALERTE POINT D’INTÉGRATION\n\nLe point d’intégration {{$json.source}} -&gt; {{$json.target}} ({{$json.path}}) nécessite une action:\n- Statut: {{$json.status}}\n- Message: {{$json.message}}\n\nVeuillez exécuter WF-WEBHOOK-MANAGER pour créer ce webhook.”,<br />”additionalFields”: {}<br />},<br />”name”: “Envoyer Alerte”,<br />”type”: “n8n-nodes-base.telegram”,<br />”position”: [1300, 200]<br />}<br />],<br />”connections”: {<br />”Déclencheur Cron”: {<br />”main”: [<br />[<br />{<br />”node”: “Définir Points d’Intégration”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Définir Points d’Intégration”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Webhook”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Vérifier Webhook”: {<br />”main”: [<br />[<br />{<br />”node”: “Webhook Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Webhook Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Webhook Manquant”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Webhook Existe”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Webhook Manquant”: {<br />”main”: [<br />[<br />{<br />”node”: “Action Nécessaire?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Webhook Existe”: {<br />”main”: [<br />[<br />{<br />”node”: “Action Nécessaire?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Action Nécessaire?”: {<br />”main”: [<br />[<br />{<br />”node”: “Envoyer Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[]<br />]<br />}<br />}<br />}</p>
</section>
<section id="diagramme-ascii-des-points-d-integration">
<h4>Diagramme ASCII des Points d’Intégration<a class="headerlink" href="#diagramme-ascii-des-points-d-integration" title="Link to this heading"></a></h4>
<p>Copy<br />┌─────────────────────────────────────────────────────────────────────────┐<br />│                                                                         │<br />│                    ARCHITECTURE DES POINTS D’INTÉGRATION                │<br />│                                                                         │<br />│  ┌─────────────┐                                     ┌─────────────┐    │<br />│  │  PILIER 1   │◄────────────────────────────────────┤  PILIER 4   │    │<br />│  │  Données    │                                     │ Interfaces  │    │<br />│  │ Stratégiques│                                     │ Utilisateur │    │<br />│  └─────────────┘                                     └─────────────┘    │<br />│        │                                                    ▲           │<br />│        │                                                    │           │<br />│        │                                                    │           │<br />│        │                                                    │           │<br />│        ▼                                                    │           │<br />│  ┌─────────────┐                                     ┌─────────────┐    │<br />│  │  PILIER 2   │                                     │  PILIER 3   │    │<br />│  │  Processus  │────────────────────────────────────►│ Intelligence│    │<br />│  │ Automatisés │                                     │  Augmentée  │    │<br />│  └─────────────┘                                     └─────────────┘    │<br />│                                                                         │<br />└─────────────────────────────────────────────────────────────────────────┘</p>
</section>
</section>
<section id="mise-en-place-du-systeme-de-configuration-centralise">
<h3>3.1.3 Mise en Place du Système de Configuration Centralisé<a class="headerlink" href="#mise-en-place-du-systeme-de-configuration-centralise" title="Link to this heading"></a></h3>
<section id="id2">
<h4>Workflows à Développer<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-CORE-CONFIG-CENTRAL</p>
<ul class="simple">
<li><p>Objectif: Créer un système de configuration centralisé pour tous les piliers</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
<li><p>Copy</p></li>
</ol>
<p>{<br />”name”: “WF-CORE-CONFIG-CENTRAL”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”path”: “core-config”,<br />”responseMode”: “onReceived”,<br />”options”: {}<br />},<br />”name”: “Webhook”,<br />”type”: “n8n-nodes-base.webhook”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Validation des paramètres d’entrée\nconst input = $input.item.json;\n\n// Vérifier les paramètres requis\nif (!input.configType) {\n  throw new Error(’Le paramètre configType est requis’);\n}\n\n// Déterminer le type de configuration demandé\nconst configType = input.configType.toLowerCase();\nconst configId = input.configId || ‘default’;\n\n// Retourner les informations pour le chargement de la configuration\nreturn {\n  json: {\n    configType,\n    configId,\n    configPath: `configs/${configType}/${configId}.json`,\n    timestamp: new Date().toISOString()\n  }\n};”<br />},<br />”name”: “Valider Requête”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “={{$json.configPath}}”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Charger Configuration”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.errorMessage}}”,<br />”operation”: “exists”<br />}<br />]<br />}<br />},<br />”name”: “Config Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “error”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Configuration non trouvée: {{$json.configPath}}”<br />}<br />],<br />”object”: [<br />{<br />”name”: “error”,<br />”value”: {<br />”code”: “CONFIG_NOT_FOUND”,<br />”details”: “La configuration demandée n’existe pas”<br />}<br />}<br />]<br />}<br />},<br />”name”: “Config Non Trouvée”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Traiter la configuration chargée\nconst configData = $binary.data.toString();\n\n// Tenter de parser le JSON\nlet parsedConfig;\ntry {\n  parsedConfig = JSON.parse(configData);\n} catch (error) {\n  return {\n    json: {\n      status: ‘error’,\n      message: ‘Erreur de parsing JSON’,\n      error: {\n        code: ‘INVALID_JSON’,\n        details: error.message\n      }\n    }\n  };\n}\n\n// Ajouter des métadonnées\nparsedConfig.metadata = {\n  loadedAt: new Date().toISOString(),\n  configPath: $input.item.json.configPath,\n  configType: $input.item.json.configType,\n  configId: $input.item.json.configId\n};\n\nreturn {\n  json: {\n    status: ‘success’,\n    message: ‘Configuration chargée avec succès’,\n    config: parsedConfig\n  }\n};”<br />},<br />”name”: “Traiter Configuration”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 400]<br />},<br />{<br />”parameters”: {<br />”keepOnlySet”: true,<br />”values”: {<br />”string”: [<br />{<br />”name”: “notionDatabaseId_contacts”,<br />”value”: “={{$json.config.notionDatabases ? $json.config.notionDatabases.find(db =&gt; db.name === ‘Agence_Contacts’).id : $env.NOTION_DB_CONTACTS}}”<br />},<br />{<br />”name”: “notionDatabaseId_artistes”,<br />”value”: “={{$json.config.notionDatabases ? $json.config.notionDatabases.find(db =&gt; db.name === ‘Agence_Artistes’).id : $env.NOTION_DB_ARTISTES}}”<br />},<br />{<br />”name”: “gDriveFolderId_agence”,<br />”value”: “={{$json.config.gDriveFolders ? $json.config.gDriveFolders.find(folder =&gt; folder.name === ‘Agence’).id : $env.GDRIVE_FOLDER_AGENCE}}”<br />}<br />],<br />”number”: [<br />{<br />”name”: “delayBetweenEmails_minutes”,<br />”value”: “={{$json.config.emailSettings ? $json.config.emailSettings.delayBetweenEmails : 5}}”<br />}<br />],<br />”boolean”: [<br />{<br />”name”: “useAI_forEmailGeneration”,<br />”value”: “={{$json.config.aiSettings ? $json.config.aiSettings.useForEmailGeneration : true}}”<br />}<br />],<br />”object”: [<br />{<br />”name”: “configMetadata”,<br />”value”: “={{$json.config.metadata || {}}}”<br />}<br />]<br />},<br />”options”: {}<br />},<br />”name”: “Extraire Variables Config”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1100, 400]<br />}<br />],<br />”connections”: {<br />”Webhook”: {<br />”main”: [<br />[<br />{<br />”node”: “Valider Requête”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Valider Requête”: {<br />”main”: [<br />[<br />{<br />”node”: “Charger Configuration”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Charger Configuration”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Non Trouvée”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Traiter Configuration”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Traiter Configuration”: {<br />”main”: [<br />[<br />{<br />”node”: “Extraire Variables Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
<p>2.WF-CONFIG-UPDATER</p>
<ul class="simple">
<li><p>Objectif: Permettre la mise à jour des configurations centralisées</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>Copy<br />{<br />”name”: “WF-CONFIG-UPDATER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “configType”,<br />”value”: “==$input.item.json.configType || ‘piliers’”<br />},<br />{<br />”name”: “configId”,<br />”value”: “==$input.item.json.configId || ‘PILIER_1’”<br />}<br />],<br />”object”: [<br />{<br />”name”: “configData”,<br />”value”: “==$input.item.json.configData || {}”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Entrée”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/{{$json.configType}}/{{$json.configId}}.json”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Vérifier Config Existante”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.errorMessage}}”,<br />”operation”: “exists”<br />}<br />]<br />}<br />},<br />”name”: “Config Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Création d’une nouvelle configuration\nconst configType = $input.item.json.configType;\nconst configId = $input.item.json.configId;\nconst configData = $input.item.json.configData;\n\n// Ajouter des métadonnées\nconst newConfig = {\n  …configData,\n  metadata: {\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    configType,\n    configId,\n    version: ‘1.0.0’\n  }\n};\n\n// Convertir en JSON formaté\nconst configJson = JSON.stringify(newConfig, null, 2);\n\nreturn {\n  json: {\n    configType,\n    configId,\n    action: ‘create’,\n    config: newConfig\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(configJson).toString(’base64’),\n      fileName: `${configId}.json`\n    }\n  }\n};”<br />},<br />”name”: “Créer Nouvelle Config”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Mise à jour d’une configuration existante\nconst configType = $input.item.json.configType;\nconst configId = $input.item.json.configId;\nconst configData = $input.item.json.configData;\n\n// Charger la configuration existante\nconst existingConfigStr = $binary.data.toString();\nlet existingConfig;\n\ntry {\n  existingConfig = JSON.parse(existingConfigStr);\n} catch (error) {\n  // Si le parsing échoue, créer une nouvelle configuration\n  existingConfig = {};\n}\n\n// Fusionner avec les nouvelles données\nconst updatedConfig = {\n  …existingConfig,\n  …configData,\n  metadata: {\n    …existingConfig.metadata,\n    updatedAt: new Date().toISOString(),\n    previousVersion: existingConfig.metadata?.version || ‘0.0.0’,\n    version: existingConfig.metadata?.version ? incrementVersion(existingConfig.metadata.version) : ‘1.0.0’\n  }\n};\n\n// Fonction pour incrémenter la version\nfunction incrementVersion(version) {\n  const parts = version.split(’.’);\n  parts[2] = (parseInt(parts[2]) + 1).toString();\n  return parts.join(’.’);\n}\n\n// Convertir en JSON formaté\nconst configJson = JSON.stringify(updatedConfig, null, 2);\n\nreturn {\n  json: {\n    configType,\n    configId,\n    action: ‘update’,\n    config: updatedConfig\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(configJson).toString(’base64’),\n      fileName: `${configId}.json`\n    }\n  }\n};”<br />},<br />”name”: “Mettre à Jour Config”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/{{$json.configType}}/{{$json.configId}}.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Config”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “success”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Configuration {{$json.configId}} {{$json.action === ‘create’ ? ‘créée’ : ‘mise à jour’}} avec succès”<br />}<br />]<br />}<br />},<br />”name”: “Résultat”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1300, 300]<br />}<br />],<br />”connections”: {<br />”Déclencheur Manuel”: {<br />”main”: [<br />[<br />{<br />”node”: “Configuration Entrée”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Configuration Entrée”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Config Existante”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Vérifier Config Existante”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Créer Nouvelle Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Mettre à Jour Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Créer Nouvelle Config”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Mettre à Jour Config”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Sauvegarder Config”: {<br />”main”: [<br />[<br />{<br />”node”: “Résultat”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
</section>
<section id="diagramme-ascii-du-systeme-de-configuration-centralise">
<h4>Diagramme ASCII du Système de Configuration Centralisé<a class="headerlink" href="#diagramme-ascii-du-systeme-de-configuration-centralise" title="Link to this heading"></a></h4>
<p>Copy<br />┌─────────────────────────────────────────────────────────────────────────┐<br />│                                                                         │<br />│                SYSTÈME DE CONFIGURATION CENTRALISÉ                      │<br />│                                                                         │<br />│  ┌─────────────────────┐                                                │<br />│  │                     │                                                │<br />│  │  WF-CONFIG-UPDATER  │◄───────┐                                       │<br />│  │                     │        │                                       │<br />│  └─────────────────────┘        │                                       │<br />│            │                    │                                       │<br />│            ▼                    │                                       │<br />│  ┌─────────────────────┐        │                                       │<br />│  │                     │        │                                       │<br />│  │  FICHIERS CONFIG    │        │                                       │<br />│  │                     │        │                                       │<br />│  └─────────────────────┘        │                                       │<br />│            │                    │                                       │<br />│            ▼                    │                                       │<br />│  ┌─────────────────────┐        │                                       │<br />│  │                     │        │                                       │<br />│  │ WF-CORE-CONFIG-     │        │                                       │<br />│  │     CENTRAL         │        │                                       │<br />│  │                     │        │                                       │<br />│  └─────────────────────┘        │                                       │<br />│            │                    │                                       │<br />│            ▼                    │                                       │<br />│  ┌─────────────────────┐        │                                       │<br />│  │                     │        │                                       │<br />│  │  PILIERS            │────────┘                                       │<br />│  │                     │                                                │<br />│  └─────────────────────┘                                                │<br />│                                                                         │<br />└─────────────────────────────────────────────────────────────────────────┘</p>
</section>
</section>
</section>
<section id="etape-3-2-migration-des-fonctionnalites-existantes">
<h2>Étape 3.2: Migration des Fonctionnalités Existantes<a class="headerlink" href="#etape-3-2-migration-des-fonctionnalites-existantes" title="Link to this heading"></a></h2>
<section id="cartographie-des-fonctionnalites">
<h3>3.2.1 Cartographie des Fonctionnalités<a class="headerlink" href="#cartographie-des-fonctionnalites" title="Link to this heading"></a></h3>
<section id="id3">
<h4>Workflows à Développer<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-FUNCTIONALITY-MAPPER</p>
<ul class="simple">
<li><p>Objectif: Cartographier les fonctionnalités existantes et les associer aux piliers du Plan Magistral V5</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
<li><p>Copy</p></li>
</ol>
<p>{<br />”name”: “WF-FUNCTIONALITY-MAPPER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Définir les fonctionnalités existantes\nconst existingFunctionalities = [\n  {\n    id: ‘email_generation’,\n    name: ‘Génération d\\’Emails’,\n    description: ‘Génération d\\’emails personnalisés avec l\\’IA’,\n    currentWorkflow: ‘EMAIL_SENDER_1’,\n    currentPhase: ‘Phase 2’,\n    dependencies: [’notion_contacts’, ‘openrouter_ai’]\n  },\n  {\n    id: ‘email_sending’,\n    name: ‘Envoi d\\’Emails’,\n    description: ‘Envoi d\\’emails via Gmail’,\n    currentWorkflow: ‘EMAIL_SENDER_1’,\n    currentPhase: ‘Phase 3’,\n    dependencies: [’gmail_api’]\n  },\n  {\n    id: ‘response_analysis’,\n    name: ‘Analyse des Réponses’,\n    description: ‘Analyse des réponses aux emails avec l\\’IA’,\n    currentWorkflow: ‘EMAIL_SENDER_1’,\n    currentPhase: ‘Phase 4’,\n    dependencies: [’gmail_api’, ‘openrouter_ai’]\n  },\n  {\n    id: ‘calendar_management’,\n    name: ‘Gestion du Calendrier’,\n    description: ‘Création et gestion des événements dans Google Calendar’,\n    currentWorkflow: ‘EMAIL_SENDER_1’,\n    currentPhase: ‘Phase 5’,\n    dependencies: [’google_calendar_api’]\n  },\n  {\n    id: ‘notion_update’,\n    name: ‘Mise à Jour Notion’,\n    description: ‘Mise à jour des bases de données Notion’,\n    currentWorkflow: ‘EMAIL_SENDER_1’,\n    currentPhase: ‘Phase 6’,\n    dependencies: [’notion_api’]\n  }\n];\n\n// Définir les piliers du Plan Magistral V5\nconst magistralPillars = [\n  {\n    id: ‘PILIER_1’,\n    name: ‘La Donnée Stratégique’,\n    description: ‘Centralisée, Structurée, Validée, Sécurisée et Accessible’\n  },\n  {\n    id: ‘PILIER_2’,\n    name: ‘Les Processus Automatisés’,\n    description: ‘Workflows N8N optimisés et modulaires’\n  },\n  {\n    id: ‘PILIER_3’,\n    name: ‘L\\’Intelligence Augmentée’,\n    description: ‘Intégration des équipes IA via OpenRouter’\n  },\n  {\n    id: ‘PILIER_4’,\n    name: ‘Les Interfaces Utilisateur’,\n    description: ‘CMS et interfaces de gestion’\n  }\n];\n\n// Cartographier les fonctionnalités vers les piliers\nconst functionalityMapping = [\n  {\n    functionalityId: ‘email_generation’,\n    primaryPillarId: ‘PILIER_3’,\n    secondaryPillarIds: [’PILIER_2’],\n    migrationComplexity: ‘medium’,\n    migrationPriority: ‘high’\n  },\n  {\n    functionalityId: ‘email_sending’,\n    primaryPillarId: ‘PILIER_2’,\n    secondaryPillarIds: [],\n    migrationComplexity: ‘low’,\n    migrationPriority: ‘high’\n  },\n  {\n    functionalityId: ‘response_analysis’,\n    primaryPillarId: ‘PILIER_3’,\n    secondaryPillarIds: [’PILIER_2’],\n    migrationComplexity: ‘medium’,\n    migrationPriority: ‘medium’\n  },\n  {\n    functionalityId: ‘calendar_management’,\n    primaryPillarId: ‘PILIER_2’,\n    secondaryPillarIds: [’PILIER_1’],\n    migrationComplexity: ‘low’,\n    migrationPriority: ‘high’\n  },\n  {\n    functionalityId: ‘notion_update’,\n    primaryPillarId: ‘PILIER_1’,\n    secondaryPillarIds: [’PILIER_2’],\n    migrationComplexity: ‘medium’,\n    migrationPriority: ‘high’\n  }\n];\n\n// Enrichir les fonctionnalités avec les informations de mapping\nconst enrichedFunctionalities = existingFunctionalities.map(func =&gt; {\n  const mapping = functionalityMapping.find(map =&gt; map.functionalityId === func.id);\n  if (!mapping) return func;\n  \n  const primaryPillar = magistralPillars.find(pillar =&gt; pillar.id === mapping.primaryPillarId);\n  const secondaryPillars = mapping.secondaryPillarIds.map(id =&gt; \n    magistralPillars.find(pillar =&gt; pillar.id === id)\n  ).filter(Boolean);\n  \n  return {\n    …func,\n    mapping: {\n      primaryPillar: primaryPillar || null,\n      secondaryPillars,\n      migrationComplexity: mapping.migrationComplexity,\n      migrationPriority: mapping.migrationPriority\n    }\n  };\n});\n\nreturn enrichedFunctionalities.map(func =&gt; ({ json: func }));”<br />},<br />”name”: “Cartographier Fonctionnalités”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer un rapport de cartographie\nconst functionality = $input.item.json;\nconst primaryPillar = functionality.mapping?.primaryPillar;\nconst secondaryPillars = functionality.mapping?.secondaryPillars || [];\n\n// Formater le rapport\nconst report = {\n  functionalityId: functionality.id,\n  functionalityName: functionality.name,\n  description: functionality.description,\n  currentLocation: `${functionality.currentWorkflow} (${functionality.currentPhase})`,\n  dependencies: functionality.dependencies.join(’, ‘),\n  targetPillar: primaryPillar ? primaryPillar.name : ‘Non assigné’,\n  secondaryPillars: secondaryPillars.map(p =&gt; p.name).join(’, ‘) || ‘Aucun’,\n  migrationComplexity: functionality.mapping?.migrationComplexity || ‘Non évalué’,\n  migrationPriority: functionality.mapping?.migrationPriority || ‘Non évalué’\n};\n\nreturn {\n  json: report\n};”<br />},<br />”name”: “Générer Rapport”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”operation”: “append”,<br />”file”: “reports/functionality_mapping.csv”,<br />”options”: {<br />”columns”: {<br />”column1”: “functionalityId”,<br />”column2”: “functionalityName”,<br />”column3”: “description”,<br />”column4”: “currentLocation”,<br />”column5”: “dependencies”,<br />”column6”: “targetPillar”,<br />”column7”: “secondaryPillars”,<br />”column8”: “migrationComplexity”,<br />”column9”: “migrationPriority”<br />},<br />”fileName”: “functionality_mapping.csv”<br />}<br />},<br />”name”: “Sauvegarder en CSV”,<br />”type”: “n8n-nodes-base.spreadsheetFile”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “reports/functionality_mapping.md”,<br />”options”: {}<br />},<br />”name”: “Lire Rapport Markdown”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [900, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.errorMessage}}”,<br />”operation”: “exists”<br />}<br />]<br />}<br />},<br />”name”: “Rapport Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Créer un nouveau rapport Markdown\nconst reports = $input.all.map(item =&gt; item.json);\n\n// En-tête du rapport\nlet markdownContent = `# Cartographie des Fonctionnalités vers le Plan Magistral V5\n\n_Généré le ${new Date().toLocaleString(’fr-FR’)}_\n\n## Vue d’ensemble\n\nCe document présente la cartographie des fonctionnalités existantes du workflow Email Sender vers les piliers du Plan Magistral V5.\n\n## Tableau de Cartographie\n\n| Fonctionnalité | Description | Emplacement Actuel | Dépendances | Pilier Principal | Piliers Secondaires | Complexité | Priorité |\n|—————-|————-|——————-|————-|—————–|———————|————|———-|\n`;\n\n// Ajouter chaque fonctionnalité\nreports.forEach(report =&gt; {\n  markdownContent += `| ${report.functionalityName} | ${report.description} | ${report.currentLocation} | ${report.dependencies} | ${report.targetPillar} | ${report.secondaryPillars} | ${report.migrationComplexity} | ${report.migrationPriority} |\\n`;\n});\n\n// Ajouter des sections supplémentaires\nmarkdownContent += `\n\n## Analyse des Chevauchements\n\nCertaines fonctionnalités chevauchent plusieurs piliers :\n\n`;\n\n// Identifier les fonctionnalités avec des piliers secondaires\nconst overlappingFuncs = reports.filter(r =&gt; r.secondaryPillars &amp;&amp; r.secondaryPillars !== ‘Aucun’);\noverlappingFuncs.forEach(func =&gt; {\n  markdownContent += `- **${func.functionalityName}** : Principalement dans ${func.targetPillar}, mais aussi dans ${func.secondaryPillars}\\n`;\n});\n\n// Ajouter une section sur la séquence de migration\nmarkdownContent += `\n\n## Séquence de Migration Recommandée\n\n`;\n\n// Trier par priorité et complexité\nconst sortedByPriority = […reports].sort((a, b) =&gt; {\n  const priorityOrder = { high: 0, medium: 1, low: 2, ‘Non évalué’: 3 };\n  const complexityOrder = { low: 0, medium: 1, high: 2, ‘Non évalué’: 3 };\n  \n  if (priorityOrder[a.migrationPriority] !== priorityOrder[b.migrationPriority]) {\n    return priorityOrder[a.migrationPriority] - priorityOrder[b.migrationPriority];\n  }\n  \n  return complexityOrder[a.migrationComplexity] - complexityOrder[b.migrationComplexity];\n});\n\n// Ajouter la séquence recommandée\nmarkdownContent += `1. **Phase 1 : Fonctionnalités Prioritaires et Simples**\\n`;\nsortedByPriority\n  .filter(r =&gt; r.migrationPriority === ‘high’ &amp;&amp; r.migrationComplexity === ‘low’)\n  .forEach((r, i) =&gt; markdownContent += `   ${i+1}. ${r.functionalityName} (${r.targetPillar})\\n`);\n\nmarkdownContent += `\\n2. **Phase 2 : Fonctionnalités Prioritaires mais Complexes**\\n`;\nsortedByPriority\n  .filter(r =&gt; r.migrationPriority === ‘high’ &amp;&amp; r.migrationComplexity !== ‘low’)\n  .forEach((r, i) =&gt; markdownContent += `   ${i+1}. ${r.functionalityName} (${r.targetPillar})\\n`);\n\nmarkdownContent += `\\n3. **Phase 3 : Fonctionnalités Restantes**\\n`;\nsortedByPriority\n  .filter(r =&gt; r.migrationPriority !== ‘high’)\n  .forEach((r, i) =&gt; markdownContent += `   ${i+1}. ${r.functionalityName} (${r.targetPillar})\\n`);\n\nreturn {\n  json: {\n    markdownContent\n  },\n  binary: {\n    data: {\n      mimeType: ‘text/markdown’,\n      data: Buffer.from(markdownContent).toString(’base64’),\n      fileName: ‘functionality_mapping.md’\n    }\n  }\n};”<br />},<br />”name”: “Créer Rapport Markdown”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1300, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Mettre à jour le rapport Markdown existant\nconst existingReport = $binary.data.toString();\nconst reports = $input.all.map(item =&gt; item.json);\n\n// Extraire l’en-tête et les sections existantes\nconst headerMatch = existingReport.match(/^([\\s\\S]*?## Tableau de Cartographie)/m);\nconst header = headerMatch ? headerMatch[1] : ‘’;\n\n// Créer le nouveau tableau\nlet tableContent = `\n\n| Fonctionnalité | Description | Emplacement Actuel | Dépendances | Pilier Principal | Piliers Secondaires | Complexité | Priorité |\n|—————-|————-|——————-|————-|—————–|———————|————|———-|\n`;\n\n// Ajouter chaque fonctionnalité\nreports.forEach(report =&gt; {\n  tableContent += `| ${report.functionalityName} | ${report.description} | ${report.currentLocation} | ${report.dependencies} | ${report.targetPillar} | ${report.secondaryPillars} | ${report.migrationComplexity} | ${report.migrationPriority} |\\n`;\n});\n\n// Recréer les sections d’analyse\nlet analysisContent = `\n\n## Analyse des Chevauchements\n\nCertaines fonctionnalités chevauchent plusieurs piliers :\n\n`;\n\n// Identifier les fonctionnalités avec des piliers secondaires\nconst overlappingFuncs = reports.filter(r =&gt; r.secondaryPillars &amp;&amp; r.secondaryPillars !== ‘Aucun’);\noverlappingFuncs.forEach(func =&gt; {\n  analysisContent += `- **${func.functionalityName}** : Principalement dans ${func.targetPillar}, mais aussi dans ${func.secondaryPillars}\\n`;\n});\n\n// Ajouter une section sur la séquence de migration\nlet sequenceContent = `\n\n## Séquence de Migration Recommandée\n\n`;\n\n// Trier par priorité et complexité\nconst sortedByPriority = […reports].sort((a, b) =&gt; {\n  const priorityOrder = { high: 0, medium: 1, low: 2, ‘Non évalué’: 3 };\n  const complexityOrder = { low: 0, medium: 1, high: 2, ‘Non évalué’: 3 };\n  \n  if (priorityOrder[a.migrationPriority] !== priorityOrder[b.migrationPriority]) {\n    return priorityOrder[a.migrationPriority] - priorityOrder[b.migrationPriority];\n  }\n  \n  return complexityOrder[a.migrationComplexity] - complexityOrder[b.migrationComplexity];\n});\n\n// Ajouter la séquence recommandée\nsequenceContent += `1. **Phase 1 : Fonctionnalités Prioritaires et Simples**\\n`;\nsortedByPriority\n  .filter(r =&gt; r.migrationPriority === ‘high’ &amp;&amp; r.migrationComplexity === ‘low’)\n  .forEach((r, i) =&gt; sequenceContent += `   ${i+1}. ${r.functionalityName} (${r.targetPillar})\\n`);\n\nsequenceContent += `\\n2. **Phase 2 : Fonctionnalités Prioritaires mais Complexes**\\n`;\nsortedByPriority\n  .filter(r =&gt; r.migrationPriority === ‘high’ &amp;&amp; r.migrationComplexity !== ‘low’)\n  .forEach((r, i) =&gt; sequenceContent += `   ${i+1}. ${r.functionalityName} (${r.targetPillar})\\n`);\n\nsequenceContent += `\\n3. **Phase 3 : Fonctionnalités Restantes**\\n`;\nsortedByPriority\n  .filter(r =&gt; r.migrationPriority !== ‘high’)\n  .forEach((r, i) =&gt; sequenceContent += `   ${i+1}. ${r.functionalityName} (${r.targetPillar})\\n`);\n\n// Ajouter une note de mise à jour\nconst updateNote = `\n\n—\n\n_Rapport mis à jour le ${new Date().toLocaleString(’fr-FR’)}_\n`;\n\n// Assembler le rapport final\nconst updatedReport = header + tableContent + analysisContent + sequenceContent + updateNote;\n\nreturn {\n  json: {\n    markdownContent: updatedReport\n  },\n  binary: {\n    data: {\n      mimeType: ‘text/markdown’,\n      data: Buffer.from(updatedReport).toString(’base64’),\n      fileName: ‘functionality_mapping.md’\n    }\n  }\n};”<br />},<br />”name”: “Mettre à Jour Rapport”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1300, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “reports/functionality_mapping.md”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Rapport”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1500, 300]<br />}</p>
<p>2.WF-DEPENDENCY-ANALYZER</p>
<ul class="simple">
<li><p>Objectif: Analyser les dépendances entre les fonctionnalités pour planifier la séquence de migration</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>{<br />”name”: “WF-DEPENDENCY-ANALYZER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “reports/functionality_mapping.md”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Charger Cartographie”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Analyser les dépendances entre fonctionnalités\nconst reportContent = $binary.data.toString();\n\n// Extraire les informations du tableau\nconst tableRegex = /\\| ([^|]+) \\| [^|]+ \\| [^|]+ \\| ([^|]+) \\| ([^|]+) \\| [^|]+ \\| [^|]+ \\| [^|]+ \\|/g;\nlet match;\nconst functionalities = [];\n\nwhile ((match = tableRegex.exec(reportContent)) !== null) {\n  const functionalityName = match[1].trim();\n  if (functionalityName === ‘Fonctionnalité’) continue; // Skip header\n  \n  const dependencies = match[2].trim().split(’, ‘).map(d =&gt; d.trim());\n  const targetPillar = match[3].trim();\n  \n  functionalities.push({\n    name: functionalityName,\n    dependencies,\n    targetPillar\n  });\n}\n\n// Analyser les dépendances entre fonctionnalités\nconst dependencyGraph = {};\n\nfunctionalities.forEach(func =&gt; {\n  dependencyGraph[func.name] = {\n    targetPillar: func.targetPillar,\n    directDependencies: [],\n    indirectDependencies: []\n  };\n});\n\n// Identifier les dépendances directes\nfunctionalities.forEach(func =&gt; {\n  const funcDeps = func.dependencies;\n  \n  functionalities.forEach(otherFunc =&gt; {\n    if (func.name === otherFunc.name) return;\n    \n    // Vérifier si cette fonctionnalité dépend d’une ressource fournie par l’autre\n    const hasDirectDependency = funcDeps.some(dep =&gt; {\n      // Logique simplifiée - dans un cas réel, il faudrait une cartographie plus précise\n      // des ressources fournies par chaque fonctionnalité\n      if (dep === ‘notion_api’ &amp;&amp; otherFunc.name.includes(’Notion’)) return true;\n      if (dep === ‘gmail_api’ &amp;&amp; otherFunc.name.includes(’Email’)) return true;\n      if (dep === ‘google_calendar_api’ &amp;&amp; otherFunc.name.includes(’Calendrier’)) return true;\n      if (dep === ‘openrouter_ai’ &amp;&amp; otherFunc.name.includes(’IA’)) return true;\n      return false;\n    });\n    \n    if (hasDirectDependency) {\n      dependencyGraph[func.name].directDependencies.push(otherFunc.name);\n    }\n  });\n});\n\n// Identifier les dépendances indirectes (transitivité)\nfunctionalities.forEach(func =&gt; {\n  const visited = new Set();\n  const indirectDeps = new Set();\n  \n  function findIndirectDeps(funcName) {\n    if (visited.has(funcName)) return;\n    visited.add(funcName);\n    \n    const directDeps = dependencyGraph[funcName]?.directDependencies || [];\n    directDeps.forEach(dep =&gt; {\n      indirectDeps.add(dep);\n      findIndirectDeps(dep);\n    });\n  }\n  \n  findIndirectDeps(func.name);\n  dependencyGraph[func.name].indirectDependencies = Array.from(indirectDeps);\n});\n\n// Analyser les dépendances par pilier\nconst pillarDependencies = {};\n\nfunctionalities.forEach(func =&gt; {\n  const pillar = func.targetPillar;\n  if (!pillarDependencies[pillar]) {\n    pillarDependencies[pillar] = {\n      functionalities: [],\n      dependsOn: new Set(),\n      requiredBy: new Set()\n    };\n  }\n  \n  pillarDependencies[pillar].functionalities.push(func.name);\n});\n\n// Identifier les dépendances entre piliers\nObject.entries(dependencyGraph).forEach(([funcName, deps]) =&gt; {\n  const sourcePillar = deps.targetPillar;\n  \n  […deps.directDependencies, …deps.indirectDependencies].forEach(depFunc =&gt; {\n    const targetFunc = functionalities.find(f =&gt; f.name === depFunc);\n    if (!targetFunc) return;\n    \n    const targetPillar = targetFunc.targetPillar;\n    if (sourcePillar !== targetPillar) {\n      pillarDependencies[sourcePillar].dependsOn.add(targetPillar);\n      pillarDependencies[targetPillar].requiredBy.add(sourcePillar);\n    }\n  });\n});\n\n// Convertir les Sets en Arrays pour la sérialisation JSON\nObject.values(pillarDependencies).forEach(pillar =&gt; {\n  pillar.dependsOn = Array.from(pillar.dependsOn);\n  pillar.requiredBy = Array.from(pillar.requiredBy);\n});\n\nreturn {\n  json: {\n    functionalities: functionalities.length,\n    dependencyGraph,\n    pillarDependencies\n  }\n};”<br />},<br />”name”: “Analyser Dépendances”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [500, 300]<br />},</p>
<p>{<br />”parameters”: {<br />”functionCode”: “// Générer un rapport de dépendances\nconst analysis = $input.item.json;\n\n// Créer le contenu Markdown\nlet markdownContent = `# Analyse des Dépendances pour la Migration\n\n_Généré le ${new Date().toLocaleString(’fr-FR’)}_\n\n## Vue d’ensemble\n\nCe document présente l’analyse des dépendances entre les fonctionnalités et les piliers pour planifier la séquence de migration.\n\n## Dépendances entre Piliers\n\n`;\n\n// Ajouter les dépendances entre piliers\nObject.entries(analysis.pillarDependencies).forEach(([pillar, deps]) =&gt; {\n  markdownContent += `### ${pillar}\n\n`;\n  markdownContent += `- **Fonctionnalités** : ${deps.functionalities.join(’, ‘)}\\n`;\n  markdownContent += `- **Dépend de** : ${deps.dependsOn.length ? deps.dependsOn.join(’, ‘) : ‘Aucun’}\\n`;\n  markdownContent += `- **Requis par** : ${deps.requiredBy.length ? deps.requiredBy.join(’, ‘) : ‘Aucun’}\\n\\n`;\n});\n\n// Ajouter un diagramme ASCII des dépendances\nmarkdownContent += `## Diagramme de Dépendances\n\n\\`\\`\\`\n`;\n\n// Créer un diagramme ASCII simple\nconst pillars = Object.keys(analysis.pillarDependencies);\nconst pillarSymbols = {};\npillars.forEach((pillar, index) =&gt; {\n  pillarSymbols[pillar] = String.fromCharCode(65 + index); // A, B, C, D…\n});\n\n// Légende\nmarkdownContent += `Légende:\\n`;\nObject.entries(pillarSymbols).forEach(([pillar, symbol]) =&gt; {\n  markdownContent += `${symbol} = ${pillar}\\n`;\n});\nmarkdownContent += `\\n`;\n\n// Matrice de dépendances\nmarkdownContent += `Matrice de dépendances (ligne dépend de colonne):\\n\\n`;\nmarkdownContent += `    `;\npillars.forEach(pillar =&gt; {\n  markdownContent += `${pillarSymbols[pillar]} `;\n});\nmarkdownContent += `\\n`;\n\npillars.forEach(sourcePillar =&gt; {\n  markdownContent += `${pillarSymbols[sourcePillar]}   `;\n  pillars.forEach(targetPillar =&gt; {\n    const deps = analysis.pillarDependencies[sourcePillar];\n    const dependsOn = deps.dependsOn.includes(targetPillar);\n    markdownContent += dependsOn ? ‘X ‘ : ‘- ‘;\n  });\n  markdownContent += `\\n`;\n});\n\n// Graphe de dépendances\nmarkdownContent += `\\nGraphe de dépendances:\\n\\n`;\n\n// Créer un graphe ASCII simple\nconst graph = {};\npillars.forEach(pillar =&gt; {\n  graph[pillarSymbols[pillar]] = {\n    dependsOn: analysis.pillarDependencies[pillar].dependsOn.map(p =&gt; pillarSymbols[p])\n  };\n});\n\n// Dessiner le graphe\nObject.entries(graph).forEach(([symbol, node]) =&gt; {\n  markdownContent += `${symbol} `;\n  if (node.dependsOn.length) {\n    markdownContent += `—&gt; ${node.dependsOn.join(’, ‘)}\\n`;\n  } else {\n    markdownContent += `(indépendant)\\n`;\n  }\n});\n\nmarkdownContent += `\\`\\`\\`\n\n## Recommandations pour la Séquence de Migration\n\n`;\n\n// Déterminer l’ordre de migration basé sur les dépendances\nconst migrationOrder = [];\nconst visited = new Set();\n\nfunction visit(pillar) {\n  if (visited.has(pillar)) return;\n  visited.add(pillar);\n  \n  const deps = analysis.pillarDependencies[pillar].dependsOn;\n  deps.forEach(dep =&gt; visit(dep));\n  \n  migrationOrder.push(pillar);\n}\n\n// Visiter tous les piliers\npillars.forEach(pillar =&gt; {\n  if (!visited.has(pillar)) {\n    visit(pillar);\n  }\n});\n\n// Ajouter les recommandations\nmarkdownContent += `Basé sur l’analyse des dépendances, voici l’ordre de migration recommandé :\\n\\n`;\nmigrationOrder.forEach((pillar, index) =&gt; {\n  markdownContent += `${index + 1}. **${pillar}** - ${analysis.pillarDependencies[pillar].functionalities.length} fonctionnalités\\n`;\n});\n\nreturn {\n  json: {\n    markdownContent\n  },\n  binary: {\n    data: {\n      mimeType: ‘text/markdown’,\n      data: Buffer.from(markdownContent).toString(’base64’),\n      fileName: ‘dependency_analysis.md’\n    }\n  }\n};”<br />},<br />”name”: “Générer Rapport Markdown”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “reports/dependency_analysis.md”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Rapport”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [900, 300]<br />}</p>
</section>
<section id="diagramme-ascii-de-la-cartographie-des-fonctionnalites">
<h4>Diagramme ASCII de la Cartographie des Fonctionnalités<a class="headerlink" href="#diagramme-ascii-de-la-cartographie-des-fonctionnalites" title="Link to this heading"></a></h4>
<p>Copy<br />┌─────────────────────────────────────────────────────────────────────────┐<br />│                                                                         │<br />│                CARTOGRAPHIE DES FONCTIONNALITÉS                         │<br />│                                                                         │<br />│  ┌─────────────┐                                     ┌─────────────┐    │<br />│  │  PILIER 1   │                                     │  PILIER 4   │    │<br />│  │  Données    │◄────────┐                      ┌────┤ Interfaces  │    │<br />│  │ Stratégiques│         │                      │    │ Utilisateur │    │<br />│  └─────────────┘         │                      │    └─────────────┘    │<br />│        ▲                 │                      │                       │<br />│        │                 │                      │                       │<br />│        │                 │                      │                       │<br />│        │                 │                      │                       │<br />│        │                 │                      ▼                       │<br />│  ┌─────────────┐         │                 ┌─────────────┐              │<br />│  │  PILIER 2   │         │                 │  PILIER 3   │              │<br />│  │  Processus  │─────────┴────────────────►│ Intelligence│              │<br />│  │ Automatisés │                           │  Augmentée  │              │<br />│  └─────────────┘                           └─────────────┘              │<br />│                                                                         │<br />└─────────────────────────────────────────────────────────────────────────┘<br />LÉGENDE:<br />→ Dépendance principale<br />⟶ Dépendance secondaire</p>
</section>
</section>
<section id="migration-progressive">
<h3>3.2.2 Migration Progressive<a class="headerlink" href="#migration-progressive" title="Link to this heading"></a></h3>
<section id="id4">
<h4>Workflows à Développer<a class="headerlink" href="#id4" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-MIGRATION-TEMPLATE-GENERATOR</p>
<ul class="simple">
<li><p>Objectif: Générer des templates de workflows pour la migration des fonctionnalités</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
<li><p>Copy</p></li>
</ol>
<p>{<br />”name”: “WF-MIGRATION-TEMPLATE-GENERATOR”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “functionalityId”,<br />”value”: “==$input.item.json.functionalityId || ‘email_generation’”<br />},<br />{<br />”name”: “targetPillar”,<br />”value”: “==$input.item.json.targetPillar || ‘PILIER_3’”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Entrée”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “reports/functionality_mapping.md”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Charger Cartographie”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Extraire les informations de la fonctionnalité\nconst reportContent = $binary.data.toString();\nconst functionalityId = $input.item.json.functionalityId;\nconst targetPillar = $input.item.json.targetPillar;\n\n// Extraire les informations du tableau\nconst tableRegex = /\\| ([^|]+) \\| ([^|]+) \\| ([^|]+) \\| ([^|]+) \\| ([^|]+) \\| ([^|]+) \\| ([^|]+) \\| ([^|]+) \\|/g;\nlet match;\nlet functionality = null;\n\nwhile ((match = tableRegex.exec(reportContent)) !== null) {\n  const name = match[1].trim();\n  if (name === ‘Fonctionnalité’) continue; // Skip header\n  \n  // Vérifier si c’est la fonctionnalité recherchée\n  if (name.toLowerCase().includes(functionalityId)) {\n    functionality = {\n      name,\n      description: match[2].trim(),\n      currentLocation: match[3].trim(),\n      dependencies: match[4].trim().split(’, ‘).map(d =&gt; d.trim()),\n      targetPillar: match[5].trim(),\n      secondaryPillars: match[6].trim(),\n      complexity: match[7].trim(),\n      priority: match[8].trim()\n    };\n    break;\n  }\n}\n\nif (!functionality) {\n  throw new Error(`Fonctionnalité ‘${functionalityId}’ non trouvée dans le rapport`);\n}\n\n// Vérifier si le pilier cible correspond\nif (functionality.targetPillar !== targetPillar) {\n  console.log(`Attention: Le pilier cible spécifié (${targetPillar}) ne correspond pas au pilier dans la cartographie (${functionality.targetPillar})`);\n}\n\nreturn {\n  json: functionality\n};”<br />},<br />”name”: “Extraire Fonctionnalité”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer un template de workflow pour la migration\nconst functionality = $input.item.json;\nconst targetPillar = functionality.targetPillar;\n\n// Normaliser le nom pour l’utiliser comme identifiant\nconst normalizedName = functionality.name\n  .toLowerCase()\n  .replace(/[^a-z0-9]+/g, ‘_’)\n  .replace(/^_|_$/g, ‘’);\n\n// Créer un template de workflow basé sur le pilier cible\nlet workflowTemplate;\n\nswitch (targetPillar) {\n  case ‘PILIER_1’:\n    workflowTemplate = generatePilier1Template(functionality, normalizedName);\n    break;\n  case ‘PILIER_2’:\n    workflowTemplate = generatePilier2Template(functionality, normalizedName);\n    break;\n  case ‘PILIER_3’:\n    workflowTemplate = generatePilier3Template(functionality, normalizedName);\n    break;\n  case ‘PILIER_4’:\n    workflowTemplate = generatePilier4Template(functionality, normalizedName);\n    break;\n  default:\n    workflowTemplate = generateGenericTemplate(functionality, normalizedName);\n}\n\n// Fonction pour générer un template pour le Pilier 1 (Données Stratégiques)\nfunction generatePilier1Template(functionality, normalizedName) {\n  return {\n    name: `P1_${normalizedName}`,\n    nodes: [\n      {\n        parameters: {\n          triggerTimes: {\n            item: [\n              {\n                mode: \”manual\”\n              }\n            ]\n          }\n        },\n        name: \”Déclencheur Manuel\”,\n        type: \”n8n-nodes-base.manualTrigger\”,\n        position: [100, 300]\n      },\n      {\n        parameters: {\n          url: \”http://localhost:5678/webhook/core-config\”,\n          options: {}\n        },\n        name: \”Charger Configuration\”,\n        type: \”n8n-nodes-base.httpRequest\”,\n        position: [300, 300]\n      },\n      {\n        parameters: {\n          authentication: \”notionApi\”,\n          operation: \”getDatabases\”,\n          returnAll: true\n        },\n        name: \”Notion\”,\n        type: \”n8n-nodes-base.notion\”,\n        position: [500, 300]\n      },\n      {\n        parameters: {\n          functionCode: `// Code spécifique à ${functionality.name}\\nreturn $input.item;`\n        },\n        name: \”Traitement Données\”,\n        type: \”n8n-nodes-base.function\”,\n        position: [700, 300]\n      }\n    ],\n    connections: {\n      \”Déclencheur Manuel\”: {\n        main: [\n          [\n            {\n              node: \”Charger Configuration\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Charger Configuration\”: {\n        main: [\n          [\n            {\n              node: \”Notion\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Notion\”: {\n        main: [\n          [\n            {\n              node: \”Traitement Données\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      }\n    }\n  };\n}\n\n// Fonction pour générer un template pour le Pilier 2 (Processus Automatisés)\nfunction generatePilier2Template(functionality, normalizedName) {\n  return {\n    name: `P2_${normalizedName}`,\n    nodes: [\n      {\n        parameters: {\n          triggerTimes: {\n            item: [\n              {\n                mode: \”manual\”\n              }\n            ]\n          }\n        },\n        name: \”Déclencheur Manuel\”,\n        type: \”n8n-nodes-base.manualTrigger\”,\n        position: [100, 300]\n      },\n      {\n        parameters: {\n          url: \”http://localhost:5678/webhook/core-config\”,\n          options: {}\n        },\n        name: \”Charger Configuration\”,\n        type: \”n8n-nodes-base.httpRequest\”,\n        position: [300, 300]\n      },\n      {\n        parameters: {\n          functionCode: `// Code spécifique à ${functionality.name}\\nreturn $input.item;`\n        },\n        name: \”Logique Métier\”,\n        type: \”n8n-nodes-base.function\”,\n        position: [500, 300]\n      },\n      {\n        parameters: {\n          conditions: {\n            string: [\n              {\n                value1: \”={{$json.success}}\”,\n                operation: \”equal\”,\n                value2: \”true\”\n              }\n            ]\n          }\n        },\n        name: \”Vérifier Résultat\”,\n        type: \”n8n-nodes-base.if\”,\n        position: [700, 300]\n      },\n      {\n        parameters: {\n          values: {\n            string: [\n              {\n                name: \”status\”,\n                value: \”success\”\n              }\n            ]\n          }\n        },\n        name: \”Succès\”,\n        type: \”n8n-nodes-base.set\”,\n        position: [900, 200]\n      },\n      {\n        parameters: {\n          values: {\n            string: [\n              {\n                name: \”status\”,\n                value: \”error\”\n              }\n            ]\n          }\n        },\n        name: \”Erreur\”,\n        type: \”n8n-nodes-base.set\”,\n        position: [900, 400]\n      }\n    ],\n    connections: {\n      \”Déclencheur Manuel\”: {\n        main: [\n          [\n            {\n              node: \”Charger Configuration\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Charger Configuration\”: {\n        main: [\n          [\n            {\n              node: \”Logique Métier\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Logique Métier\”: {\n        main: [\n          [\n            {\n              node: \”Vérifier Résultat\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Vérifier Résultat\”: {\n        main: [\n          [\n            {\n              node: \”Succès\”,\n              type: \”main\”,\n              index: 0\n            }\n          ],\n          [\n            {\n              node: \”Erreur\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      }\n    }\n  };\n}\n\n// Fonction pour générer un template pour le Pilier 3 (Intelligence Augmentée)\nfunction generatePilier3Template(functionality, normalizedName) {\n  return {\n    name: `P3_${normalizedName}`,\n    nodes: [\n      {\n        parameters: {\n          triggerTimes: {\n            item: [\n              {\n                mode: \”manual\”\n              }\n            ]\n          }\n        },\n        name: \”Déclencheur Manuel\”,\n        type: \”n8n-nodes-base.manualTrigger\”,\n        position: [100, 300]\n      },\n      {\n        parameters: {\n          url: \”http://localhost:5678/webhook/core-config\”,\n          options: {}\n        },\n        name: \”Charger Configuration\”,\n        type: \”n8n-nodes-base.httpRequest\”,\n        position: [300, 300]\n      },\n      {\n        parameters: {\n          functionCode: `// Préparation des données pour l’IA\\nreturn $input.item;`\n        },\n        name: \”Préparer Données\”,\n        type: \”n8n-nodes-base.function\”,\n        position: [500, 300]\n      },\n      {\n        parameters: {\n          authentication: \”genericCredentialType\”,\n          url: \”https://openrouter.ai/api/v1/chat/completions\”,\n          options: {\n            bodyContentType: \”json\”,\n            body: {\n              model: \”deepseek-ai/deepseek-v3\”,\n              messages: [\n                {\n                  role: \”system\”,\n                  content: `Vous êtes un assistant spécialisé dans ${functionality.description}`\n                },\n                {\n                  role: \”user\”,\n                  content: \”={{$json.prompt}}\”\n                }\n              ]\n            }\n          }\n        },\n        name: \”Appel IA\”,\n        type: \”n8n-nodes-base.httpRequest\”,\n        position: [700, 300]\n      },\n      {\n        parameters: {\n          functionCode: `// Traitement de la réponse de l’IA\\nconst response = $json.choices[0].message.content;\\nreturn {\\n  json: {\\n    aiResponse: response,\\n    processedResult: response.trim()\\n  }\\n};`\n        },\n        name: \”Traiter Réponse IA\”,\n        type: \”n8n-nodes-base.function\”,\n        position: [900, 300]\n      }\n    ],\n    connections: {\n      \”Déclencheur Manuel\”: {\n        main: [\n          [\n            {\n              node: \”Charger Configuration\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Charger Configuration\”: {\n        main: [\n          [\n            {\n              node: \”Préparer Données\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Préparer Données\”: {\n        main: [\n          [\n            {\n              node: \”Appel IA\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Appel IA\”: {\n        main: [\n          [\n            {\n              node: \”Traiter Réponse IA\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      }\n    }\n  };\n}\n\n// Fonction pour générer un template pour le Pilier 4 (Interfaces Utilisateur)\nfunction generatePilier4Template(functionality, normalizedName) {\n  return {\n    name: `P4_${normalizedName}`,\n    nodes: [\n      {\n        parameters: {\n          path: `api/${normalizedName}`,\n          responseMode: \”onReceived\”,\n          options: {}\n        },\n        name: \”Webhook API\”,\n        type: \”n8n-nodes-base.webhook\”,\n        position: [100, 300]\n      },\n      {\n        parameters: {\n          functionCode: `// Validation des paramètres d’entrée\\nconst input = $input.item.json;\\n\\n// Vérifier les paramètres requis\\nconst requiredParams = [’param1’, ‘param2’];\\nconst missingParams = requiredParams.filter(param =&gt; !input[param]);\\n\\nif (missingParams.length &gt; 0) {\\n  return {\\n    json: {\\n      success: false,\\n      error: \\`Paramètres manquants: \\${missingParams.join(’, ‘)}\\`\\n    }\\n  };\\n}\\n\\nreturn {\\n  json: {\\n    …input,\\n    validated: true\\n  }\\n};`\n        },\n        name: \”Valider Requête\”,\n        type: \”n8n-nodes-base.function\”,\n        position: [300, 300]\n      },\n      {\n        parameters: {\n          conditions: {\n            string: [\n              {\n                value1: \”={{$json.validated}}\”,\n                operation: \”equal\”,\n                value2: \”true\”\n              }\n            ]\n          }\n        },\n        name: \”Requête Valide?\”,\n        type: \”n8n-nodes-base.if\”,\n        position: [500, 300]\n      },\n      {\n        parameters: {\n          url: \”http://localhost:5678/webhook/core-config\”,\n          options: {}\n        },\n        name: \”Charger Configuration\”,\n        type: \”n8n-nodes-base.httpRequest\”,\n        position: [700, 200]\n      },\n      {\n        parameters: {\n          values: {\n            string: [\n              {\n                name: \”success\”,\n                value: \”false\”\n              },\n              {\n                name: \”message\”,\n                value: \”={{$json.error}}\”\n              }\n            ],\n            object: [\n              {\n                name: \”error\”,\n                value: {\n                  code: \”VALIDATION_ERROR\”,\n                  details: \”={{$json.error}}\”\n                }\n              }\n            ]\n          }\n        },\n        name: \”Erreur Validation\”,\n        type: \”n8n-nodes-base.set\”,\n        position: [700, 400]\n      },\n      {\n        parameters: {\n          functionCode: `// Logique métier spécifique à ${functionality.name}\\nreturn {\\n  json: {\\n    success: true,\\n    data: {\\n      result: ‘Exemple de résultat’,\\n      timestamp: new Date().toISOString()\\n    }\\n  }\\n};`\n        },\n        name: \”Logique Métier\”,\n        type: \”n8n-nodes-base.function\”,\n        position: [900, 200]\n      }\n    ],\n    connections: {\n      \”Webhook API\”: {\n        main: [\n          [\n            {\n              node: \”Valider Requête\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Valider Requête\”: {\n        main: [\n          [\n            {\n              node: \”Requête Valide?\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Requête Valide?\”: {\n        main: [\n          [\n            {\n              node: \”Charger Configuration\”,\n              type: \”main\”,\n              index: 0\n            }\n          ],\n          [\n            {\n              node: \”Erreur Validation\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      },\n      \”Charger Configuration\”: {\n        main: [\n          [\n            {\n              node: \”Logique Métier\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      }\n    }\n  };\n}\n\n// Fonction pour générer un template générique\nfunction generateGenericTemplate(functionality, normalizedName) {\n  return {\n    name: `Generic_${normalizedName}`,\n    nodes: [\n      {\n        parameters: {\n          triggerTimes: {\n            item: [\n              {\n                mode: \”manual\”\n              }\n            ]\n          }\n        },\n        name: \”Déclencheur Manuel\”,\n        type: \”n8n-nodes-base.manualTrigger\”,\n        position: [100, 300]\n      },\n      {\n        parameters: {\n          functionCode: `// Code spécifique à ${functionality.name}\\nreturn $input.item;`\n        },\n        name: \”Logique Principale\”,\n        type: \”n8n-nodes-base.function\”,\n        position: [300, 300]\n      }\n    ],\n    connections: {\n      \”Déclencheur Manuel\”: {\n        main: [\n          [\n            {\n              node: \”Logique Principale\”,\n              type: \”main\”,\n              index: 0\n            }\n          ]\n        ]\n      }\n    }\n  };\n}\n\n// Convertir en JSON formaté\nconst workflowJson = JSON.stringify(workflowTemplate, null, 2);\n\nreturn {\n  json: {\n    functionality: functionality.name,\n    targetPillar,\n    workflowName: workflowTemplate.name\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(workflowJson).toString(’base64’),\n      fileName: `${workflowTemplate.name}.json`\n    }\n  }\n};”<br />},<br />”name”: “Générer Template Workflow”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “templates/{{$json.workflowName}}.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Template”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer un guide de migration\nconst functionality = $input.item.json.functionality;\nconst targetPillar = $input.item.json.targetPillar;\nconst workflowName = $input.item.json.workflowName;\n\n// Créer le contenu Markdown\nlet markdownContent = `# Guide de Migration : ${functionality}\n\n## Vue d’ensemble\n\nCe document fournit les instructions pour migrer la fonctionnalité \”${functionality}\” vers le pilier ${targetPillar} du Plan Magistral V5.\n\n## Étapes de Migration\n\n1. **Préparation**\n   - Créer un nouveau workflow basé sur le template `${workflowName}.json`\n   - Vérifier que toutes les dépendances sont disponibles\n   - Configurer les credentials nécessaires\n\n2. **Adaptation du Code**\n   - Localiser les sections marquées avec des commentaires `// Code spécifique à…`\n   - Adapter le code existant pour l’intégrer dans la nouvelle structure\n   - Mettre à jour les références aux autres workflows/piliers\n\n3. **Tests**\n   - Tester le workflow en isolation\n   - Vérifier les interactions avec les autres piliers\n   - Valider que toutes les fonctionnalités sont correctement migrées\n\n4. **Déploiement**\n   - Activer le nouveau workflow\n   - Désactiver l’ancien workflow après validation\n   - Mettre à jour la documentation\n\n## Points d’Attention\n\n- Vérifier que les formats de données sont compatibles avec le Plan Magistral V5\n- S’assurer que les webhooks et points d’intégration sont correctement configurés\n- Mettre à jour les références dans les autres workflows\n\n## Validation\n\nPour valider la migration, vérifier que :\n\n- Le workflow fonctionne correctement en isolation\n- Les interactions avec les autres piliers sont fonctionnelles\n- Les performances sont au moins équivalentes à l’ancienne implémentation\n- Tous les cas d’utilisation sont couverts\n\n## Rollback\n\nEn cas de problème, suivre ces étapes pour revenir à l’ancienne implémentation :\n\n1. Désactiver le nouveau workflow\n2. Réactiver l’ancien workflow\n3. Documenter les problèmes rencontrés pour une future tentative\n`;\n\nreturn {\n  json: {\n    markdownContent\n  },\n  binary: {\n    data: {\n      mimeType: ‘text/markdown’,\n      data: Buffer.from(markdownContent).toString(’base64’),\n      fileName: `migration_guide_${workflowName}.md`\n    }\n  }\n};”<br />},<br />”name”: “Générer Guide Migration”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1100, 500]<br />},<br />{<br />”parameters”: {<br />”path”: “guides/migration_guide_{{$json.workflowName}}.md”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Guide”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1300, 500]<br />}</p>
<p>2.WF-MIGRATION-TESTER</p>
<ul class="simple">
<li><p>Objectif: Tester les fonctionnalités migrées pour s’assurer qu’elles fonctionnent correctement</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>{<br />”name”: “WF-MIGRATION-TESTER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “workflowName”,<br />”value”: “==$input.item.json.workflowName || ‘P3_email_generation’”<br />}<br />],<br />”object”: [<br />{<br />”name”: “testData”,<br />”value”: “==$input.item.json.testData || {}”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Test”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”url”: “=http://localhost:5678/rest/workflows?filter={{$json.workflowName}}”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”options”: {}<br />},<br />”name”: “Vérifier Workflow”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”number”: [<br />{<br />”value1”: “={{$json.data.length}}”,<br />”operation”: “equal”,<br />”value2”: 0<br />}<br />]<br />}<br />},<br />”name”: “Workflow Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “error”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Le workflow {{$json.workflowName}} n’existe pas”<br />}<br />]<br />}<br />},<br />”name”: “Erreur Workflow”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Préparer l’exécution du workflow\nconst workflowData = $json.data[0];\nconst workflowId = workflowData.id;\nconst testData = $input.item.json.testData || {};\n\n// Créer la requête d’exécution\nreturn {\n  json: {\n    workflowId,\n    workflowName: workflowData.name,\n    testData\n  }\n};”<br />},<br />”name”: “Préparer Exécution”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 400]<br />},<br />{<br />”parameters”: {<br />”url”: “=http://localhost:5678/rest/workflows/{{$json.workflowId}}/execute”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”sendBody”: true,<br />”bodyParameters”: {<br />”parameters”: [<br />{<br />”name”: “data”,<br />”value”: “={{$json.testData}}”<br />}<br />]<br />},<br />”options”: {}<br />},<br />”name”: “Exécuter Workflow”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [1100, 400]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.statusCode}}”,<br />”operation”: “startsWith”,<br />”value2”: “2”<br />}<br />]<br />}<br />},<br />”name”: “Exécution Réussie?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1300, 400]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “success”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Test du workflow {{$json.workflowName}} réussi”<br />}<br />],<br />”object”: [<br />{<br />”name”: “result”,<br />”value”: “={{$json.data}}”<br />}<br />]<br />}<br />},<br />”name”: “Test Réussi”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1500, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “error”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Erreur lors du test du workflow {{$json.workflowName}}: {{$json.statusCode}} - {{$json.statusMessage}}”<br />}<br />],<br />”object”: [<br />{<br />”name”: “error”,<br />”value”: “={{$json}}”<br />}<br />]<br />}<br />},<br />”name”: “Test Échoué”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [1500, 500]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer un rapport de test\nconst status = $input.item.json.status;\nconst message = $input.item.json.message;\nconst workflowName = $input.item.json.workflowName;\nconst result = $input.item.json.result || $input.item.json.error || {};\n\n// Créer le contenu Markdown\nlet markdownContent = `# Rapport de Test : ${workflowName}\n\n## Résultat\n\n**Statut** : ${status === ‘success’ ? ‘✅ Succès’ : ‘❌ Échec’}\n**Message** : ${message}\n\n## Détails\n\n\\`\\`\\`json\n${JSON.stringify(result, null, 2)}\n\\`\\`\\`\n\n## Horodatage\n\nTest exécuté le ${new Date().toLocaleString(’fr-FR’)}\n`;\n\nreturn {\n  json: {\n    status,\n    message,\n    workflowName,\n    markdownContent\n  },\n  binary: {\n    data: {\n      mimeType: ‘text/markdown’,\n      data: Buffer.from(markdownContent).toString(’base64’),\n      fileName: `test_report_${workflowName}.md`\n    }\n  }\n};”<br />},<br />”name”: “Générer Rapport”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1700, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “reports/tests/test_report_{{$json.workflowName}}.md”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Rapport”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1900, 400]<br />}<br />],<br />”connections”: {<br />”Déclencheur Manuel”: {<br />”main”: [<br />[<br />{<br />”node”: “Configuration Test”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Configuration Test”: {<br />”main”: [<br />[<br />{<br />”node”: “Vérifier Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Vérifier Workflow”: {<br />”main”: [<br />[<br />{<br />”node”: “Workflow Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Workflow Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Erreur Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Préparer Exécution”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Erreur Workflow”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Rapport”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Préparer Exécution”: {<br />”main”: [<br />[<br />{<br />”node”: “Exécuter Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Exécuter Workflow”: {<br />”main”: [<br />[<br />{<br />”node”: “Exécution Réussie?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Exécution Réussie?”: {<br />”main”: [<br />[<br />{<br />”node”: “Test Réussi”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Test Échoué”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Test Réussi”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Rapport”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Test Échoué”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Rapport”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Générer Rapport”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Rapport”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
</section>
</section>
<section id="adaptation-des-interfaces">
<h3>3.2.3 Adaptation des Interfaces<a class="headerlink" href="#adaptation-des-interfaces" title="Link to this heading"></a></h3>
<section id="id5">
<h4>Workflows à Développer<a class="headerlink" href="#id5" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-INTERFACE-ADAPTER</p>
<ul class="simple">
<li><p>Objectif: Adapter les interfaces entre les fonctionnalités migrées pour assurer la compatibilité</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
</ol>
<p>{<br />”name”: “WF-INTERFACE-ADAPTER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “sourceWorkflow”,<br />”value”: “==$input.item.json.sourceWorkflow || ‘P3_email_generation’”<br />},<br />{<br />”name”: “targetWorkflow”,<br />”value”: “==$input.item.json.targetWorkflow || ‘P2_email_sending’”<br />}<br />],<br />”object”: [<br />{<br />”name”: “interfaceSpec”,<br />”value”: “==$input.item.json.interfaceSpec || {}”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Interface”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer un adaptateur d’interface\nconst sourceWorkflow = $input.item.json.sourceWorkflow;\nconst targetWorkflow = $input.item.json.targetWorkflow;\nconst interfaceSpec = $input.item.json.interfaceSpec || {};\n\n// Créer un nom pour l’adaptateur\nconst adapterName = `Interface_${sourceWorkflow}_to_${targetWorkflow}`;\n\n// Créer un template d’adaptateur\nconst adapterTemplate = {\n  name: adapterName,\n  nodes: [\n    {\n      parameters: {\n        path: `interface/${sourceWorkflow.toLowerCase()}-to-${targetWorkflow.toLowerCase()}`,\n        responseMode: \”onReceived\”,\n        options: {}\n      },\n      name: \”Webhook Interface\”,\n      type: \”n8n-nodes-base.webhook\”,\n      position: [100, 300]\n    },\n    {\n      parameters: {\n        functionCode: `// Validation des données d’entrée\\nconst input = $input.item.json;\\n\\n// Vérifier les champs requis\\nconst requiredFields = ${JSON.stringify(interfaceSpec.requiredFields || [’data’])};\\nconst missingFields = requiredFields.filter(field =&gt; !input[field]);\\n\\nif (missingFields.length &gt; 0) {\\n  return {\\n    json: {\\n      success: false,\\n      error: \\`Champs manquants: \\${missingFields.join(’, ‘)}\\`\\n    }\\n  };\\n}\\n\\nreturn {\\n  json: {\\n    …input,\\n    validated: true\\n  }\\n};`\n      },\n      name: \”Valider Données\”,\n      type: \”n8n-nodes-base.function\”,\n      position: [300, 300]\n    },\n    {\n      parameters: {\n        conditions: {\n          string: [\n            {\n              value1: \”={{$json.validated}}\”,\n              operation: \”equal\”,\n              value2: \”true\”\n            }\n          ]\n        }\n      },\n      name: \”Données Valides?\”,\n      type: \”n8n-nodes-base.if\”,\n      position: [500, 300]\n    },\n    {\n      parameters: {\n        functionCode: `// Transformation des données pour le workflow cible\\nconst input = $input.item.json;\\n\\n// Appliquer les transformations spécifiées\\nconst transformedData = {};\\n\\n// Exemple de transformation basée sur interfaceSpec\\n${generateTransformationCode(interfaceSpec)}\\n\\nreturn {\\n  json: transformedData\\n};`\n      },\n      name: \”Transformer Données\”,\n      type: \”n8n-nodes-base.function\”,\n      position: [700, 200]\n    },\n    {\n      parameters: {\n        values: {\n          string: [\n            {\n              name: \”success\”,\n              value: \”false\”\n            },\n            {\n              name: \”message\”,\n              value: \”={{$json.error}}\”\n            }\n          ],\n          object: [\n            {\n              name: \”error\”,\n              value: {\n                code: \”VALIDATION_ERROR\”,\n                details: \”={{$json.error}}\”\n              }\n            }\n          ]\n        }\n      },\n      name: \”Erreur Validation\”,\n      type: \”n8n-nodes-base.set\”,\n      position: [700, 400]\n    },\n    {\n      parameters: {\n        url: `http://localhost:5678/webhook/${targetWorkflow.toLowerCase()}`,\n        sendBody: true,\n        bodyParameters: {\n          parameters: [\n            {\n              name: \”data\”,\n              value: \”={{$json}}\”\n            }\n          ]\n        },\n        options: {}\n      },\n      name: \”Appeler Workflow Cible\”,\n      type: \”n8n-nodes-base.httpRequest\”,\n      position: [900, 200]\n    },\n    {\n      parameters: {\n        functionCode: `// Traitement de la réponse du workflow cible\\nconst response = $json;\\n\\n// Formater la réponse finale\\nreturn {\\n  json: {\\n    success: true,\\n    source: ‘${sourceWorkflow}’,\\n    target: ‘${targetWorkflow}’,\\n    result: response\\n  }\\n};`\n      },\n      name: \”Traiter Réponse\”,\n      type: \”n8n-nodes-base.function\”,\n      position: [1100, 200]\n    }\n  ],\n  connections: {\n    \”Webhook Interface\”: {\n      main: [\n        [\n          {\n            node: \”Valider Données\”,\n            type: \”main\”,\n            index: 0\n          }\n        ]\n      ]\n    },\n    \”Valider Données\”: {\n      main: [\n        [\n          {\n            node: \”Données Valides?\”,\n            type: \”main\”,\n            index: 0\n          }\n        ]\n      ]\n    },\n    \”Données Valides?\”: {\n      main: [\n        [\n          {\n            node: \”Transformer Données\”,\n            type: \”main\”,\n            index: 0\n          }\n        ],\n        [\n          {\n            node: \”Erreur Validation\”,\n            type: \”main\”,\n            index: 0\n          }\n        ]\n      ]\n    },\n    \”Transformer Données\”: {\n      main: [\n        [\n          {\n            node: \”Appeler Workflow Cible\”,\n            type: \”main\”,\n            index: 0\n          }\n        ]\n      ]\n    },\n    \”Appeler Workflow Cible\”: {\n      main: [\n        [\n          {\n            node: \”Traiter Réponse\”,\n            type: \”main\”,\n            index: 0\n          }\n        ]\n      ]\n    }\n  }\n};\n\n// Fonction pour générer le code de transformation\nfunction generateTransformationCode(spec) {\n  const mappings = spec.fieldMappings || [];\n  let code = ‘’;\n  \n  if (mappings.length === 0) {\n    code = `// Aucune transformation spécifiée - copier toutes les données\\nObject.assign(transformedData, input);`;\n  } else {\n    code = ‘// Appliquer les transformations de champs\\n’;\n    mappings.forEach(mapping =&gt; {\n      if (mapping.transform) {\n        code += `transformedData[’${mapping.target}’] = ${mapping.transform.replace(’$source’, `input[’${mapping.source}’]`)}\\n`;\n      } else {\n        code += `transformedData[’${mapping.target}’] = input[’${mapping.source}’];\\n`;\n      }\n    });\n  }\n  \n  return code;\n}\n\n// Convertir en JSON formaté\nconst adapterJson = JSON.stringify(adapterTemplate, null, 2);\n\nreturn {\n  json: {\n    sourceWorkflow,\n    targetWorkflow,\n    adapterName\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(adapterJson).toString(’base64’),\n      fileName: `${adapterName}.json`\n    }\n  }\n};”<br />},<br />”name”: “Générer Adaptateur”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “templates/interfaces/{{$json.adapterName}}.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Adaptateur”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer un guide d’interface\nconst sourceWorkflow = $input.item.json.sourceWorkflow;\nconst targetWorkflow = $input.item.json.targetWorkflow;\nconst adapterName = $input.item.json.adapterName;\nconst interfaceSpec = $input.item.json.interfaceSpec || {};\n\n// Créer le contenu Markdown\nlet markdownContent = `# Guide d’Interface : ${sourceWorkflow} → ${targetWorkflow}\n\n## Vue d’ensemble\n\nCe document décrit l’interface entre les workflows ${sourceWorkflow} et ${targetWorkflow}, et explique comment utiliser l’adaptateur ${adapterName}.\n\n## Spécification de l’Interface\n\n### Données d’Entrée (${sourceWorkflow})\n\n`;\n\n// Ajouter les champs requis\nconst requiredFields = interfaceSpec.requiredFields || [’data’];\nmarkdownContent += `**Champs Requis :**\\n\\n`;\nrequiredFields.forEach(field =&gt; {\n  markdownContent += `- \\`${field}\\`\\n`;\n});\n\n// Ajouter les mappings de champs\nmarkdownContent += `\\n### Mappings de Champs\\n\\n`;\nconst mappings = interfaceSpec.fieldMappings || [];\n\nif (mappings.length === 0) {\n  markdownContent += `Aucun mapping spécifique - toutes les données sont transmises telles quelles.\\n`;\n} else {\n  markdownContent += `| Champ Source | Champ Cible | Transformation |\\n|————-|————|—————-|\\n`;\n  mappings.forEach(mapping =&gt; {\n    markdownContent += `| \\`${mapping.source}\\` | \\`${mapping.target}\\` | ${mapping.transform ? mapping.transform.replace(’$source’, ‘valeur source’) : ‘Aucune’} |\\n`;\n  });\n}\n\n// Ajouter des exemples\nmarkdownContent += `\\n## Exemples\\n\\n### Exemple de Requête\\n\\n\\`\\`\\`json\\n${JSON.stringify(generateExampleRequest(interfaceSpec), null, 2)}\\n\\`\\`\\`\\n\\n### Exemple de Réponse\\n\\n\\`\\`\\`json\\n${JSON.stringify(generateExampleResponse(), null, 2)}\\n\\`\\`\\`\\n\\n## Utilisation\\n\\nPour utiliser cet adaptateur d’interface :\\n\\n1. Déployer le workflow ${adapterName}\\n2. Configurer ${sourceWorkflow} pour envoyer ses données à l’URL de webhook de l’adaptateur\\n3. Vérifier que ${targetWorkflow} est correctement configuré pour recevoir les données transformées\\n\\n## Dépannage\\n\\nEn cas de problème :\\n\\n- Vérifier que tous les champs requis sont présents dans les données d’entrée\\n- S’assurer que les deux workflows sont actifs\\n- Consulter les logs d’exécution pour identifier les erreurs potentielles\\n`;\n\n// Fonction pour générer un exemple de requête\nfunction generateExampleRequest(spec) {\n  const example = {};\n  const requiredFields = spec.requiredFields || [’data’];\n  \n  requiredFields.forEach(field =&gt; {\n    example[field] = field === ‘data’ ? { example: ‘value’ } : `example_${field}`;\n  });\n  \n  return example;\n}\n\n// Fonction pour générer un exemple de réponse\nfunction generateExampleResponse() {\n  return {\n    success: true,\n    source: sourceWorkflow,\n    target: targetWorkflow,\n    result: {\n      status: ‘success’,\n      message: ‘Opération réussie’,\n      data: {\n        id: ‘12345’,\n        timestamp: new Date().toISOString()\n      }\n    }\n  };\n}\n\nreturn {\n  json: {\n    sourceWorkflow,\n    targetWorkflow,\n    adapterName\n  },\n  binary: {\n    data: {\n      mimeType: ‘text/markdown’,\n      data: Buffer.from(markdownContent).toString(’base64’),\n      fileName: `interface_guide_${sourceWorkflow}_to_${targetWorkflow}.md`\n    }\n  }\n};”<br />},<br />”name”: “Générer Guide Interface”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 500]<br />},<br />{<br />”parameters”: {<br />”path”: “guides/interfaces/interface_guide_{{$json.sourceWorkflow}}_to_{{$json.targetWorkflow}}.md”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Guide”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [900, 500]<br />}<br />],<br />”connections”: {<br />”Déclencheur Manuel”: {<br />”main”: [<br />[<br />{<br />”node”: “Configuration Interface”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Configuration Interface”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Adaptateur”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Générer Adaptateur”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Adaptateur”,<br />”type”: “main”,<br />”index”: 0<br />},<br />{<br />”node”: “Générer Guide Interface”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Générer Guide Interface”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Guide”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
</section>
</section>
</section>
<section id="etape-3-3-mise-en-place-du-systeme-de-monitoring">
<h2>Étape 3.3: Mise en Place du Système de Monitoring<a class="headerlink" href="#etape-3-3-mise-en-place-du-systeme-de-monitoring" title="Link to this heading"></a></h2>
<section id="configuration-des-alertes">
<h3>3.3.1 Configuration des Alertes<a class="headerlink" href="#configuration-des-alertes" title="Link to this heading"></a></h3>
<section id="id6">
<h4>Workflows à Développer<a class="headerlink" href="#id6" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-MONITORING-ALERT-MANAGER</p>
<ul class="simple">
<li><p>Objectif: Configurer et gérer les alertes pour le système de monitoring</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
<li><p>Copy</p></li>
</ol>
<p>{<br />”name”: “WF-MONITORING-ALERT-MANAGER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”triggerTimes”: {<br />”item”: [<br />{<br />”mode”: “manual”<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Manuel”,<br />”type”: “n8n-nodes-base.manualTrigger”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “action”,<br />”value”: “==$input.item.json.action || ‘configure’”<br />},<br />{<br />”name”: “alertName”,<br />”value”: “==$input.item.json.alertName || ‘workflow_error’”<br />}<br />],<br />”object”: [<br />{<br />”name”: “alertConfig”,<br />”value”: “==$input.item.json.alertConfig || {}”<br />}<br />]<br />}<br />},<br />”name”: “Configuration Entrée”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.action}}”,<br />”operation”: “equal”,<br />”value2”: “configure”<br />}<br />]<br />}<br />},<br />”name”: “Action?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Configurer une alerte\nconst alertName = $input.item.json.alertName;\nconst alertConfig = $input.item.json.alertConfig || {};\n\n// Valeurs par défaut pour la configuration\nconst defaultConfig = {\n  enabled: true,\n  severity: ‘medium’,\n  channels: [’email’],\n  recipients: [],\n  thresholds: {\n    critical: 0.9,\n    warning: 0.7\n  },\n  cooldownMinutes: 30,\n  description: `Alerte ${alertName}`,\n  template: {\n    subject: `[ALERTE] {{severity}} - {{alertName}}`,\n    body: `Une alerte {{severity}} a été déclenchée pour {{alertName}}\\n\\nDétails: {{details}}\\n\\nHorodatage: {{timestamp}}`\n  }\n};\n\n// Fusionner avec la configuration fournie\nconst mergedConfig = {\n  …defaultConfig,\n  …alertConfig,\n  // Fusionner les sous-objets\n  thresholds: {\n    …defaultConfig.thresholds,\n    …(alertConfig.thresholds || {})\n  },\n  template: {\n    …defaultConfig.template,\n    …(alertConfig.template || {})\n  }\n};\n\n// Ajouter des métadonnées\nmergedConfig.metadata = {\n  createdAt: new Date().toISOString(),\n  updatedAt: new Date().toISOString(),\n  alertName\n};\n\n// Convertir en JSON formaté\nconst configJson = JSON.stringify(mergedConfig, null, 2);\n\nreturn {\n  json: {\n    alertName,\n    action: ‘configure’,\n    config: mergedConfig\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(configJson).toString(’base64’),\n      fileName: `alert_${alertName}.json`\n    }\n  }\n};”<br />},<br />”name”: “Configurer Alerte”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Lister les alertes configurées\nconst fs = require(’fs’);\nconst path = require(’path’);\n\n// Chemin du dossier des alertes\nconst alertsDir = ‘configs/alerts’;\n\n// Vérifier si le dossier existe\nif (!fs.existsSync(alertsDir)) {\n  fs.mkdirSync(alertsDir, { recursive: true });\n}\n\n// Lire les fichiers d’alerte\nconst alertFiles = fs.readdirSync(alertsDir)\n  .filter(file =&gt; file.startsWith(’alert_’) &amp;&amp; file.endsWith(’.json’));\n\n// Charger les configurations d’alerte\nconst alerts = [];\n\nalertFiles.forEach(file =&gt; {\n  try {\n    const filePath = path.join(alertsDir, file);\n    const fileContent = fs.readFileSync(filePath, ‘utf8’);\n    const alertConfig = JSON.parse(fileContent);\n    const alertName = file.replace(/^alert_/, ‘’).replace(/\\.json$/, ‘’);\n    \n    alerts.push({\n      name: alertName,\n      enabled: alertConfig.enabled,\n      severity: alertConfig.severity,\n      channels: alertConfig.channels,\n      description: alertConfig.description,\n      lastUpdated: alertConfig.metadata?.updatedAt || ‘Unknown’\n    });\n  } catch (error) {\n    console.error(`Erreur lors de la lecture du fichier ${file}: ${error.message}`);\n  }\n});\n\nreturn {\n  json: {\n    action: ‘list’,\n    count: alerts.length,\n    alerts\n  }\n};”<br />},<br />”name”: “Lister Alertes”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/alerts/alert_{{$json.alertName}}.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Config Alerte”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer un guide de configuration des alertes\nconst alertName = $input.item.json.alertName;\nconst config = $input.item.json.config;\n\n// Créer le contenu Markdown\nlet markdownContent = `# Guide de Configuration d’Alerte : ${alertName}\n\n## Vue d’ensemble\n\nCe document décrit la configuration de l’alerte \”${alertName}\” et explique comment la personnaliser.\n\n## Configuration Actuelle\n\n\\`\\`\\`json\n${JSON.stringify(config, null, 2)}\n\\`\\`\\`\n\n## Paramètres\n\n| Paramètre | Description | Valeur Actuelle |\n|———–|————-|—————-|\n| enabled | Active ou désactive l’alerte | ${config.enabled ? ‘Activé’ : ‘Désactivé’} |\n| severity | Niveau de sévérité de l’alerte | ${config.severity} |\n| channels | Canaux de notification | ${config.channels.join(’, ‘)} |\n| recipients | Destinataires des notifications | ${config.recipients.length &gt; 0 ? config.recipients.join(’, ‘) : ‘Aucun’} |\n| thresholds.critical | Seuil critique | ${config.thresholds.critical} |\n| thresholds.warning | Seuil d’avertissement | ${config.thresholds.warning} |\n| cooldownMinutes | Période de silence entre les alertes (minutes) | ${config.cooldownMinutes} |\n\n## Personnalisation des Templates\n\n### Sujet\n\n\\`${config.template.subject}\\`\n\n### Corps\n\n\\`\\`\\`\n${config.template.body}\n\\`\\`\\`\n\n## Variables Disponibles\n\nLes variables suivantes peuvent être utilisées dans les templates :\n\n- \\`{{alertName}}\\` - Nom de l’alerte\n- \\`{{severity}}\\` - Niveau de sévérité\n- \\`{{details}}\\` - Détails de l’alerte\n- \\`{{timestamp}}\\` - Horodatage du déclenchement\n- \\`{{value}}\\` - Valeur qui a déclenché l’alerte (si applicable)\n- \\`{{threshold}}\\` - Seuil dépassé (si applicable)\n\n## Exemple d’Utilisation\n\nPour déclencher cette alerte depuis un workflow :\n\n\\`\\`\\`javascript\n// Dans un nœud Function\nreturn {\n  json: {\n    alertName: ‘${alertName}’,\n    severity: ‘critical’, // ou ‘warning’\n    details: ‘Description du problème’,\n    value: 0.95, // valeur qui a déclenché l’alerte (si applicable)\n    additionalData: {\n      // Données supplémentaires spécifiques à l’alerte\n    }\n  }\n};\n\\`\\`\\`\n\nPuis appeler le webhook de WF-MONITORING-ALERT-TRIGGER avec ces données.\n`;\n\nreturn {\n  json: {\n    alertName,\n    markdownContent\n  },\n  binary: {\n    data: {\n      mimeType: ‘text/markdown’,\n      data: Buffer.from(markdownContent).toString(’base64’),\n      fileName: `alert_guide_${alertName}.md`\n    }\n  }\n};”<br />},<br />”name”: “Générer Guide Alerte”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “guides/alerts/alert_guide_{{$json.alertName}}.md”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Guide”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1100, 400]<br />}<br />],<br />”connections”: {<br />”Déclencheur Manuel”: {<br />”main”: [<br />[<br />{<br />”node”: “Configuration Entrée”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Configuration Entrée”: {<br />”main”: [<br />[<br />{<br />”node”: “Action?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Action?”: {<br />”main”: [<br />[<br />{<br />”node”: “Configurer Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Lister Alertes”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Configurer Alerte”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Config Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Sauvegarder Config Alerte”: {<br />”main”: [<br />[<br />{<br />”node”: “Générer Guide Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Générer Guide Alerte”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Guide”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
<p>2.WF-MONITORING-ALERT-TRIGGER</p>
<ul class="simple">
<li><p>Objectif: Déclencher les alertes configurées en fonction des événements du système</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>Copy<br />{<br />”name”: “WF-MONITORING-ALERT-TRIGGER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”path”: “trigger-alert”,<br />”responseMode”: “onReceived”,<br />”options”: {}<br />},<br />”name”: “Webhook”,<br />”type”: “n8n-nodes-base.webhook”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Validation des paramètres d’entrée\nconst input = $input.item.json;\n\n// Vérifier les paramètres requis\nif (!input.alertName) {\n  return {\n    json: {\n      success: false,\n      error: ‘Le paramètre alertName est requis’\n    }\n  };\n}\n\n// Déterminer la sévérité\nconst severity = input.severity || ‘medium’;\n\n// Retourner les informations pour le chargement de la configuration d’alerte\nreturn {\n  json: {\n    alertName: input.alertName,\n    severity,\n    details: input.details || ‘Aucun détail fourni’,\n    value: input.value,\n    timestamp: new Date().toISOString(),\n    additionalData: input.additionalData || {}\n  }\n};”<br />},<br />”name”: “Valider Alerte”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/alerts/alert_{{$json.alertName}}.json”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Charger Config Alerte”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.errorMessage}}”,<br />”operation”: “exists”<br />}<br />]<br />}<br />},<br />”name”: “Config Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [700, 300]<br />},<br />{<br />”parameters”: {<br />”values”: {<br />”string”: [<br />{<br />”name”: “status”,<br />”value”: “error”<br />},<br />{<br />”name”: “message”,<br />”value”: “=Configuration d’alerte non trouvée pour {{$json.alertName}}”<br />}<br />]<br />}<br />},<br />”name”: “Config Non Trouvée”,<br />”type”: “n8n-nodes-base.set”,<br />”position”: [900, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Traiter la configuration d’alerte\nconst alertData = $input.item.json;\nconst configData = $binary.data.toString();\n\n// Parser la configuration\nlet alertConfig;\ntry {\n  alertConfig = JSON.parse(configData);\n} catch (error) {\n  return {\n    json: {\n      status: ‘error’,\n      message: ‘Erreur de parsing de la configuration d\\’alerte’,\n      error: error.message\n    }\n  };\n}\n\n// Vérifier si l’alerte est activée\nif (!alertConfig.enabled) {\n  return {\n    json: {\n      status: ‘skipped’,\n      message: ‘Alerte désactivée’,\n      alertName: alertData.alertName\n    }\n  };\n}\n\n// Vérifier le cooldown\nconst lastTriggered = alertConfig.lastTriggered ? new Date(alertConfig.lastTriggered) : null;\nconst now = new Date();\nconst cooldownMinutes = alertConfig.cooldownMinutes || 30;\n\nif (lastTriggered &amp;&amp; ((now - lastTriggered) / 60000) &lt; cooldownMinutes) {\n  return {\n    json: {\n      status: ‘cooldown’,\n      message: `Alerte en période de cooldown (${cooldownMinutes} minutes)`,\n      alertName: alertData.alertName,\n      lastTriggered\n    }\n  };\n}\n\n// Déterminer si le seuil est dépassé (si applicable)\nlet thresholdExceeded = true;\nlet thresholdLevel = null;\n\nif (alertData.value !== undefined &amp;&amp; alertConfig.thresholds) {\n  const value = parseFloat(alertData.value);\n  \n  if (value &gt;= alertConfig.thresholds.critical) {\n    thresholdLevel = ‘critical’;\n  } else if (value &gt;= alertConfig.thresholds.warning) {\n    thresholdLevel = ‘warning’;\n  } else {\n    thresholdExceeded = false;\n  }\n}\n\n// Si le seuil n’est pas dépassé, ne pas déclencher l’alerte\nif (alertData.value !== undefined &amp;&amp; !thresholdExceeded) {\n  return {\n    json: {\n      status: ‘below_threshold’,\n      message: ‘Valeur en dessous des seuils d\\’alerte’,\n      alertName: alertData.alertName,\n      value: alertData.value,\n      thresholds: alertConfig.thresholds\n    }\n  };\n}\n\n// Préparer les données pour les notifications\nconst notificationData = {\n  alertName: alertData.alertName,\n  severity: thresholdLevel || alertData.severity || alertConfig.severity,\n  details: alertData.details,\n  timestamp: alertData.timestamp,\n  value: alertData.value,\n  threshold: thresholdLevel ? alertConfig.thresholds[thresholdLevel] : null,\n  config: alertConfig,\n  additionalData: alertData.additionalData\n};\n\n// Mettre à jour la date de dernier déclenchement\nalertConfig.lastTriggered = now.toISOString();\nalertConfig.metadata.updatedAt = now.toISOString();\n\n// Convertir en JSON formaté pour la mise à jour\nconst updatedConfigJson = JSON.stringify(alertConfig, null, 2);\n\nreturn {\n  json: {\n    status: ‘triggered’,\n    message: ‘Alerte déclenchée’,\n    alertName: alertData.alertName,\n    severity: notificationData.severity,\n    notificationData\n  },\n  binary: {\n    updatedConfig: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(updatedConfigJson).toString(’base64’),\n      fileName: `alert_${alertData.alertName}.json`\n    }\n  }\n};”<br />},<br />”name”: “Traiter Config Alerte”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [900, 400]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.status}}”,<br />”operation”: “equal”,<br />”value2”: “triggered”<br />}<br />]<br />}<br />},<br />”name”: “Alerte Déclenchée?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1100, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/alerts/alert_{{$json.alertName}}.json”,<br />”options”: {}<br />},<br />”name”: “Mettre à Jour Config”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [1300, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Préparer les notifications\nconst notificationData = $input.item.json.notificationData;\nconst config = notificationData.config;\n\n// Déterminer les canaux de notification\nconst channels = config.channels || [’email’];\n\n// Préparer les données pour chaque canal\nconst notifications = [];\n\n// Remplacer les variables dans les templates\nfunction replaceTemplateVars(template, data) {\n  return template\n    .replace(/{{alertName}}/g, data.alertName)\n    .replace(/{{severity}}/g, data.severity)\n    .replace(/{{details}}/g, data.details)\n    .replace(/{{timestamp}}/g, data.timestamp)\n    .replace(/{{value}}/g, data.value !== undefined ? data.value : ‘N/A’)\n    .replace(/{{threshold}}/g, data.threshold !== null ? data.threshold : ‘N/A’);\n}\n\n// Préparer les notifications par canal\nchannels.forEach(channel =&gt; {\n  switch (channel) {\n    case ‘email’:\n      notifications.push({\n        channel: ‘email’,\n        recipients: config.recipients,\n        subject: replaceTemplateVars(config.template.subject, notificationData),\n        body: replaceTemplateVars(config.template.body, notificationData)\n      });\n      break;\n    case ‘slack’:\n      notifications.push({\n        channel: ‘slack’,\n        webhook: config.slackWebhook,\n        message: replaceTemplateVars(config.template.body, notificationData)\n      });\n      break;\n    case ‘telegram’:\n      notifications.push({\n        channel: ‘telegram’,\n        chatId: config.telegramChatId,\n        message: replaceTemplateVars(config.template.body, notificationData)\n      });\n      break;\n    // Ajouter d’autres canaux au besoin\n  }\n});\n\nreturn {\n  json: {\n    alertName: notificationData.alertName,\n    severity: notificationData.severity,\n    notifications\n  }\n};”<br />},<br />”name”: “Préparer Notifications”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1300, 500]<br />},<br />{<br />”parameters”: {<br />”mode”: “combine”,<br />”combinationMode”: “multiplex”,<br />”options”: {}<br />},<br />”name”: “Séparer Notifications”,<br />”type”: “n8n-nodes-base.splitInBatches”,<br />”position”: [1500, 500]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.channel}}”,<br />”operation”: “equal”,<br />”value2”: “email”<br />}<br />]<br />}<br />},<br />”name”: “Canal?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1700, 500]<br />},<br />{<br />”parameters”: {<br />”fromEmail”: “{{$env.ALERT_EMAIL_FROM}}”,<br />”toEmail”: “={{$json.recipients.join(’,’)}}”,<br />”subject”: “={{$json.subject}}”,<br />”text”: “={{$json.body}}”<br />},<br />”name”: “Envoyer Email”,<br />”type”: “n8n-nodes-base.emailSend”,<br />”position”: [1900, 400]<br />},<br />{<br />”parameters”: {<br />”chatId”: “={{$json.chatId}}”,<br />”text”: “={{$json.message}}”,<br />”additionalFields”: {}<br />},<br />”name”: “Envoyer Telegram”,<br />”type”: “n8n-nodes-base.telegram”,<br />”position”: [1900, 600]<br />}<br />],<br />”connections”: {<br />”Webhook”: {<br />”main”: [<br />[<br />{<br />”node”: “Valider Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Valider Alerte”: {<br />”main”: [<br />[<br />{<br />”node”: “Charger Config Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Charger Config Alerte”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Non Trouvée”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Traiter Config Alerte”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Traiter Config Alerte”: {<br />”main”: [<br />[<br />{<br />”node”: “Alerte Déclenchée?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Alerte Déclenchée?”: {<br />”main”: [<br />[<br />{<br />”node”: “Mettre à Jour Config”,<br />”type”: “main”,<br />”index”: 0<br />},<br />{<br />”node”: “Préparer Notifications”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[]<br />]<br />},<br />”Préparer Notifications”: {<br />”main”: [<br />[<br />{<br />”node”: “Séparer Notifications”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Séparer Notifications”: {<br />”main”: [<br />[<br />{<br />”node”: “Canal?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Canal?”: {<br />”main”: [<br />[<br />{<br />”node”: “Envoyer Email”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Envoyer Telegram”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
</section>
</section>
<section id="mise-en-place-des-tableaux-de-bord">
<h3>3.3.2 Mise en Place des Tableaux de Bord<a class="headerlink" href="#mise-en-place-des-tableaux-de-bord" title="Link to this heading"></a></h3>
<section id="id7">
<h4>Workflows à Développer<a class="headerlink" href="#id7" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-MONITORING-DASHBOARD-GENERATOR</p>
<ul class="simple">
<li><p>Objectif: Générer des tableaux de bord pour visualiser les performances du système</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
</ol>
<p>{<br />”name”: “WF-MONITORING-DASHBOARD-GENERATOR”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”rule”: {<br />”interval”: [<br />{<br />”field”: “hours”,<br />”hour”: 6<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Cron”,<br />”type”: “n8n-nodes-base.cron”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/dashboard_config.json”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Charger Config Dashboard”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.errorMessage}}”,<br />”operation”: “exists”<br />}<br />]<br />}<br />},<br />”name”: “Config Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [500, 300]<br />},</p>
<p>{<br />”parameters”: {<br />”functionCode”: “// Créer une configuration par défaut\nconst defaultConfig = {\n  dashboards: [\n    {\n      name: ‘workflow_performance’,\n      title: ‘Performance des Workflows’,\n      description: ‘Tableau de bord de suivi des performances des workflows’,\n      metrics: [\n        {\n          name: ‘execution_time’,\n          title: ‘Temps d\\’Exécution’,\n          type: ‘line’,\n          source: ‘Agence_Monitoring_N8N’,\n          filter: {\n            property: ‘metricType’,\n            value: ‘executionTime’\n          },\n          aggregation: ‘avg’,\n          timeframe: ‘daily’\n        },\n        {\n          name: ‘error_rate’,\n          title: ‘Taux d\\’Erreur’,\n          type: ‘bar’,\n          source: ‘Agence_Monitoring_N8N’,\n          filter: {\n            property: ‘metricType’,\n            value: ‘errorRate’\n          },\n          aggregation: ‘sum’,\n          timeframe: ‘daily’\n        }\n      ],\n      refreshInterval: 3600 // secondes\n    },\n    {\n      name: ‘notion_usage’,\n      title: ‘Utilisation de Notion’,\n      description: ‘Tableau de bord de suivi de l\\’utilisation des bases Notion’,\n      metrics: [\n        {\n          name: ‘record_count’,\n          title: ‘Nombre d\\’Enregistrements’,\n          type: ‘bar’,\n          source: ‘Agence_Monitoring_N8N’,\n          filter: {\n            property: ‘metricType’,\n            value: ‘notionRecordCount’\n          },\n          aggregation: ‘latest’,\n          timeframe: ‘daily’\n        },\n        {\n          name: ‘update_frequency’,\n          title: ‘Fréquence de Mise à Jour’,\n          type: ‘line’,\n          source: ‘Agence_Monitoring_N8N’,\n          filter: {\n            property: ‘metricType’,\n            value: ‘notionUpdateFrequency’\n          },\n          aggregation: ‘avg’,\n          timeframe: ‘daily’\n        }\n      ],\n      refreshInterval: 7200 // secondes\n    }\n  ],\n  settings: {\n    defaultTimeRange: ‘last7days’,\n    theme: ‘light’,\n    exportFormats: [’csv’, ‘json’]\n  },\n  metadata: {\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    version: ‘1.0.0’\n  }\n};\n\n// Convertir en JSON formaté\nconst configJson = JSON.stringify(defaultConfig, null, 2);\n\nreturn {\n  json: {\n    action: ‘create’,\n    config: defaultConfig\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(configJson).toString(’base64’),\n      fileName: ‘dashboard_config.json’\n    }\n  }\n};”<br />},<br />”name”: “Créer Config Par Défaut”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Traiter la configuration existante\nconst configData = $binary.data.toString();\n\n// Parser la configuration\nlet dashboardConfig;\ntry {\n  dashboardConfig = JSON.parse(configData);\n} catch (error) {\n  return {\n    json: {\n      status: ‘error’,\n      message: ‘Erreur de parsing de la configuration du dashboard’,\n      error: error.message\n    }\n  };\n}\n\n// Mettre à jour les métadonnées\ndashboardConfig.metadata.updatedAt = new Date().toISOString();\n\n// Convertir en JSON formaté\nconst updatedConfigJson = JSON.stringify(dashboardConfig, null, 2);\n\nreturn {\n  json: {\n    action: ‘update’,\n    config: dashboardConfig\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(updatedConfigJson).toString(’base64’),\n      fileName: ‘dashboard_config.json’\n    }\n  }\n};”<br />},<br />”name”: “Traiter Config Existante”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/dashboard_config.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Config”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [900, 300]<br />},<br />{<br />”parameters”: {<br />”authentication”: “notionApi”,<br />”operation”: “getDatabases”,<br />”returnAll”: true<br />},<br />”name”: “Lister Bases Notion”,<br />”type”: “n8n-nodes-base.notion”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.title}}”,<br />”operation”: “contains”,<br />”value2”: “Monitoring”<br />}<br />]<br />}<br />},<br />”name”: “Filtrer Base Monitoring”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1300, 300]<br />},<br />{<br />”parameters”: {<br />”authentication”: “notionApi”,<br />”databaseId”: “={{$json.id}}”,<br />”returnAll”: true,<br />”filters”: {<br />”options”: {<br />”filter”: {<br />”conditions”: [<br />{<br />”key”: “metricType”,<br />”condition”: “exists”<br />}<br />]<br />}<br />}<br />}<br />},<br />”name”: “Récupérer Métriques”,<br />”type”: “n8n-nodes-base.notion”,<br />”position”: [1500, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Agréger les métriques pour les tableaux de bord\nconst metrics = $input.all;\nconst config = $node[’Sauvegarder Config’].json.config;\n\n// Organiser les métriques par type\nconst metricsByType = {};\n\nmetrics.forEach(item =&gt; {\n  const properties = item.json.properties;\n  const metricType = properties.metricType?.select?.name || ‘unknown’;\n  \n  if (!metricsByType[metricType]) {\n    metricsByType[metricType] = [];\n  }\n  \n  // Extraire les valeurs des propriétés\n  const metric = {\n    id: item.json.id,\n    timestamp: properties.timestamp?.date?.start || new Date().toISOString(),\n    value: properties.value?.number || 0,\n    workflowName: properties.workflowName?.title?.[0]?.plain_text || ‘N/A’,\n    details: properties.details?.rich_text?.[0]?.plain_text || ‘’\n  };\n  \n  metricsByType[metricType].push(metric);\n});\n\n// Générer les données pour chaque dashboard\nconst dashboardData = {};\n\nconfig.dashboards.forEach(dashboard =&gt; {\n  const dashboardMetrics = {};\n  \n  dashboard.metrics.forEach(metricConfig =&gt; {\n    const filter = metricConfig.filter || {};\n    const filteredMetrics = metricsByType[filter.value] || [];\n    \n    // Appliquer l’agrégation\n    let aggregatedValue;\n    switch (metricConfig.aggregation) {\n      case ‘sum’:\n        aggregatedValue = filteredMetrics.reduce((sum, m) =&gt; sum + m.value, 0);\n        break;\n      case ‘avg’:\n        aggregatedValue = filteredMetrics.length &gt; 0 ?\n          filteredMetrics.reduce((sum, m) =&gt; sum + m.value, 0) / filteredMetrics.length :\n          0;\n        break;\n      case ‘max’:\n        aggregatedValue = filteredMetrics.length &gt; 0 ?\n          Math.max(…filteredMetrics.map(m =&gt; m.value)) :\n          0;\n        break;\n      case ‘min’:\n        aggregatedValue = filteredMetrics.length &gt; 0 ?\n          Math.min(…filteredMetrics.map(m =&gt; m.value)) :\n          0;\n        break;\n      case ‘latest’:\n        aggregatedValue = filteredMetrics.length &gt; 0 ?\n          filteredMetrics.sort((a, b) =&gt; new Date(b.timestamp) - new Date(a.timestamp))[0].value :\n          0;\n        break;\n      default:\n        aggregatedValue = 0;\n    }\n    \n    // Organiser par timeframe\n    const timeframeData = {};\n    \n    if (metricConfig.timeframe === ‘daily’) {\n      // Regrouper par jour\n      filteredMetrics.forEach(metric =&gt; {\n        const date = metric.timestamp.split(’T’)[0];\n        if (!timeframeData[date]) {\n          timeframeData[date] = [];\n        }\n        timeframeData[date].push(metric.value);\n      });\n    }\n    \n    // Calculer les valeurs agrégées par timeframe\n    const timeSeriesData = Object.entries(timeframeData).map(([date, values]) =&gt; {\n      let value;\n      switch (metricConfig.aggregation) {\n        case ‘sum’:\n          value = values.reduce((sum, v) =&gt; sum + v, 0);\n          break;\n        case ‘avg’:\n          value = values.reduce((sum, v) =&gt; sum + v, 0) / values.length;\n          break;\n        case ‘max’:\n          value = Math.max(…values);\n          break;\n        case ‘min’:\n          value = Math.min(…values);\n          break;\n        default:\n          value = values[0];\n      }\n      \n      return { date, value };\n    });\n    \n    dashboardMetrics[metricConfig.name] = {\n      title: metricConfig.title,\n      type: metricConfig.type,\n      aggregatedValue,\n      timeSeriesData\n    };\n  });\n  \n  dashboardData[dashboard.name] = {\n    title: dashboard.title,\n    description: dashboard.description,\n    metrics: dashboardMetrics,\n    generatedAt: new Date().toISOString()\n  };\n});\n\nreturn {\n  json: {\n    dashboardData\n  }\n};”<br />},<br />”name”: “Agréger Métriques”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1700, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Générer le HTML du tableau de bord\nconst dashboardData = $input.item.json.dashboardData;\nconst config = $node[’Sauvegarder Config’].json.config;\n\n// Générer le HTML pour chaque dashboard\nlet dashboardsHtml = ‘’;\n\nObject.entries(dashboardData).forEach(([dashboardName, dashboard]) =&gt; {\n  dashboardsHtml += `\n    &lt;div class=\”dashboard\” id=\”${dashboardName}\”&gt;\n      &lt;h2&gt;${dashboard.title}&lt;/h2&gt;\n      &lt;p&gt;${dashboard.description}&lt;/p&gt;\n      &lt;div class=\”metrics-container\”&gt;\n  `;\n  \n  // Générer le HTML pour chaque métrique\n  Object.entries(dashboard.metrics).forEach(([metricName, metric]) =&gt; {\n    dashboardsHtml += `\n        &lt;div class=\”metric-card\”&gt;\n          &lt;h3&gt;${metric.title}&lt;/h3&gt;\n          &lt;div class=\”metric-value\”&gt;${formatValue(metric.aggregatedValue)}&lt;/div&gt;\n          &lt;div class=\”metric-chart\” id=\”chart-${dashboardName}-${metricName}\”&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    `;\n  });\n  \n  dashboardsHtml += `\n      &lt;/div&gt;\n    &lt;/div&gt;\n  `;\n});\n\n// Générer le script pour les graphiques\nlet chartsScript = `\n&lt;script&gt;\n  document.addEventListener(’DOMContentLoaded’, function() {\n`;\n\nObject.entries(dashboardData).forEach(([dashboardName, dashboard]) =&gt; {\n  Object.entries(dashboard.metrics).forEach(([metricName, metric]) =&gt; {\n    const chartData = metric.timeSeriesData;\n    const chartType = metric.type;\n    \n    chartsScript += `\n    // Chart for ${metric.title}\n    const ctx${dashboardName}${metricName} = document.getElementById(’chart-${dashboardName}-${metricName}’).getContext(’2d’);\n    new Chart(ctx${dashboardName}${metricName}, {\n      type: ‘${chartType}’,\n      data: {\n        labels: [${chartData.map(d =&gt; `’${d.date}’`).join(’, ‘)}],\n        datasets: [{\n          label: ‘${metric.title}’,\n          data: [${chartData.map(d =&gt; d.value).join(’, ‘)}],\n          backgroundColor: ‘${getChartColor(metricName, 0.2)}’,\n          borderColor: ‘${getChartColor(metricName, 1)}’,\n          borderWidth: 1\n        }]\n      },\n      options: {\n        responsive: true,\n        scales: {\n          y: {\n            beginAtZero: true\n          }\n        }\n      }\n    });\n    `;\n  });\n});\n\nchartsScript += `\n  });\n&lt;/script&gt;\n`;\n\n// Générer le HTML complet\nconst html = `\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\”fr\”&gt;\n&lt;head&gt;\n  &lt;meta charset=\”UTF-8\”&gt;\n  &lt;meta name=\”viewport\” content=\”width=device-width, initial-scale=1.0\”&gt;\n  &lt;title&gt;Tableaux de Bord - Plan Magistral V5&lt;/title&gt;\n  &lt;script src=\”https://cdn.jsdelivr.net/npm/chart.js\”&gt;&lt;/script&gt;\n  &lt;style&gt;\n    body {\n      font-family: Arial, sans-serif;\n      margin: 0;\n      padding: 20px;\n      background-color: ${config.settings.theme === ‘dark’ ? ‘#1e1e1e’ : ‘#f5f5f5’};\n      color: ${config.settings.theme === ‘dark’ ? ‘#ffffff’ : ‘#333333’};\n    }\n    .dashboard {\n      background-color: ${config.settings.theme === ‘dark’ ? ‘#2d2d2d’ : ‘#ffffff’};\n      border-radius: 8px;\n      padding: 20px;\n      margin-bottom: 30px;\n      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n    }\n    h2 {\n      margin-top: 0;\n      border-bottom: 1px solid ${config.settings.theme === ‘dark’ ? ‘#444’ : ‘#eee’};\n      padding-bottom: 10px;\n    }\n    .metrics-container {\n      display: grid;\n      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n      gap: 20px;\n      margin-top: 20px;\n    }\n    .metric-card {\n      background-color: ${config.settings.theme === ‘dark’ ? ‘#3d3d3d’ : ‘#f9f9f9’};\n      border-radius: 6px;\n      padding: 15px;\n      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.05);\n    }\n    .metric-value {\n      font-size: 24px;\n      font-weight: bold;\n      margin: 10px 0;\n      color: #4a90e2;\n    }\n    .metric-chart {\n      height: 200px;\n      margin-top: 15px;\n    }\n    .header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin-bottom: 20px;\n    }\n    .export-buttons {\n      display: flex;\n      gap: 10px;\n    }\n    .export-button {\n      padding: 8px 12px;\n      background-color: #4a90e2;\n      color: white;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n    }\n    .export-button:hover {\n      background-color: #3a80d2;\n    }\n    .last-updated {\n      font-size: 12px;\n      color: ${config.settings.theme === ‘dark’ ? ‘#aaa’ : ‘#888’};\n      text-align: right;\n      margin-top: 5px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=\”header\”&gt;\n    &lt;h1&gt;Tableaux de Bord - Plan Magistral V5&lt;/h1&gt;\n    &lt;div class=\”export-buttons\”&gt;\n      ${config.settings.exportFormats.includes(’csv’) ? ‘&lt;button class=\”export-button\” onclick=\”exportCSV()\”&gt;Exporter CSV&lt;/button&gt;’ : ‘’}\n      ${config.settings.exportFormats.includes(’json’) ? ‘&lt;button class=\”export-button\” onclick=\”exportJSON()\”&gt;Exporter JSON&lt;/button&gt;’ : ‘’}\n    &lt;/div&gt;\n  &lt;/div&gt;\n  \n  ${dashboardsHtml}\n  \n  &lt;div class=\”last-updated\”&gt;\n    Dernière mise à jour: ${new Date().toLocaleString(’fr-FR’)}\n  &lt;/div&gt;\n  \n  ${chartsScript}\n  \n  &lt;script&gt;\n    // Export functions\n    function exportCSV() {\n      const dashboardData = ${JSON.stringify(dashboardData)};\n      let csv = ‘Dashboard,Metric,Date,Value\\n’;\n      \n      Object.entries(dashboardData).forEach(([dashboardName, dashboard]) =&gt; {\n        Object.entries(dashboard.metrics).forEach(([metricName, metric]) =&gt; {\n          metric.timeSeriesData.forEach(point =&gt; {\n            csv += `\”${dashboard.title}\”,\”${metric.title}\”,\”${point.date}\”,${point.value}\\n`;\n          });\n        });\n      });\n      \n      downloadFile(csv, ‘dashboard_data.csv’, ‘text/csv’);\n    }\n    \n    function exportJSON() {\n      const dashboardData = ${JSON.stringify(dashboardData)};\n      downloadFile(JSON.stringify(dashboardData, null, 2), ‘dashboard_data.json’, ‘application/json’);\n    }\n    \n    function downloadFile(content, fileName, contentType) {\n      const a = document.createElement(’a’);\n      const file = new Blob([content], {type: contentType});\n      a.href = URL.createObjectURL(file);\n      a.download = fileName;\n      a.click();\n    }\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n`;\n\n// Fonctions utilitaires\nfunction formatValue(value) {\n  if (typeof value === ‘number’) {\n    return value.toLocaleString(’fr-FR’, { maximumFractionDigits: 2 });\n  }\n  return value;\n}\n\nfunction getChartColor(metricName, alpha) {\n  // Générer une couleur basée sur le nom de la métrique\n  const hash = metricName.split(’’).reduce((acc, char) =&gt; {\n    return char.charCodeAt(0) + ((acc &lt;&lt; 5) - acc);\n  }, 0);\n  \n  const h = Math.abs(hash) % 360;\n  return `hsla(${h}, 70%, 60%, ${alpha})`;\n}\n\nreturn {\n  json: {\n    dashboardData\n  },\n  binary: {\n    dashboard: {\n      mimeType: ‘text/html’,\n      data: Buffer.from(html).toString(’base64’),\n      fileName: ‘dashboard.html’\n    }\n  }\n};”<br />},<br />”name”: “Générer Dashboard HTML”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1900, 200]<br />},<br />{<br />”parameters”: {<br />”path”: “dashboards/dashboard.html”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Dashboard”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [2100, 200]<br />}</p>
</section>
</section>
<section id="implementation-des-mecanismes-de-recuperation">
<h3>3.3.3 Implémentation des Mécanismes de Récupération<a class="headerlink" href="#implementation-des-mecanismes-de-recuperation" title="Link to this heading"></a></h3>
<section id="id8">
<h4>Workflows à Développer<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<ol class="simple">
<li><p>WF-RECOVERY-MANAGER</p>
<ul class="simple">
<li><p>Objectif: Mettre en place des mécanismes de récupération en cas d’échec des workflows</p></li>
<li><p>Structure JSON:</p></li>
</ul>
</li>
<li><p>Copy</p></li>
</ol>
<p>{<br />”name”: “WF-RECOVERY-MANAGER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”path”: “recovery”,<br />”responseMode”: “onReceived”,<br />”options”: {}<br />},<br />”name”: “Webhook”,<br />”type”: “n8n-nodes-base.webhook”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Validation des paramètres d’entrée\nconst input = $input.item.json;\n\n// Vérifier les paramètres requis\nif (!input.workflowId) {\n  return {\n    json: {\n      success: false,\n      error: ‘Le paramètre workflowId est requis’\n    }\n  };\n}\n\n// Déterminer l’action\nconst action = input.action || ‘recover’;\n\n// Retourner les informations pour le traitement\nreturn {\n  json: {\n    workflowId: input.workflowId,\n    workflowName: input.workflowName || ‘Unknown’,\n    executionId: input.executionId,\n    action,\n    error: input.error || {},\n    context: input.context || {},\n    timestamp: new Date().toISOString()\n  }\n};”<br />},<br />”name”: “Valider Requête”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.action}}”,<br />”operation”: “equal”,<br />”value2”: “recover”<br />}<br />]<br />}<br />},<br />”name”: “Action?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Logique de récupération\nconst workflowId = $input.item.json.workflowId;\nconst workflowName = $input.item.json.workflowName;\nconst executionId = $input.item.json.executionId;\nconst error = $input.item.json.error;\nconst context = $input.item.json.context;\n\n// Enregistrer l’erreur\nconst recoveryLog = {\n  workflowId,\n  workflowName,\n  executionId,\n  error,\n  context,\n  timestamp: new Date().toISOString(),\n  recoveryAttempt: 1,\n  status: ‘pending’\n};\n\n// Déterminer la stratégie de récupération\nlet recoveryStrategy;\n\n// Analyser l’erreur pour déterminer la stratégie\nif (error.message &amp;&amp; error.message.includes(’timeout’)) {\n  recoveryStrategy = ‘retry’;\n} else if (error.message &amp;&amp; error.message.includes(’rate limit’)) {\n  recoveryStrategy = ‘delay_retry’;\n} else if (error.message &amp;&amp; error.message.includes(’credential’)) {\n  recoveryStrategy = ‘notify_admin’;\n} else {\n  recoveryStrategy = ‘default’;\n}\n\n// Ajouter la stratégie au log\nrecoveryLog.recoveryStrategy = recoveryStrategy;\n\n// Convertir en JSON formaté\nconst logJson = JSON.stringify(recoveryLog, null, 2);\n\nreturn {\n  json: {\n    workflowId,\n    workflowName,\n    executionId,\n    recoveryStrategy,\n    recoveryLog\n  },\n  binary: {\n    log: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(logJson).toString(’base64’),\n      fileName: `recovery_${workflowId}_${new Date().toISOString().replace(/[:.]/g, ‘-’)}.json`\n    }\n  }\n};”<br />},<br />”name”: “Traiter Récupération”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Logique de sauvegarde\nconst workflowId = $input.item.json.workflowId;\nconst workflowName = $input.item.json.workflowName;\nconst context = $input.item.json.context;\n\n// Créer une sauvegarde\nconst backupLog = {\n  workflowId,\n  workflowName,\n  context,\n  timestamp: new Date().toISOString(),\n  status: ‘completed’\n};\n\n// Convertir en JSON formaté\nconst logJson = JSON.stringify(backupLog, null, 2);\n\nreturn {\n  json: {\n    workflowId,\n    workflowName,\n    backupLog\n  },\n  binary: {\n    log: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(logJson).toString(’base64’),\n      fileName: `backup_${workflowId}_${new Date().toISOString().replace(/[:.]/g, ‘-’)}.json`\n    }\n  }\n};”<br />},<br />”name”: “Traiter Sauvegarde”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “logs/recovery/{{$binary.log.fileName}}”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Log”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [900, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.recoveryStrategy}}”,<br />”operation”: “equal”,<br />”value2”: “retry”<br />}<br />]<br />}<br />},<br />”name”: “Stratégie?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1100, 200]<br />},<br />{<br />”parameters”: {<br />”url”: “=http://localhost:5678/rest/workflows/{{$json.workflowId}}/execute”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”sendBody”: true,<br />”bodyParameters”: {<br />”parameters”: [<br />{<br />”name”: “data”,<br />”value”: “={{$json.context}}”<br />},<br />{<br />”name”: “recovery”,<br />”value”: true<br />}<br />]<br />},<br />”options”: {}<br />},<br />”name”: “Réexécuter Workflow”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [1300, 100]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Attendre avant de réessayer\nreturn new Promise(resolve =&gt; {\n  // Attendre 5 minutes\n  setTimeout(() =&gt; {\n    resolve({\n      json: {\n        …$input.item.json,\n        delayedRetry: true,\n        delayMinutes: 5\n      }\n    });\n  }, 5 * 60 * 1000);\n});”<br />},<br />”name”: “Attendre et Réessayer”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1300, 300]<br />},<br />{<br />”parameters”: {<br />”chatId”: “{{$env.TELEGRAM_CHAT_ID}}”,<br />”text”: “=⚠️ ALERTE RÉCUPÉRATION\n\nLe workflow {{$json.workflowName}} (ID: {{$json.workflowId}}) a rencontré une erreur nécessitant une intervention manuelle.\n\nErreur: {{$json.error.message}}\n\nVeuillez vérifier les logs de récupération pour plus de détails.”,<br />”additionalFields”: {}<br />},<br />”name”: “Notifier Admin”,<br />”type”: “n8n-nodes-base.telegram”,<br />”position”: [1300, 500]<br />}<br />],<br />”connections”: {<br />”Webhook”: {<br />”main”: [<br />[<br />{<br />”node”: “Valider Requête”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Valider Requête”: {<br />”main”: [<br />[<br />{<br />”node”: “Action?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Action?”: {<br />”main”: [<br />[<br />{<br />”node”: “Traiter Récupération”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Traiter Sauvegarde”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Traiter Récupération”: {<br />”main”: [</p>
<p>{<br />”Traiter Récupération”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Log”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Traiter Sauvegarde”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Log”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Sauvegarder Log”: {<br />”main”: [<br />[<br />{<br />”node”: “Stratégie?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Stratégie?”: {<br />”main”: [<br />[<br />{<br />”node”: “Réexécuter Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Attendre et Réessayer”,<br />”type”: “main”,<br />”index”: 0<br />},<br />{<br />”node”: “Notifier Admin”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Attendre et Réessayer”: {<br />”main”: [<br />[<br />{<br />”node”: “Réexécuter Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}</p>
<p>WF-BACKUP-SCHEDULER</p>
<ul class="simple">
<li><p>Objectif: Planifier et gérer les sauvegardes automatiques des workflows et des données</p></li>
<li><p>Structure JSON:</p></li>
</ul>
<p>Copy<br />{<br />”name”: “WF-BACKUP-SCHEDULER”,<br />”nodes”: [<br />{<br />”parameters”: {<br />”rule”: {<br />”interval”: [<br />{<br />”field”: “hours”,<br />”hour”: 1<br />}<br />]<br />}<br />},<br />”name”: “Déclencheur Cron”,<br />”type”: “n8n-nodes-base.cron”,<br />”position”: [100, 300]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/backup_config.json”,<br />”options”: {<br />”encoding”: “utf8”<br />}<br />},<br />”name”: “Charger Config Backup”,<br />”type”: “n8n-nodes-base.readBinaryFile”,<br />”position”: [300, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.errorMessage}}”,<br />”operation”: “exists”<br />}<br />]<br />}<br />},<br />”name”: “Config Existe?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [500, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Créer une configuration par défaut\nconst defaultConfig = {\n  backupSchedule: {\n    workflows: {\n      frequency: ‘daily’,\n      time: ‘01:00’,\n      retention: 7 // jours\n    },\n    notion: {\n      frequency: ‘daily’,\n      time: ‘02:00’,\n      retention: 14 // jours\n    },\n    configurations: {\n      frequency: ‘hourly’,\n      retention: 24 // heures\n    }\n  },\n  backupLocations: {\n    local: {\n      enabled: true,\n      path: ‘backups/’\n    },\n    remote: {\n      enabled: false,\n      type: ‘gdrive’,\n      folderId: ‘’\n    }\n  },\n  notifications: {\n    onSuccess: false,\n    onFailure: true,\n    channels: [’telegram’]\n  },\n  metadata: {\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    version: ‘1.0.0’\n  }\n};\n\n// Convertir en JSON formaté\nconst configJson = JSON.stringify(defaultConfig, null, 2);\n\nreturn {\n  json: {\n    action: ‘create’,\n    config: defaultConfig\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(configJson).toString(’base64’),\n      fileName: ‘backup_config.json’\n    }\n  }\n};”<br />},<br />”name”: “Créer Config Par Défaut”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Traiter la configuration existante\nconst configData = $binary.data.toString();\n\n// Parser la configuration\nlet backupConfig;\ntry {\n  backupConfig = JSON.parse(configData);\n} catch (error) {\n  return {\n    json: {\n      status: ‘error’,\n      message: ‘Erreur de parsing de la configuration de backup’,\n      error: error.message\n    }\n  };\n}\n\n// Mettre à jour les métadonnées\nbackupConfig.metadata.updatedAt = new Date().toISOString();\n\n// Convertir en JSON formaté\nconst updatedConfigJson = JSON.stringify(backupConfig, null, 2);\n\nreturn {\n  json: {\n    action: ‘update’,\n    config: backupConfig\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(updatedConfigJson).toString(’base64’),\n      fileName: ‘backup_config.json’\n    }\n  }\n};”<br />},<br />”name”: “Traiter Config Existante”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [700, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “configs/backup_config.json”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Config”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [900, 300]<br />},<br />{<br />”parameters”: {<br />”url”: “http://localhost:5678/rest/workflows”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”options”: {}<br />},<br />”name”: “Lister Workflows”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [1100, 300]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Préparer les tâches de backup\nconst workflows = $json.data || [];\nconst config = $node[’Sauvegarder Config’].json.config;\nconst now = new Date();\n\n// Déterminer quels backups doivent être exécutés maintenant\nconst backupTasks = [];\n\n// Vérifier si c’est l’heure du backup des workflows\nif (config.backupSchedule.workflows.frequency === ‘daily’) {\n  const [hour, minute] = config.backupSchedule.workflows.time.split(’:’).map(Number);\n  if (now.getHours() === hour &amp;&amp; now.getMinutes() &lt; 15) { // Fenêtre de 15 minutes\n    backupTasks.push({\n      type: ‘workflows’,\n      items: workflows.map(wf =&gt; ({\n        id: wf.id,\n        name: wf.name\n      })),\n      config: config.backupSchedule.workflows\n    });\n  }\n}\n\n// Vérifier si c’est l’heure du backup Notion\nif (config.backupSchedule.notion.frequency === ‘daily’) {\n  const [hour, minute] = config.backupSchedule.notion.time.split(’:’).map(Number);\n  if (now.getHours() === hour &amp;&amp; now.getMinutes() &lt; 15) { // Fenêtre de 15 minutes\n    backupTasks.push({\n      type: ‘notion’,\n      config: config.backupSchedule.notion\n    });\n  }\n}\n\n// Backup des configurations (horaire)\nif (config.backupSchedule.configurations.frequency === ‘hourly’) {\n  backupTasks.push({\n    type: ‘configurations’,\n    config: config.backupSchedule.configurations\n  });\n}\n\nreturn {\n  json: {\n    backupTasks,\n    timestamp: now.toISOString(),\n    backupLocations: config.backupLocations\n  }\n};”<br />},<br />”name”: “Préparer Tâches Backup”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1300, 300]<br />},<br />{<br />”parameters”: {<br />”mode”: “combine”,<br />”combinationMode”: “multiplex”,<br />”options”: {}<br />},<br />”name”: “Séparer Tâches”,<br />”type”: “n8n-nodes-base.splitInBatches”,<br />”position”: [1500, 300]<br />},<br />{<br />”parameters”: {<br />”conditions”: {<br />”string”: [<br />{<br />”value1”: “={{$json.type}}”,<br />”operation”: “equal”,<br />”value2”: “workflows”<br />}<br />]<br />}<br />},<br />”name”: “Type Backup?”,<br />”type”: “n8n-nodes-base.if”,<br />”position”: [1700, 300]<br />},<br />{<br />”parameters”: {<br />”mode”: “combine”,<br />”combinationMode”: “multiplex”,<br />”options”: {}<br />},<br />”name”: “Séparer Workflows”,<br />”type”: “n8n-nodes-base.splitInBatches”,<br />”position”: [1900, 200]<br />},<br />{<br />”parameters”: {<br />”url”: “=http://localhost:5678/rest/workflows/{{$json.id}}/export”,<br />”authentication”: “genericCredentialType”,<br />”genericAuthType”: “n8nApi”,<br />”options”: {}<br />},<br />”name”: “Exporter Workflow”,<br />”type”: “n8n-nodes-base.httpRequest”,<br />”position”: [2100, 200]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Préparer le fichier de backup\nconst workflowData = $json;\nconst backupLocations = $node[’Préparer Tâches Backup’].json.backupLocations;\nconst timestamp = new Date().toISOString().replace(/[:.]/g, ‘-’);\nconst workflowName = workflowData.name.replace(/[^a-zA-Z0-9]/g, ‘_’);\nconst fileName = `workflow_${workflowName}_${timestamp}.json`;\n\n// Déterminer le chemin de sauvegarde\nlet savePath;\nif (backupLocations.local.enabled) {\n  savePath = `${backupLocations.local.path}workflows/${fileName}`;\n}\n\n// Convertir en JSON formaté\nconst workflowJson = JSON.stringify(workflowData, null, 2);\n\nreturn {\n  json: {\n    workflowId: workflowData.id,\n    workflowName: workflowData.name,\n    fileName,\n    savePath\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(workflowJson).toString(’base64’),\n      fileName\n    }\n  }\n};”<br />},<br />”name”: “Préparer Fichier Backup”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [2300, 200]<br />},<br />{<br />”parameters”: {<br />”path”: “={{$json.savePath}}”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Backup”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [2500, 200]<br />},<br />{<br />”parameters”: {<br />”authentication”: “notionApi”,<br />”operation”: “getDatabases”,<br />”returnAll”: true<br />},<br />”name”: “Lister Bases Notion”,<br />”type”: “n8n-nodes-base.notion”,<br />”position”: [1900, 400]<br />},<br />{<br />”parameters”: {<br />”mode”: “combine”,<br />”combinationMode”: “multiplex”,<br />”options”: {}<br />},<br />”name”: “Séparer Bases”,<br />”type”: “n8n-nodes-base.splitInBatches”,<br />”position”: [2100, 400]<br />},<br />{<br />”parameters”: {<br />”authentication”: “notionApi”,<br />”databaseId”: “={{$json.id}}”,<br />”returnAll”: true,<br />”simplifyOutput”: true<br />},<br />”name”: “Exporter Base Notion”,<br />”type”: “n8n-nodes-base.notion”,<br />”position”: [2300, 400]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Préparer le fichier de backup Notion\nconst notionData = $input.all;\nconst databaseInfo = $input.first.json;\nconst backupLocations = $node[’Préparer Tâches Backup’].json.backupLocations;\nconst timestamp = new Date().toISOString().replace(/[:.]/g, ‘-’);\nconst databaseName = databaseInfo.title.replace(/[^a-zA-Z0-9]/g, ‘_’);\nconst fileName = `notion_${databaseName}_${timestamp}.json`;\n\n// Déterminer le chemin de sauvegarde\nlet savePath;\nif (backupLocations.local.enabled) {\n  savePath = `${backupLocations.local.path}notion/${fileName}`;\n}\n\n// Préparer les données\nconst backupData = {\n  database: databaseInfo,\n  records: notionData.map(item =&gt; item.json),\n  metadata: {\n    exportedAt: new Date().toISOString(),\n    recordCount: notionData.length\n  }\n};\n\n// Convertir en JSON formaté\nconst dataJson = JSON.stringify(backupData, null, 2);\n\nreturn {\n  json: {\n    databaseId: databaseInfo.id,\n    databaseName: databaseInfo.title,\n    recordCount: notionData.length,\n    fileName,\n    savePath\n  },\n  binary: {\n    data: {\n      mimeType: ‘application/json’,\n      data: Buffer.from(dataJson).toString(’base64’),\n      fileName\n    }\n  }\n};”<br />},<br />”name”: “Préparer Backup Notion”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [2500, 400]<br />},<br />{<br />”parameters”: {<br />”path”: “={{$json.savePath}}”,<br />”options”: {}<br />},<br />”name”: “Sauvegarder Backup Notion”,<br />”type”: “n8n-nodes-base.writeBinaryFile”,<br />”position”: [2700, 400]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Backup des fichiers de configuration\nconst fs = require(’fs’);\nconst path = require(’path’);\nconst backupLocations = $node[’Préparer Tâches Backup’].json.backupLocations;\nconst timestamp = new Date().toISOString().replace(/[:.]/g, ‘-’);\n\n// Chemin du dossier des configurations\nconst configsDir = ‘configs’;\nconst backupFileName = `configurations_${timestamp}.zip`;\n\n// Déterminer le chemin de sauvegarde\nlet savePath;\nif (backupLocations.local.enabled) {\n  savePath = `${backupLocations.local.path}configurations/${backupFileName}`;\n}\n\n// Créer une archive ZIP des configurations\nconst archiver = require(’archiver’);\nconst output = fs.createWriteStream(savePath);\nconst archive = archiver(’zip’, {\n  zlib: { level: 9 } // Niveau de compression maximum\n});\n\n// Événements de l’archive\noutput.on(’close’, function() {\n  console.log(`Archive créée: ${archive.pointer()} octets`);\n});\n\narchive.on(’error’, function(err) {\n  throw err;\n});\n\n// Pipe l’archive vers le fichier de sortie\narchive.pipe(output);\n\n// Ajouter les fichiers de configuration à l’archive\narchive.directory(configsDir, ‘configs’);\n\n// Finaliser l’archive\narchive.finalize();\n\nreturn {\n  json: {\n    type: ‘configurations’,\n    fileName: backupFileName,\n    savePath,\n    timestamp: new Date().toISOString()\n  }\n};”<br />},<br />”name”: “Backup Configurations”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [1900, 600]<br />},<br />{<br />”parameters”: {<br />”functionCode”: “// Nettoyer les anciens backups\nconst fs = require(’fs’);\nconst path = require(’path’);\nconst config = $node[’Sauvegarder Config’].json.config;\nconst backupLocations = config.backupLocations;\n\n// Fonction pour supprimer les fichiers plus anciens que la période de rétention\nfunction cleanupOldBackups(directory, retentionDays) {\n  if (!fs.existsSync(directory)) {\n    return { directory, status: ‘skipped’, reason: ‘directory_not_found’ };\n  }\n  \n  const now = new Date();\n  const files = fs.readdirSync(directory);\n  const deletedFiles = [];\n  \n  files.forEach(file =&gt; {\n    const filePath = path.join(directory, file);\n    const stats = fs.statSync(filePath);\n    const fileAge = (now - stats.mtime) / (1000 * 60 * 60 * 24); // âge en jours\n    \n    if (fileAge &gt; retentionDays) {\n      fs.unlinkSync(filePath);\n      deletedFiles.push(file);\n    }\n  });\n  \n  return {\n    directory,\n    status: ‘cleaned’,\n    deletedCount: deletedFiles.length,\n    deletedFiles\n  };\n}\n\n// Nettoyer les backups de workflows\nconst workflowsCleanup = cleanupOldBackups(\n  path.join(backupLocations.local.path, ‘workflows’),\n  config.backupSchedule.workflows.retention\n);\n\n// Nettoyer les backups Notion\nconst notionCleanup = cleanupOldBackups(\n  path.join(backupLocations.local.path, ‘notion’),\n  config.backupSchedule.notion.retention\n);\n\n// Nettoyer les backups de configurations\nconst configsCleanup = cleanupOldBackups(\n  path.join(backupLocations.local.path, ‘configurations’),\n  config.backupSchedule.configurations.retention\n);\n\nreturn {\n  json: {\n    timestamp: new Date().toISOString(),\n    cleanup: {\n      workflows: workflowsCleanup,\n      notion: notionCleanup,\n      configurations: configsCleanup\n    }\n  }\n};”<br />},<br />”name”: “Nettoyer Anciens Backups”,<br />”type”: “n8n-nodes-base.function”,<br />”position”: [2700, 600]<br />}<br />],<br />”connections”: {<br />”Déclencheur Cron”: {<br />”main”: [<br />[<br />{<br />”node”: “Charger Config Backup”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Charger Config Backup”: {<br />”main”: [<br />[<br />{<br />”node”: “Config Existe?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Config Existe?”: {<br />”main”: [<br />[<br />{<br />”node”: “Créer Config Par Défaut”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Traiter Config Existante”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Créer Config Par Défaut”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Traiter Config Existante”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Config”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Sauvegarder Config”: {<br />”main”: [<br />[<br />{<br />”node”: “Lister Workflows”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Lister Workflows”: {<br />”main”: [<br />[<br />{<br />”node”: “Préparer Tâches Backup”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Préparer Tâches Backup”: {<br />”main”: [<br />[<br />{<br />”node”: “Séparer Tâches”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Séparer Tâches”: {<br />”main”: [<br />[<br />{<br />”node”: “Type Backup?”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Type Backup?”: {<br />”main”: [<br />[<br />{<br />”node”: “Séparer Workflows”,<br />”type”: “main”,<br />”index”: 0<br />}<br />],<br />[<br />{<br />”node”: “Lister Bases Notion”,<br />”type”: “main”,<br />”index”: 0<br />},<br />{<br />”node”: “Backup Configurations”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Séparer Workflows”: {<br />”main”: [<br />[<br />{<br />”node”: “Exporter Workflow”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Exporter Workflow”: {<br />”main”: [<br />[<br />{<br />”node”: “Préparer Fichier Backup”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Préparer Fichier Backup”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Backup”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Sauvegarder Backup”: {<br />”main”: [<br />[<br />{<br />”node”: “Nettoyer Anciens Backups”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Lister Bases Notion”: {<br />”main”: [<br />[<br />{<br />”node”: “Séparer Bases”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Séparer Bases”: {<br />”main”: [<br />[<br />{<br />”node”: “Exporter Base Notion”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Exporter Base Notion”: {<br />”main”: [<br />[<br />{<br />”node”: “Préparer Backup Notion”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Préparer Backup Notion”: {<br />”main”: [<br />[<br />{<br />”node”: “Sauvegarder Backup Notion”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Sauvegarder Backup Notion”: {<br />”main”: [<br />[<br />{<br />”node”: “Nettoyer Anciens Backups”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />},<br />”Backup Configurations”: {<br />”main”: [<br />[<br />{<br />”node”: “Nettoyer Anciens Backups”,<br />”type”: “main”,<br />”index”: 0<br />}<br />]<br />]<br />}<br />}<br />}</p>
<p>┌─────────────────────────────────────────────────────────────────────────────┐<br />│                                                                             │<br />│                  PHASE 3: INTÉGRATION AVEC LE PLAN MAGISTRAL V5             │<br />│                                                                             │<br />│  ┌─────────────────────┐     ┌─────────────────────┐     ┌─────────────────┐│<br />│  │                     │     │                     │     │                 ││<br />│  │  ÉTAPE 3.1          │     │  ÉTAPE 3.2          │     │  ÉTAPE 3.3      ││<br />│  │  STRUCTURES DE BASE │────►│  MIGRATION          │────►│  MONITORING     ││<br />│  │                     │     │  FONCTIONNALITÉS    │     │                 ││<br />│  └─────────────────────┘     └─────────────────────┘     └─────────────────┘│<br />│     │         │                  │         │                │         │     │<br />│     ▼         ▼                  ▼         ▼                ▼         ▼     │<br />│  ┌─────┐   ┌─────┐            ┌─────┐   ┌─────┐          ┌─────┐   ┌─────┐ │<br />│  │     │   │     │            │     │   │     │          │     │   │     │ │<br />│  │ P1  │◄──┤ P2  │◄───────────┤ P3  │◄──┤ P4  │          │ALERT│   │DASH │ │<br />│  │     │   │     │            │     │   │     │          │     │   │     │ │<br />│  └─────┘   └─────┘            └─────┘   └─────┘          └─────┘   └─────┘ │<br />│     ▲         ▲                  ▲         ▲                │         │     │<br />│     │         │                  │         │                ▼         ▼     │<br />│     └─────────┴──────────────────┴─────────┘          ┌─────────────────┐  │<br />│                      │                                 │                 │  │<br />│                      │                                 │  RÉCUPÉRATION   │  │<br />│                      │                                 │  ET SAUVEGARDE  │  │<br />│                      │                                 │                 │  │<br />│                      │                                 └─────────────────┘  │<br />│                      ▼                                        │             │<br />│               ┌─────────────────┐                             │             │<br />│               │                 │                             │             │<br />│               │  CONFIGURATION  │◄────────────────────────────┘             │<br />│               │  CENTRALISÉE    │                                           │<br />│               │                 │                                           │<br />│               └─────────────────┘                                           │<br />│                      │                                                      │<br />│                      │                                                      │<br />│                      ▼                                                      │<br />│               ┌─────────────────┐                                           │<br />│               │                 │                                           │<br />│               │  WEBHOOKS ET    │                                           │<br />│               │  INTÉGRATIONS   │                                           │<br />│               │                 │                                           │<br />│               └─────────────────┘                                           │<br />│                                                                             │<br />└─────────────────────────────────────────────────────────────────────────────┘</p>
</section>
</section>
</section>
<section id="conclusion-et-recommandations">
<h2>Conclusion et Recommandations<a class="headerlink" href="#conclusion-et-recommandations" title="Link to this heading"></a></h2>
<p>La Phase 3 du plan de transition est cruciale pour préparer l’infrastructure nécessaire à l’implémentation du Plan Magistral V5. Cette phase établit les fondations techniques sur lesquelles reposeront toutes les fonctionnalités futures.</p>
<section id="points-cles-a-retenir">
<h3>Points Clés à Retenir<a class="headerlink" href="#points-cles-a-retenir" title="Link to this heading"></a></h3>
<ol class="simple">
<li><p>Architecture Modulaire</p>
<ul class="simple">
<li><p>Les workflows sont organisés en piliers fonctionnels clairement définis</p></li>
<li><p>Chaque pilier a ses propres responsabilités et interfaces</p></li>
<li><p>La communication entre piliers se fait via des webhooks standardisés</p></li>
</ul>
</li>
<li><p>Configuration Centralisée</p>
<ul class="simple">
<li><p>Toutes les configurations sont stockées dans un format standardisé</p></li>
<li><p>Les workflows accèdent aux configurations via WF-CORE-CONFIG-CENTRAL</p></li>
<li><p>Les modifications de configuration sont tracées et versionnées</p></li>
</ul>
</li>
<li><p>Monitoring Robuste</p>
<ul class="simple">
<li><p>Système d’alertes configurable pour détecter les problèmes</p></li>
<li><p>Tableaux de bord pour visualiser les performances</p></li>
<li><p>Mécanismes de récupération automatique en cas d’erreur</p></li>
</ul>
</li>
<li><p>Migration Progressive</p>
<ul class="simple">
<li><p>Cartographie détaillée des fonctionnalités existantes</p></li>
<li><p>Templates pour faciliter la migration</p></li>
<li><p>Tests automatisés pour valider les fonctionnalités migrées</p></li>
</ul>
</li>
</ol>
</section>
<section id="recommandations-pour-l-implementation">
<h3>Recommandations pour l’Implémentation<a class="headerlink" href="#recommandations-pour-l-implementation" title="Link to this heading"></a></h3>
<ol class="simple">
<li><p>Ordre de Développement</p>
<ul class="simple">
<li><p>Commencer par les workflows de l’Étape 3.1 pour établir les structures de base</p></li>
<li><p>Développer ensuite les workflows de monitoring de l’Étape 3.3</p></li>
<li><p>Terminer par les workflows de migration de l’Étape 3.2</p></li>
</ul>
</li>
<li><p>Tests Approfondis</p>
<ul class="simple">
<li><p>Tester chaque workflow individuellement</p></li>
<li><p>Tester les interactions entre workflows</p></li>
<li><p>Simuler des scénarios d’erreur pour valider les mécanismes de récupération</p></li>
</ul>
</li>
<li><p>Documentation Continue</p>
<ul class="simple">
<li><p>Documenter chaque workflow au fur et à mesure de son développement</p></li>
<li><p>Maintenir à jour les guides d’interface et de migration</p></li>
<li><p>Créer des diagrammes pour visualiser les interactions entre workflows</p></li>
</ul>
</li>
<li><p>Considérations de Performance</p>
<ul class="simple">
<li><p>Optimiser les workflows qui s’exécutent fréquemment</p></li>
<li><p>Mettre en place des mécanismes de cache pour les données fréquemment utilisées</p></li>
<li><p>Surveiller l’utilisation des ressources et ajuster les configurations en conséquence</p></li>
</ul>
</li>
</ol>
<p>En suivant ce plan détaillé, l’équipe de développement pourra mettre en place une infrastructure robuste et évolutive, prête à accueillir les fonctionnalités avancées du Plan Magistral V5.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, EMAIL_SENDER_1 Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>