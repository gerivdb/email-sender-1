

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Guide de segmentation des entrées &mdash; EMAIL_SENDER_1 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            EMAIL_SENDER_1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contenu:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">Documentation des API</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Guides d’utilisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technical/index.html">Documentation technique</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">EMAIL_SENDER_1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Guide de segmentation des entrées</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/guides/input_segmentation.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="guide-de-segmentation-des-entrees">
<h1>Guide de segmentation des entrées<a class="headerlink" href="#guide-de-segmentation-des-entrees" title="Link to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>La segmentation des entrées est une technique essentielle pour traiter efficacement de grandes quantités de données qui dépassent les limites de taille imposées par certains outils ou API. Le module <code class="docutils literal notranslate"><span class="pre">InputSegmenter</span></code> fournit des outils puissants pour segmenter automatiquement les entrées volumineuses en morceaux plus petits et gérables, tout en préservant leur structure et leur contexte.</p>
<p>Ce guide vous expliquera comment utiliser efficacement le module <code class="docutils literal notranslate"><span class="pre">InputSegmenter</span></code> pour gérer les entrées volumineuses dans vos projets.</p>
</section>
<section id="prerequis">
<h2>Prérequis<a class="headerlink" href="#prerequis" title="Link to this heading"></a></h2>
<p>Avant de commencer, assurez-vous de disposer des éléments suivants :</p>
<ul class="simple">
<li><p>PowerShell 5.1 ou PowerShell 7+ installé</p></li>
<li><p>Le module <code class="docutils literal notranslate"><span class="pre">InputSegmenter.psm1</span></code> disponible dans votre projet</p></li>
<li><p>Connaissances de base sur les types de données (texte, JSON, fichiers)</p></li>
</ul>
</section>
<section id="installation-et-configuration">
<h2>Installation et configuration<a class="headerlink" href="#installation-et-configuration" title="Link to this heading"></a></h2>
<section id="installation-du-module">
<h3>Installation du module<a class="headerlink" href="#installation-du-module" title="Link to this heading"></a></h3>
<p>Pour utiliser le module <code class="docutils literal notranslate"><span class="pre">InputSegmenter</span></code>, vous devez d’abord l’importer dans votre session PowerShell :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Importer le module</span>
<span class="nb">Import-Module</span> <span class="n">-Path</span> <span class="s2">&quot;.\modules\InputSegmenter.psm1&quot;</span> <span class="n">-Force</span>
</pre></div>
</div>
</section>
<section id="initialisation-du-module">
<h3>Initialisation du module<a class="headerlink" href="#initialisation-du-module" title="Link to this heading"></a></h3>
<p>Après avoir importé le module, vous devez l’initialiser avec les paramètres souhaités :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Initialisation avec les paramètres par défaut</span>
<span class="nb">Initialize-InputSegmentation</span>

<span class="c"># Ou avec des paramètres personnalisés</span>
<span class="nb">Initialize-InputSegmentation</span> <span class="n">-Enabled</span> <span class="nv">$true</span> <span class="n">-MaxInputSizeKB</span> <span class="n">200</span> <span class="n">-SegmentSizeKB</span> <span class="n">100</span> <span class="n">-OverlapSizeKB</span> <span class="n">10</span> <span class="n">-StateStoragePath</span> <span class="s2">&quot;.\data\segmentation&quot;</span>
</pre></div>
</div>
<p>Les paramètres disponibles sont :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Enabled</span></code> : Active ou désactive la segmentation des entrées (par défaut : $true)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxInputSizeKB</span></code> : Taille maximale d’entrée en kilo-octets avant segmentation (par défaut : 100)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SegmentSizeKB</span></code> : Taille de chaque segment en kilo-octets (par défaut : 50)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OverlapSizeKB</span></code> : Taille de chevauchement entre segments en kilo-octets (par défaut : 5)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StateStoragePath</span></code> : Chemin du dossier de stockage de l’état de segmentation (par défaut : “.\temp\segmentation”)</p></li>
</ul>
</section>
</section>
<section id="concepts-de-base">
<h2>Concepts de base<a class="headerlink" href="#concepts-de-base" title="Link to this heading"></a></h2>
<section id="pourquoi-segmenter-les-entrees">
<h3>Pourquoi segmenter les entrées ?<a class="headerlink" href="#pourquoi-segmenter-les-entrees" title="Link to this heading"></a></h3>
<p>La segmentation des entrées est nécessaire dans plusieurs cas :</p>
<ol class="simple">
<li><p><strong>Limites de taille des API</strong> : De nombreuses API imposent des limites sur la taille des requêtes.</p></li>
<li><p><strong>Traitement par lots</strong> : Certains traitements sont plus efficaces lorsqu’ils sont effectués par lots.</p></li>
<li><p><strong>Gestion de la mémoire</strong> : Éviter les problèmes de mémoire lors du traitement de grandes quantités de données.</p></li>
<li><p><strong>Parallélisation</strong> : Permettre le traitement parallèle des segments pour améliorer les performances.</p></li>
</ol>
</section>
<section id="types-de-segmentation">
<h3>Types de segmentation<a class="headerlink" href="#types-de-segmentation" title="Link to this heading"></a></h3>
<p>Le module <code class="docutils literal notranslate"><span class="pre">InputSegmenter</span></code> prend en charge plusieurs types de segmentation :</p>
<ol class="simple">
<li><p><strong>Segmentation de texte</strong> : Divise un texte en segments plus petits, avec possibilité de préserver les paragraphes.</p></li>
<li><p><strong>Segmentation de JSON</strong> : Divise un objet JSON en segments plus petits, avec possibilité de préserver la structure.</p></li>
<li><p><strong>Segmentation de fichiers</strong> : Divise un fichier en segments plus petits, avec détection automatique du format.</p></li>
</ol>
</section>
</section>
<section id="utilisation-de-base">
<h2>Utilisation de base<a class="headerlink" href="#utilisation-de-base" title="Link to this heading"></a></h2>
<section id="mesure-de-la-taille-des-entrees">
<h3>Mesure de la taille des entrées<a class="headerlink" href="#mesure-de-la-taille-des-entrees" title="Link to this heading"></a></h3>
<p>Avant de segmenter une entrée, vous pouvez mesurer sa taille pour déterminer si la segmentation est nécessaire :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Mesurer la taille d&#39;une chaîne de caractères</span>
<span class="nv">$text</span> <span class="p">=</span> <span class="s2">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. &quot;</span> <span class="p">*</span> <span class="n">1000</span>
<span class="nv">$textSize</span> <span class="p">=</span> <span class="nb">Measure-InputSize</span> <span class="n">-Input</span> <span class="nv">$text</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Taille du texte: </span><span class="p">$(</span><span class="nv">$textSize</span><span class="p">.</span><span class="n">SizeKB</span><span class="p">)</span><span class="s2"> KB&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Segmentation nécessaire: </span><span class="p">$(</span><span class="nv">$textSize</span><span class="p">.</span><span class="n">NeedsSegmentation</span><span class="p">)</span><span class="s2">&quot;</span>

<span class="c"># Mesurer la taille d&#39;un fichier</span>
<span class="nv">$fileSize</span> <span class="p">=</span> <span class="nb">Measure-InputSize</span> <span class="n">-Input</span> <span class="s2">&quot;.\data\large_file.json&quot;</span> <span class="n">-InputType</span> <span class="s2">&quot;File&quot;</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Taille du fichier: </span><span class="p">$(</span><span class="nv">$fileSize</span><span class="p">.</span><span class="n">SizeKB</span><span class="p">)</span><span class="s2"> KB&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Segmentation nécessaire: </span><span class="p">$(</span><span class="nv">$fileSize</span><span class="p">.</span><span class="n">NeedsSegmentation</span><span class="p">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>Les paramètres disponibles sont :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Input</span></code> : L’entrée à mesurer (chaîne de caractères, objet JSON, fichier, etc.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InputType</span></code> : Type d’entrée (Text, JSON, File, Object)</p></li>
</ul>
</section>
<section id="segmentation-de-texte">
<h3>Segmentation de texte<a class="headerlink" href="#segmentation-de-texte" title="Link to this heading"></a></h3>
<p>Pour segmenter un texte en morceaux plus petits, utilisez la fonction <code class="docutils literal notranslate"><span class="pre">Split-TextInput</span></code> :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Segmenter un texte</span>
<span class="nv">$text</span> <span class="p">=</span> <span class="s2">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. &quot;</span> <span class="p">*</span> <span class="n">1000</span>
<span class="nv">$segments</span> <span class="p">=</span> <span class="nb">Split-TextInput</span> <span class="n">-Text</span> <span class="nv">$text</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-OverlapSizeKB</span> <span class="n">1</span> <span class="n">-PreserveParagraphs</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de segments: </span><span class="p">$(</span><span class="nv">$segments</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>

<span class="c"># Afficher les premiers caractères de chaque segment</span>
<span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="p">=</span> <span class="n">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">-lt</span> <span class="nv">$segments</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="nv">$i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="nv">$preview</span> <span class="p">=</span> <span class="nv">$segments</span><span class="p">[</span><span class="nv">$i</span><span class="p">].</span><span class="n">Substring</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="no">[Math]</span><span class="p">::</span><span class="n">Min</span><span class="p">(</span><span class="n">50</span><span class="p">,</span> <span class="nv">$segments</span><span class="p">[</span><span class="nv">$i</span><span class="p">].</span><span class="n">Length</span><span class="p">))</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Segment </span><span class="p">$(</span><span class="nv">$i</span><span class="p">+</span><span class="n">1</span><span class="p">)</span><span class="s2">: $preview...&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Les paramètres disponibles sont :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Text</span></code> : Le texte à segmenter</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SegmentSizeKB</span></code> : Taille de chaque segment en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OverlapSizeKB</span></code> : Taille de chevauchement entre segments en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PreserveParagraphs</span></code> : Préserve les paragraphes lors de la segmentation</p></li>
</ul>
</section>
<section id="segmentation-de-json">
<h3>Segmentation de JSON<a class="headerlink" href="#segmentation-de-json" title="Link to this heading"></a></h3>
<p>Pour segmenter un objet JSON en morceaux plus petits, utilisez la fonction <code class="docutils literal notranslate"><span class="pre">Split-JsonInput</span></code> :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Créer un objet JSON avec un grand tableau</span>
<span class="nv">$largeArray</span> <span class="p">=</span> <span class="p">@()</span>
<span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="p">=</span> <span class="n">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">-lt</span> <span class="n">1000</span><span class="p">;</span> <span class="nv">$i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="nv">$largeArray</span> <span class="p">+=</span> <span class="p">@{</span>
        <span class="n">id</span> <span class="p">=</span> <span class="nv">$i</span>
        <span class="n">name</span> <span class="p">=</span> <span class="s2">&quot;Item $i&quot;</span>
        <span class="n">description</span> <span class="p">=</span> <span class="s2">&quot;Description of item $i&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nv">$jsonObject</span> <span class="p">=</span> <span class="p">@{</span>
    <span class="n">items</span> <span class="p">=</span> <span class="nv">$largeArray</span>
    <span class="n">metadata</span> <span class="p">=</span> <span class="p">@{</span>
        <span class="n">count</span> <span class="p">=</span> <span class="nv">$largeArray</span><span class="p">.</span><span class="n">Count</span>
        <span class="nb">type </span><span class="p">=</span> <span class="s2">&quot;test&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c"># Segmenter l&#39;objet JSON</span>
<span class="nv">$jsonSegments</span> <span class="p">=</span> <span class="nb">Split-JsonInput</span> <span class="n">-Json</span> <span class="nv">$jsonObject</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-PreserveStructure</span> <span class="n">-SplitArrays</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de segments JSON: </span><span class="p">$(</span><span class="nv">$jsonSegments</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>

<span class="c"># Afficher la structure de chaque segment</span>
<span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="p">=</span> <span class="n">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">-lt</span> <span class="nv">$jsonSegments</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="nv">$i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="nv">$segment</span> <span class="p">=</span> <span class="nv">$jsonSegments</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span>
    <span class="nv">$itemCount</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="nv">$segment</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$segment</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">Count</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">0</span> <span class="p">}</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Segment </span><span class="p">$(</span><span class="nv">$i</span><span class="p">+</span><span class="n">1</span><span class="p">)</span><span class="s2">: $itemCount items&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Les paramètres disponibles sont :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Json</span></code> : L’objet JSON à segmenter (chaîne de caractères ou objet déjà désérialisé)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SegmentSizeKB</span></code> : Taille de chaque segment en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PreserveStructure</span></code> : Préserve la structure JSON lors de la segmentation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SplitArrays</span></code> : Segmente les tableaux JSON</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SplitObjects</span></code> : Segmente les objets JSON</p></li>
</ul>
</section>
<section id="segmentation-de-fichiers">
<h3>Segmentation de fichiers<a class="headerlink" href="#segmentation-de-fichiers" title="Link to this heading"></a></h3>
<p>Pour segmenter un fichier en morceaux plus petits, utilisez la fonction <code class="docutils literal notranslate"><span class="pre">Split-FileInput</span></code> :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Segmenter un fichier texte</span>
<span class="nv">$segmentFiles</span> <span class="p">=</span> <span class="nb">Split-FileInput</span> <span class="n">-FilePath</span> <span class="s2">&quot;.\data\large_file.txt&quot;</span> <span class="n">-OutputDirectory</span> <span class="s2">&quot;.\data\segments&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">50</span> <span class="n">-DetectFormat</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de fichiers de segments créés: </span><span class="p">$(</span><span class="nv">$segmentFiles</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>

<span class="c"># Afficher les chemins des fichiers de segments</span>
<span class="k">foreach</span> <span class="p">(</span><span class="nv">$segmentFile</span> <span class="k">in</span> <span class="nv">$segmentFiles</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Fichier de segment: $segmentFile&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Les paramètres disponibles sont :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FilePath</span></code> : Chemin du fichier à segmenter</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OutputDirectory</span></code> : Dossier de sortie pour les segments</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SegmentSizeKB</span></code> : Taille de chaque segment en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OverlapSizeKB</span></code> : Taille de chevauchement entre segments en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DetectFormat</span></code> : Détecte automatiquement le format du fichier et utilise la méthode de segmentation appropriée</p></li>
</ul>
</section>
<section id="segmentation-generique">
<h3>Segmentation générique<a class="headerlink" href="#segmentation-generique" title="Link to this heading"></a></h3>
<p>Pour segmenter une entrée en fonction de son type, utilisez la fonction <code class="docutils literal notranslate"><span class="pre">Split-Input</span></code> :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Segmenter une entrée (type détecté automatiquement)</span>
<span class="nv">$input</span> <span class="p">=</span> <span class="nb">Get-Content</span> <span class="n">-Path</span> <span class="s2">&quot;.\data\large_file.json&quot;</span> <span class="n">-Raw</span>
<span class="nv">$segments</span> <span class="p">=</span> <span class="nb">Split-Input</span> <span class="n">-Input</span> <span class="nv">$input</span> <span class="n">-SegmentSizeKB</span> <span class="n">50</span> <span class="n">-PreserveStructure</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de segments: </span><span class="p">$(</span><span class="nv">$segments</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>

<span class="c"># Segmenter un fichier</span>
<span class="nv">$fileSegments</span> <span class="p">=</span> <span class="nb">Split-Input</span> <span class="n">-Input</span> <span class="s2">&quot;.\data\large_file.csv&quot;</span> <span class="n">-InputType</span> <span class="s2">&quot;File&quot;</span> <span class="n">-OutputDirectory</span> <span class="s2">&quot;.\data\segments&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">100</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de fichiers de segments créés: </span><span class="p">$(</span><span class="nv">$fileSegments</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>Les paramètres disponibles sont :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Input</span></code> : L’entrée à segmenter (chaîne de caractères, objet JSON, fichier, etc.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InputType</span></code> : Type d’entrée (Text, JSON, File, Object)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SegmentSizeKB</span></code> : Taille de chaque segment en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OverlapSizeKB</span></code> : Taille de chevauchement entre segments en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OutputDirectory</span></code> : Dossier de sortie pour les segments de fichiers</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PreserveStructure</span></code> : Préserve la structure lors de la segmentation</p></li>
</ul>
</section>
</section>
<section id="exemples-avances">
<h2>Exemples avancés<a class="headerlink" href="#exemples-avances" title="Link to this heading"></a></h2>
<section id="exemple-1-gestion-de-l-etat-de-segmentation">
<h3>Exemple 1 : Gestion de l’état de segmentation<a class="headerlink" href="#exemple-1-gestion-de-l-etat-de-segmentation" title="Link to this heading"></a></h3>
<p>Vous pouvez sauvegarder et récupérer l’état de segmentation pour une utilisation ultérieure :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Segmenter un texte</span>
<span class="nv">$text</span> <span class="p">=</span> <span class="s2">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. &quot;</span> <span class="p">*</span> <span class="n">1000</span>
<span class="nv">$segments</span> <span class="p">=</span> <span class="nb">Split-TextInput</span> <span class="n">-Text</span> <span class="nv">$text</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span>

<span class="c"># Créer un état de segmentation</span>
<span class="nv">$state</span> <span class="p">=</span> <span class="p">@{</span>
    <span class="n">OriginalInput</span> <span class="p">=</span> <span class="nv">$text</span>
    <span class="n">Segments</span> <span class="p">=</span> <span class="nv">$segments</span>
    <span class="n">CurrentSegmentIndex</span> <span class="p">=</span> <span class="n">0</span>
    <span class="n">TotalSegments</span> <span class="p">=</span> <span class="nv">$segments</span><span class="p">.</span><span class="n">Count</span>
    <span class="n">Timestamp</span> <span class="p">=</span> <span class="nb">Get-Date</span>
<span class="p">}</span>

<span class="c"># Sauvegarder l&#39;état</span>
<span class="nv">$stateId</span> <span class="p">=</span> <span class="nb">Save-SegmentationState</span> <span class="n">-State</span> <span class="nv">$state</span> <span class="n">-StoragePath</span> <span class="s2">&quot;.\data\segmentation_states&quot;</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;État de segmentation sauvegardé avec l&#39;ID: $stateId&quot;</span>

<span class="c"># Récupérer l&#39;état</span>
<span class="nv">$retrievedState</span> <span class="p">=</span> <span class="nb">Get-SegmentationState</span> <span class="n">-StateId</span> <span class="nv">$stateId</span> <span class="n">-StoragePath</span> <span class="s2">&quot;.\data\segmentation_states&quot;</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$retrievedState</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;État de segmentation récupéré&quot;</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Nombre total de segments: </span><span class="p">$(</span><span class="nv">$retrievedState</span><span class="p">.</span><span class="n">TotalSegments</span><span class="p">)</span><span class="s2">&quot;</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Segment actuel: </span><span class="p">$(</span><span class="nv">$retrievedState</span><span class="p">.</span><span class="n">CurrentSegmentIndex</span> <span class="p">+</span> <span class="n">1</span><span class="p">)</span><span class="s2">&quot;</span>
    
    <span class="c"># Utiliser le segment actuel</span>
    <span class="nv">$currentSegment</span> <span class="p">=</span> <span class="nv">$retrievedState</span><span class="p">.</span><span class="n">Segments</span><span class="p">[</span><span class="nv">$retrievedState</span><span class="p">.</span><span class="n">CurrentSegmentIndex</span><span class="p">]</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Taille du segment actuel: </span><span class="p">$(</span><span class="no">[Math]</span><span class="p">::</span><span class="n">Round</span><span class="p">(((</span><span class="no">[System.Text.Encoding]</span><span class="p">::</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="nv">$currentSegment</span><span class="p">)).</span><span class="n">Length</span> <span class="p">/</span> <span class="n">1024</span><span class="p">),</span> <span class="n">2</span><span class="p">))</span><span class="s2"> KB&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="exemple-2-traitement-par-lots-avec-segmentation">
<h3>Exemple 2 : Traitement par lots avec segmentation<a class="headerlink" href="#exemple-2-traitement-par-lots-avec-segmentation" title="Link to this heading"></a></h3>
<p>Vous pouvez utiliser la fonction <code class="docutils literal notranslate"><span class="pre">Invoke-WithSegmentation</span></code> pour exécuter un bloc de script sur chaque segment :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Fonction de traitement qui compte les mots dans un texte</span>
<span class="k">function</span> <span class="n">Count-Words</span> <span class="p">{</span>
    <span class="k">param</span> <span class="p">(</span>
        <span class="no">[string]</span><span class="nv">$Text</span>
    <span class="p">)</span>
    
    <span class="nv">$words</span> <span class="p">=</span> <span class="nv">$Text</span> <span class="n">-split</span> <span class="s1">&#39;\W+&#39;</span> <span class="p">|</span> <span class="nb">Where-Object</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">-ne</span> <span class="s1">&#39;&#39;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$words</span><span class="p">.</span><span class="n">Count</span>
<span class="p">}</span>

<span class="c"># Texte volumineux</span>
<span class="nv">$text</span> <span class="p">=</span> <span class="s2">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. &quot;</span> <span class="p">*</span> <span class="n">1000</span>

<span class="c"># Compter les mots avec segmentation</span>
<span class="nv">$wordCounts</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$text</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Count-Words</span> <span class="n">-Text</span> <span class="nv">$segment</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-CombineResults</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre total de mots: $wordCounts&quot;</span>

<span class="c"># Traitement plus complexe avec JSON</span>
<span class="nv">$largeJson</span> <span class="p">=</span> <span class="p">@{</span>
    <span class="n">items</span> <span class="p">=</span> <span class="n">1</span><span class="p">..</span><span class="n">1000</span> <span class="p">|</span> <span class="k">ForEach</span><span class="n">-Object</span> <span class="p">{</span>
        <span class="p">@{</span>
            <span class="n">id</span> <span class="p">=</span> <span class="nv">$_</span>
            <span class="n">name</span> <span class="p">=</span> <span class="s2">&quot;Item $_&quot;</span>
            <span class="n">value</span> <span class="p">=</span> <span class="nv">$_</span> <span class="p">*</span> <span class="n">10</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c"># Calculer la somme des valeurs</span>
<span class="nv">$results</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$largeJson</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    
    <span class="nv">$sum</span> <span class="p">=</span> <span class="n">0</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$segment</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$item</span> <span class="k">in</span> <span class="nv">$segment</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$sum</span> <span class="p">+=</span> <span class="nv">$item</span><span class="p">.</span><span class="n">value</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nv">$sum</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;JSON&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-PreserveStructure</span>

<span class="nv">$totalSum</span> <span class="p">=</span> <span class="p">(</span><span class="nv">$results</span> <span class="p">|</span> <span class="nb">Measure-Object</span> <span class="n">-Sum</span><span class="p">).</span><span class="n">Sum</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Somme totale des valeurs: $totalSum&quot;</span>
</pre></div>
</div>
<p>Les paramètres disponibles sont :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Input</span></code> : L’entrée à segmenter et à traiter</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ScriptBlock</span></code> : Le bloc de script à exécuter sur chaque segment</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InputType</span></code> : Type d’entrée (Text, JSON, File, Object)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SegmentSizeKB</span></code> : Taille de chaque segment en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OverlapSizeKB</span></code> : Taille de chevauchement entre segments en kilo-octets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PreserveStructure</span></code> : Préserve la structure lors de la segmentation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CombineResults</span></code> : Combine les résultats de chaque segment en un seul résultat</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ContinueOnError</span></code> : Continue l’exécution même si une erreur se produit lors du traitement d’un segment</p></li>
</ul>
</section>
<section id="exemple-3-traitement-parallele-avec-segmentation">
<h3>Exemple 3 : Traitement parallèle avec segmentation<a class="headerlink" href="#exemple-3-traitement-parallele-avec-segmentation" title="Link to this heading"></a></h3>
<p>Vous pouvez combiner la segmentation avec le traitement parallèle pour améliorer les performances :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Fonction de traitement qui simule un traitement intensif</span>
<span class="k">function</span> <span class="k">Process</span><span class="n">-Data</span> <span class="p">{</span>
    <span class="k">param</span> <span class="p">(</span>
        <span class="no">[string]</span><span class="nv">$Data</span>
    <span class="p">)</span>
    
    <span class="c"># Simuler un traitement intensif</span>
    <span class="nb">Start-Sleep</span> <span class="n">-Milliseconds</span> <span class="n">500</span>
    
    <span class="c"># Compter les caractères</span>
    <span class="k">return</span> <span class="nv">$Data</span><span class="p">.</span><span class="n">Length</span>
<span class="p">}</span>

<span class="c"># Créer des données volumineuses</span>
<span class="nv">$data</span> <span class="p">=</span> <span class="s2">&quot;X&quot;</span> <span class="p">*</span> <span class="n">1000000</span>  <span class="c"># Environ 1 MB de données</span>

<span class="c"># Mesurer la taille des données</span>
<span class="nv">$dataSize</span> <span class="p">=</span> <span class="nb">Measure-InputSize</span> <span class="n">-Input</span> <span class="nv">$data</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Taille des données: </span><span class="p">$(</span><span class="nv">$dataSize</span><span class="p">.</span><span class="n">SizeKB</span><span class="p">)</span><span class="s2"> KB&quot;</span>

<span class="c"># Traitement séquentiel avec segmentation</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;</span><span class="se">`n</span><span class="s2">Traitement séquentiel avec segmentation:&quot;</span>
<span class="nv">$startTime</span> <span class="p">=</span> <span class="nb">Get-Date</span>
<span class="nv">$results</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$data</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">Process</span><span class="n">-Data</span> <span class="n">-Data</span> <span class="nv">$segment</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">100</span>
<span class="nv">$totalProcessed</span> <span class="p">=</span> <span class="p">(</span><span class="nv">$results</span> <span class="p">|</span> <span class="nb">Measure-Object</span> <span class="n">-Sum</span><span class="p">).</span><span class="n">Sum</span>
<span class="nv">$endTime</span> <span class="p">=</span> <span class="nb">Get-Date</span>
<span class="nv">$sequentialTime</span> <span class="p">=</span> <span class="p">(</span><span class="nv">$endTime</span> <span class="p">-</span> <span class="nv">$startTime</span><span class="p">).</span><span class="n">TotalSeconds</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre total de caractères traités: $totalProcessed&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Temps d&#39;exécution: $sequentialTime secondes&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de segments traités: </span><span class="p">$(</span><span class="nv">$results</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>

<span class="c"># Traitement parallèle avec segmentation</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;</span><span class="se">`n</span><span class="s2">Traitement parallèle avec segmentation:&quot;</span>
<span class="nv">$startTime</span> <span class="p">=</span> <span class="nb">Get-Date</span>

<span class="c"># Segmenter les données</span>
<span class="nv">$segments</span> <span class="p">=</span> <span class="nb">Split-TextInput</span> <span class="n">-Text</span> <span class="nv">$data</span> <span class="n">-SegmentSizeKB</span> <span class="n">100</span>

<span class="c"># Traiter les segments en parallèle</span>
<span class="nv">$parallelResults</span> <span class="p">=</span> <span class="nv">$segments</span> <span class="p">|</span> <span class="k">ForEach</span><span class="n">-Object</span> <span class="n">-Parallel</span> <span class="p">{</span>
    <span class="c"># Importer la fonction dans le runspace</span>
    <span class="k">function</span> <span class="k">Process</span><span class="n">-Data</span> <span class="p">{</span>
        <span class="k">param</span> <span class="p">(</span>
            <span class="no">[string]</span><span class="nv">$Data</span>
        <span class="p">)</span>
        
        <span class="c"># Simuler un traitement intensif</span>
        <span class="nb">Start-Sleep</span> <span class="n">-Milliseconds</span> <span class="n">500</span>
        
        <span class="c"># Compter les caractères</span>
        <span class="k">return</span> <span class="nv">$Data</span><span class="p">.</span><span class="n">Length</span>
    <span class="p">}</span>
    
    <span class="c"># Traiter le segment</span>
    <span class="k">Process</span><span class="n">-Data</span> <span class="n">-Data</span> <span class="nv">$_</span>
<span class="p">}</span> <span class="n">-ThrottleLimit</span> <span class="n">10</span>

<span class="nv">$totalProcessedParallel</span> <span class="p">=</span> <span class="p">(</span><span class="nv">$parallelResults</span> <span class="p">|</span> <span class="nb">Measure-Object</span> <span class="n">-Sum</span><span class="p">).</span><span class="n">Sum</span>
<span class="nv">$endTime</span> <span class="p">=</span> <span class="nb">Get-Date</span>
<span class="nv">$parallelTime</span> <span class="p">=</span> <span class="p">(</span><span class="nv">$endTime</span> <span class="p">-</span> <span class="nv">$startTime</span><span class="p">).</span><span class="n">TotalSeconds</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre total de caractères traités: $totalProcessedParallel&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Temps d&#39;exécution: $parallelTime secondes&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de segments traités: </span><span class="p">$(</span><span class="nv">$segments</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Accélération: </span><span class="p">$(</span><span class="no">[Math]</span><span class="p">::</span><span class="n">Round</span><span class="p">(</span><span class="nv">$sequentialTime</span> <span class="p">/</span> <span class="nv">$parallelTime</span><span class="p">,</span> <span class="n">2</span><span class="p">))</span><span class="s2">x&quot;</span>
</pre></div>
</div>
</section>
<section id="exemple-4-integration-avec-une-api-externe">
<h3>Exemple 4 : Intégration avec une API externe<a class="headerlink" href="#exemple-4-integration-avec-une-api-externe" title="Link to this heading"></a></h3>
<p>Vous pouvez utiliser la segmentation pour interagir avec des API qui imposent des limites de taille :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Fonction simulant un appel à une API externe avec une limite de taille</span>
<span class="k">function</span> <span class="nb">Invoke-ExternalAPI</span> <span class="p">{</span>
    <span class="k">param</span> <span class="p">(</span>
        <span class="no">[string]</span><span class="nv">$Data</span><span class="p">,</span>
        <span class="no">[int]</span><span class="nv">$MaxSizeKB</span> <span class="p">=</span> <span class="n">2</span>
    <span class="p">)</span>
    
    <span class="c"># Vérifier la taille des données</span>
    <span class="nv">$dataBytes</span> <span class="p">=</span> <span class="no">[System.Text.Encoding]</span><span class="p">::</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="nv">$Data</span><span class="p">)</span>
    <span class="nv">$dataSizeKB</span> <span class="p">=</span> <span class="nv">$dataBytes</span><span class="p">.</span><span class="n">Length</span> <span class="p">/</span> <span class="n">1024</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nv">$dataSizeKB</span> <span class="o">-gt</span> <span class="nv">$MaxSizeKB</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">Write-Error</span> <span class="s2">&quot;Les données dépassent la taille maximale autorisée de $MaxSizeKB KB (taille actuelle: </span><span class="p">$(</span><span class="no">[Math]</span><span class="p">::</span><span class="n">Round</span><span class="p">(</span><span class="nv">$dataSizeKB</span><span class="p">,</span> <span class="n">2</span><span class="p">))</span><span class="s2"> KB)&quot;</span>
        <span class="k">return</span> <span class="nv">$null</span>
    <span class="p">}</span>
    
    <span class="c"># Simuler un traitement par l&#39;API</span>
    <span class="nb">Start-Sleep</span> <span class="n">-Milliseconds</span> <span class="n">200</span>
    
    <span class="c"># Retourner un résultat simulé</span>
    <span class="k">return</span> <span class="p">@{</span>
        <span class="n">status</span> <span class="p">=</span> <span class="s2">&quot;success&quot;</span>
        <span class="n">processed_size_kb</span> <span class="p">=</span> <span class="nv">$dataSizeKB</span>
        <span class="n">word_count</span> <span class="p">=</span> <span class="p">(</span><span class="nv">$Data</span> <span class="n">-split</span> <span class="s1">&#39;\W+&#39;</span><span class="p">).</span><span class="n">Count</span>
        <span class="n">character_count</span> <span class="p">=</span> <span class="nv">$Data</span><span class="p">.</span><span class="n">Length</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c"># Créer un texte volumineux</span>
<span class="nv">$text</span> <span class="p">=</span> <span class="s2">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. &quot;</span> <span class="p">*</span> <span class="n">100</span>

<span class="c"># Mesurer la taille du texte</span>
<span class="nv">$textSize</span> <span class="p">=</span> <span class="nb">Measure-InputSize</span> <span class="n">-Input</span> <span class="nv">$text</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Taille du texte: </span><span class="p">$(</span><span class="nv">$textSize</span><span class="p">.</span><span class="n">SizeKB</span><span class="p">)</span><span class="s2"> KB&quot;</span>

<span class="c"># Essayer d&#39;appeler l&#39;API directement (devrait échouer)</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;</span><span class="se">`n</span><span class="s2">Appel direct à l&#39;API (sans segmentation):&quot;</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="nv">$result</span> <span class="p">=</span> <span class="nb">Invoke-ExternalAPI</span> <span class="n">-Data</span> <span class="nv">$text</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Résultat: </span><span class="p">$(</span><span class="nv">$result</span> <span class="p">|</span> <span class="nb">ConvertTo-Json</span> <span class="n">-Compress</span><span class="p">)</span><span class="s2">&quot;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Erreur: $_&quot;</span>
<span class="p">}</span>

<span class="c"># Appeler l&#39;API avec segmentation</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;</span><span class="se">`n</span><span class="s2">Appel à l&#39;API avec segmentation:&quot;</span>
<span class="nv">$apiResults</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$text</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">Invoke-ExternalAPI</span> <span class="n">-Data</span> <span class="nv">$segment</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">2</span> <span class="n">-ContinueOnError</span>

<span class="c"># Afficher les résultats</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre d&#39;appels à l&#39;API: </span><span class="p">$(</span><span class="nv">$apiResults</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>

<span class="nv">$totalWords</span> <span class="p">=</span> <span class="n">0</span>
<span class="nv">$totalChars</span> <span class="p">=</span> <span class="n">0</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$result</span> <span class="k">in</span> <span class="nv">$apiResults</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$totalWords</span> <span class="p">+=</span> <span class="nv">$result</span><span class="p">.</span><span class="n">word_count</span>
    <span class="nv">$totalChars</span> <span class="p">+=</span> <span class="nv">$result</span><span class="p">.</span><span class="n">character_count</span>
<span class="p">}</span>

<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre total de mots traités: $totalWords&quot;</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Nombre total de caractères traités: $totalChars&quot;</span>

<span class="c"># Calculer les statistiques</span>
<span class="nv">$averageSize</span> <span class="p">=</span> <span class="p">(</span><span class="nv">$apiResults</span> <span class="p">|</span> <span class="nb">Measure-Object</span> <span class="n">-Property</span> <span class="n">processed_size_kb</span> <span class="n">-Average</span><span class="p">).</span><span class="n">Average</span>
<span class="nb">Write-Host</span> <span class="s2">&quot;Taille moyenne des segments: </span><span class="p">$(</span><span class="no">[Math]</span><span class="p">::</span><span class="n">Round</span><span class="p">(</span><span class="nv">$averageSize</span><span class="p">,</span> <span class="n">2</span><span class="p">))</span><span class="s2"> KB&quot;</span>
</pre></div>
</div>
</section>
</section>
<section id="integration-avec-d-autres-modules">
<h2>Intégration avec d’autres modules<a class="headerlink" href="#integration-avec-d-autres-modules" title="Link to this heading"></a></h2>
<section id="integration-avec-le-module-mcpmanager">
<h3>Intégration avec le module MCPManager<a class="headerlink" href="#integration-avec-le-module-mcpmanager" title="Link to this heading"></a></h3>
<p>Vous pouvez intégrer le module <code class="docutils literal notranslate"><span class="pre">InputSegmenter</span></code> avec le module <code class="docutils literal notranslate"><span class="pre">MCPManager</span></code> pour traiter des entrées volumineuses avec MCP :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="c"># Importer les modules</span>
<span class="nb">Import-Module</span> <span class="n">-Path</span> <span class="s2">&quot;.\modules\InputSegmenter.psm1&quot;</span> <span class="n">-Force</span>
<span class="nb">Import-Module</span> <span class="n">-Path</span> <span class="s2">&quot;.\modules\MCPManager.psm1&quot;</span> <span class="n">-Force</span>

<span class="c"># Initialiser les modules</span>
<span class="nb">Initialize-InputSegmentation</span>
<span class="nb">Initialize-MCPManager</span>

<span class="c"># Démarrer un serveur MCP local</span>
<span class="nv">$server</span> <span class="p">=</span> <span class="nb">Start-MCPServer</span> <span class="n">-ServerType</span> <span class="s2">&quot;local&quot;</span> <span class="n">-Port</span> <span class="n">8000</span> <span class="n">-Wait</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$server</span><span class="p">.</span><span class="n">Status</span> <span class="o">-eq</span> <span class="s2">&quot;running&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Serveur MCP démarré avec succès: </span><span class="p">$(</span><span class="nv">$server</span><span class="p">.</span><span class="n">Url</span><span class="p">)</span><span class="s2">&quot;</span>
    
    <span class="c"># Créer un texte volumineux</span>
    <span class="nv">$text</span> <span class="p">=</span> <span class="s2">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. &quot;</span> <span class="p">*</span> <span class="n">1000</span>
    
    <span class="c"># Segmenter le texte</span>
    <span class="nv">$segments</span> <span class="p">=</span> <span class="nb">Split-TextInput</span> <span class="n">-Text</span> <span class="nv">$text</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span>
    
    <span class="nb">Write-Host</span> <span class="s2">&quot;Nombre de segments: </span><span class="p">$(</span><span class="nv">$segments</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2">&quot;</span>
    
    <span class="c"># Traiter chaque segment avec MCP</span>
    <span class="nv">$results</span> <span class="p">=</span> <span class="p">@()</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$segment</span> <span class="k">in</span> <span class="nv">$segments</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$result</span> <span class="p">=</span> <span class="nb">Invoke-MCPCommand</span> <span class="n">-Command</span> <span class="s2">&quot;process_text&quot;</span> <span class="n">-Parameters</span> <span class="p">@{</span> 
            <span class="n">text</span> <span class="p">=</span> <span class="nv">$segment</span>
        <span class="p">}</span> <span class="n">-ServerType</span> <span class="s2">&quot;local&quot;</span> <span class="n">-Port</span> <span class="n">8000</span>
        
        <span class="nv">$results</span> <span class="p">+=</span> <span class="nv">$result</span>
    <span class="p">}</span>
    
    <span class="nb">Write-Host</span> <span class="s2">&quot;Résultats du traitement: </span><span class="p">$(</span><span class="nv">$results</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span><span class="s2"> segments traités&quot;</span>
    
    <span class="c"># Arrêter le serveur</span>
    <span class="nv">$stopped</span> <span class="p">=</span> <span class="nb">Stop-MCPServer</span> <span class="n">-ServerType</span> <span class="s2">&quot;local&quot;</span> <span class="n">-Port</span> <span class="n">8000</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nv">$stopped</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">Write-Host</span> <span class="s2">&quot;Serveur MCP arrêté avec succès&quot;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">Write-Host</span> <span class="s2">&quot;Erreur lors de l&#39;arrêt du serveur MCP&quot;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">Write-Host</span> <span class="s2">&quot;Erreur lors du démarrage du serveur MCP: </span><span class="p">$(</span><span class="nv">$server</span><span class="p">.</span><span class="n">Error</span><span class="p">)</span><span class="s2">&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="depannage">
<h2>Dépannage<a class="headerlink" href="#depannage" title="Link to this heading"></a></h2>
<section id="probleme-segmentation-incorrecte-du-texte">
<h3>Problème : Segmentation incorrecte du texte<a class="headerlink" href="#probleme-segmentation-incorrecte-du-texte" title="Link to this heading"></a></h3>
<p>Si la segmentation du texte ne préserve pas correctement les paragraphes ou les phrases, utilisez le paramètre <code class="docutils literal notranslate"><span class="pre">PreserveParagraphs</span></code> :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="nv">$segments</span> <span class="p">=</span> <span class="nb">Split-TextInput</span> <span class="n">-Text</span> <span class="nv">$text</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-PreserveParagraphs</span>
</pre></div>
</div>
</section>
<section id="probleme-segmentation-incorrecte-du-json">
<h3>Problème : Segmentation incorrecte du JSON<a class="headerlink" href="#probleme-segmentation-incorrecte-du-json" title="Link to this heading"></a></h3>
<p>Si la segmentation du JSON ne préserve pas correctement la structure, utilisez le paramètre <code class="docutils literal notranslate"><span class="pre">PreserveStructure</span></code> :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="nv">$jsonSegments</span> <span class="p">=</span> <span class="nb">Split-JsonInput</span> <span class="n">-Json</span> <span class="nv">$jsonObject</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-PreserveStructure</span>
</pre></div>
</div>
</section>
<section id="probleme-erreurs-lors-de-la-segmentation-de-fichiers">
<h3>Problème : Erreurs lors de la segmentation de fichiers<a class="headerlink" href="#probleme-erreurs-lors-de-la-segmentation-de-fichiers" title="Link to this heading"></a></h3>
<p>Si vous rencontrez des erreurs lors de la segmentation de fichiers, vérifiez que vous avez les droits d’écriture dans le dossier de sortie et que le chemin est valide.</p>
</section>
</section>
<section id="bonnes-pratiques">
<h2>Bonnes pratiques<a class="headerlink" href="#bonnes-pratiques" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><strong>Adaptez la taille des segments</strong> à vos besoins spécifiques. Une taille trop petite peut entraîner un surcoût de traitement, tandis qu’une taille trop grande peut dépasser les limites.</p></li>
<li><p><strong>Utilisez le chevauchement</strong> pour préserver le contexte entre les segments, en particulier pour le traitement de texte.</p></li>
<li><p><strong>Préservez la structure</strong> lors de la segmentation de données structurées comme JSON.</p></li>
<li><p><strong>Sauvegardez l’état de segmentation</strong> pour les traitements longs ou susceptibles d’être interrompus.</p></li>
<li><p><strong>Combinez avec le traitement parallèle</strong> pour améliorer les performances sur les grands volumes de données.</p></li>
<li><p><strong>Testez avec des données réelles</strong> pour vous assurer que la segmentation fonctionne correctement dans votre cas d’utilisation.</p></li>
</ul>
</section>
<section id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Link to this heading"></a></h2>
<section id="quelle-est-la-difference-entre-split-textinput-split-jsoninput-et-split-fileinput">
<h3>Quelle est la différence entre Split-TextInput, Split-JsonInput et Split-FileInput ?<a class="headerlink" href="#quelle-est-la-difference-entre-split-textinput-split-jsoninput-et-split-fileinput" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Split-TextInput</span></code> est spécifique à la segmentation de texte et offre des options comme la préservation des paragraphes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Split-JsonInput</span></code> est spécifique à la segmentation d’objets JSON et offre des options comme la préservation de la structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Split-FileInput</span></code> est spécifique à la segmentation de fichiers et peut détecter automatiquement le format du fichier.</p></li>
</ul>
</section>
<section id="comment-choisir-la-taille-optimale-des-segments">
<h3>Comment choisir la taille optimale des segments ?<a class="headerlink" href="#comment-choisir-la-taille-optimale-des-segments" title="Link to this heading"></a></h3>
<p>La taille optimale des segments dépend de plusieurs facteurs :</p>
<ol class="simple">
<li><p><strong>Limites de l’API ou de l’outil</strong> : Respectez les limites imposées par l’API ou l’outil que vous utilisez.</p></li>
<li><p><strong>Nature des données</strong> : Pour le texte, essayez de préserver les paragraphes ou les phrases. Pour JSON, essayez de préserver la structure.</p></li>
<li><p><strong>Performances</strong> : Des segments trop petits peuvent entraîner un surcoût de traitement, tandis que des segments trop grands peuvent être inefficaces.</p></li>
<li><p><strong>Mémoire disponible</strong> : Assurez-vous que les segments peuvent être traités avec la mémoire disponible.</p></li>
</ol>
<p>En général, commencez avec une taille de segment de 50-100 KB et ajustez en fonction de vos besoins.</p>
</section>
<section id="comment-gerer-les-erreurs-lors-du-traitement-des-segments">
<h3>Comment gérer les erreurs lors du traitement des segments ?<a class="headerlink" href="#comment-gerer-les-erreurs-lors-du-traitement-des-segments" title="Link to this heading"></a></h3>
<p>Vous pouvez utiliser le paramètre <code class="docutils literal notranslate"><span class="pre">ContinueOnError</span></code> avec la fonction <code class="docutils literal notranslate"><span class="pre">Invoke-WithSegmentation</span></code> pour continuer le traitement même si une erreur se produit lors du traitement d’un segment :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="nv">$results</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$data</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    <span class="c"># Traitement qui peut échouer</span>
    <span class="k">return</span> <span class="k">Process</span><span class="n">-Data</span> <span class="n">-Data</span> <span class="nv">$segment</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-ContinueOnError</span>
</pre></div>
</div>
<p>Vous pouvez également implémenter votre propre gestion des erreurs dans le bloc de script :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="nv">$results</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$data</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">Process</span><span class="n">-Data</span> <span class="n">-Data</span> <span class="nv">$segment</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="nb">Write-Warning</span> <span class="s2">&quot;Erreur lors du traitement du segment: $_&quot;</span>
        <span class="k">return</span> <span class="nv">$null</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span>
</pre></div>
</div>
</section>
<section id="comment-combiner-les-resultats-du-traitement-des-segments">
<h3>Comment combiner les résultats du traitement des segments ?<a class="headerlink" href="#comment-combiner-les-resultats-du-traitement-des-segments" title="Link to this heading"></a></h3>
<p>Vous pouvez utiliser le paramètre <code class="docutils literal notranslate"><span class="pre">CombineResults</span></code> avec la fonction <code class="docutils literal notranslate"><span class="pre">Invoke-WithSegmentation</span></code> pour combiner automatiquement les résultats :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="nv">$combinedResult</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$data</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">Process</span><span class="n">-Data</span> <span class="n">-Data</span> <span class="nv">$segment</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span> <span class="n">-CombineResults</span>
</pre></div>
</div>
<p>Vous pouvez également implémenter votre propre logique de combinaison :</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="nv">$results</span> <span class="p">=</span> <span class="nb">Invoke-WithSegmentation</span> <span class="n">-Input</span> <span class="nv">$data</span> <span class="n">-ScriptBlock</span> <span class="p">{</span>
    <span class="k">param</span><span class="p">(</span><span class="nv">$segment</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">Process</span><span class="n">-Data</span> <span class="n">-Data</span> <span class="nv">$segment</span>
<span class="p">}</span> <span class="n">-InputType</span> <span class="s2">&quot;Text&quot;</span> <span class="n">-SegmentSizeKB</span> <span class="n">10</span>

<span class="c"># Combiner les résultats</span>
<span class="nv">$combinedResult</span> <span class="p">=</span> <span class="nv">$results</span> <span class="p">|</span> <span class="nb">Measure-Object</span> <span class="n">-Sum</span> <span class="p">|</span> <span class="nb">Select-Object</span> <span class="n">-ExpandProperty</span> <span class="n">Sum</span>
</pre></div>
</div>
</section>
</section>
<section id="ressources-supplementaires">
<h2>Ressources supplémentaires<a class="headerlink" href="#ressources-supplementaires" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="../api/InputSegmenter.html">Documentation API du module InputSegmenter</a></p></li>
<li><p><a class="reference external" href="../api/examples/InputSegmenter_Examples.html">Exemples d’utilisation du module InputSegmenter</a></p></li>
<li><p><a class="reference internal" href="../technical/InputSegmenter.html"><span class="doc">Documentation technique sur la segmentation des entrées</span></a></p></li>
<li><p><a class="reference internal" href="mcp_integration.html"><span class="doc">Guide d’intégration MCP</span></a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, EMAIL_SENDER_1 Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>