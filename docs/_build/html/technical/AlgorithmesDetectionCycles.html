

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Analyse des algorithmes de détection de cycles &mdash; EMAIL_SENDER_1 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            EMAIL_SENDER_1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contenu:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">Documentation des API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">EMAIL_SENDER_1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Analyse des algorithmes de détection de cycles</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/technical/AlgorithmesDetectionCycles.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="analyse-des-algorithmes-de-detection-de-cycles">
<h1>Analyse des algorithmes de détection de cycles<a class="headerlink" href="#analyse-des-algorithmes-de-detection-de-cycles" title="Link to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>Ce document présente une analyse comparative des différents algorithmes de détection de cycles dans les graphes. Cette analyse servira de base pour l’implémentation du module <code class="docutils literal notranslate"><span class="pre">CycleDetector.psm1</span></code>.</p>
</section>
<section id="algorithmes-etudies">
<h2>Algorithmes étudiés<a class="headerlink" href="#algorithmes-etudies" title="Link to this heading"></a></h2>
<section id="algorithme-de-recherche-en-profondeur-dfs-depth-first-search">
<h3>1. Algorithme de recherche en profondeur (DFS - Depth-First Search)<a class="headerlink" href="#algorithme-de-recherche-en-profondeur-dfs-depth-first-search" title="Link to this heading"></a></h3>
<section id="principe">
<h4>Principe<a class="headerlink" href="#principe" title="Link to this heading"></a></h4>
<p>L’algorithme DFS explore un graphe en profondeur d’abord, en suivant chaque chemin jusqu’à sa fin avant de revenir en arrière (backtracking). Pour détecter les cycles, on maintient deux ensembles :</p>
<ul class="simple">
<li><p>Un ensemble des nœuds visités</p></li>
<li><p>Un ensemble des nœuds actuellement dans la pile de récursion</p></li>
</ul>
<p>Si un nœud déjà présent dans la pile de récursion est rencontré, alors un cycle est détecté.</p>
</section>
<section id="pseudocode">
<h4>Pseudocode<a class="headerlink" href="#pseudocode" title="Link to this heading"></a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">DFS_CycleDetection</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">recursion_stack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">each</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DFS_Visit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">recursion_stack</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">true</span>  <span class="c1"># Cycle détecté</span>
    
    <span class="k">return</span> <span class="n">false</span>  <span class="c1"># Pas de cycle</span>

<span class="n">function</span> <span class="n">DFS_Visit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">recursion_stack</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">recursion_stack</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DFS_Visit</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">recursion_stack</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">true</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">recursion_stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">true</span>  <span class="c1"># Cycle détecté</span>
    
    <span class="n">recursion_stack</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">false</span>
</pre></div>
</div>
</section>
<section id="avantages">
<h4>Avantages<a class="headerlink" href="#avantages" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Efficacité</strong> : Complexité O(V+E) où V est le nombre de nœuds et E le nombre d’arêtes</p></li>
<li><p><strong>Simplicité</strong> : Facile à implémenter, surtout avec la récursion</p></li>
<li><p><strong>Détection précise</strong> : Identifie exactement les nœuds impliqués dans le cycle</p></li>
</ul>
</section>
<section id="inconvenients">
<h4>Inconvénients<a class="headerlink" href="#inconvenients" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Consommation de la pile</strong> : Peut causer un débordement de pile pour les graphes très profonds</p></li>
<li><p><strong>Non-parallélisable</strong> : Difficile à paralléliser en raison de sa nature récursive</p></li>
</ul>
</section>
</section>
<section id="algorithme-de-recherche-en-largeur-bfs-breadth-first-search">
<h3>2. Algorithme de recherche en largeur (BFS - Breadth-First Search)<a class="headerlink" href="#algorithme-de-recherche-en-largeur-bfs-breadth-first-search" title="Link to this heading"></a></h3>
<section id="id1">
<h4>Principe<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<p>L’algorithme BFS explore un graphe niveau par niveau. Pour détecter les cycles, on peut utiliser une variante qui maintient les distances depuis le nœud source. Si un nœud déjà visité est rencontré avec une distance inférieure à celle attendue, alors un cycle est détecté.</p>
</section>
<section id="id2">
<h4>Pseudocode<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">BFS_CycleDetection</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">BFS_Visit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">true</span>  <span class="c1"># Cycle détecté</span>
    
    <span class="k">return</span> <span class="n">false</span>  <span class="c1"># Pas de cycle</span>

<span class="n">function</span> <span class="n">BFS_Visit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="nb">map</span><span class="p">()</span>
    
    <span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">neighbor</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">true</span>  <span class="c1"># Cycle détecté</span>
    
    <span class="k">return</span> <span class="n">false</span>
</pre></div>
</div>
</section>
<section id="id3">
<h4>Avantages<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Efficacité</strong> : Complexité O(V+E)</p></li>
<li><p><strong>Consommation mémoire</strong> : Utilise une file au lieu d’une pile de récursion</p></li>
<li><p><strong>Cycles courts</strong> : Trouve d’abord les cycles les plus courts</p></li>
</ul>
</section>
<section id="id4">
<h4>Inconvénients<a class="headerlink" href="#id4" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Complexité d’implémentation</strong> : Plus complexe pour la détection de cycles</p></li>
<li><p><strong>Identification des cycles</strong> : Plus difficile d’identifier tous les nœuds d’un cycle</p></li>
</ul>
</section>
</section>
<section id="algorithme-de-tarjan">
<h3>3. Algorithme de Tarjan<a class="headerlink" href="#algorithme-de-tarjan" title="Link to this heading"></a></h3>
<section id="id5">
<h4>Principe<a class="headerlink" href="#id5" title="Link to this heading"></a></h4>
<p>L’algorithme de Tarjan est une variante optimisée du DFS qui permet de trouver les composantes fortement connexes (SCC) d’un graphe dirigé. Une composante fortement connexe contenant plus d’un nœud ou une boucle sur un nœud indique la présence d’un cycle.</p>
</section>
<section id="id6">
<h4>Pseudocode<a class="headerlink" href="#id6" title="Link to this heading"></a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">Tarjan</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">empty</span> <span class="n">stack</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">map</span><span class="p">()</span>  <span class="c1"># Indice de découverte</span>
    <span class="n">lowlinks</span> <span class="o">=</span> <span class="nb">map</span><span class="p">()</span> <span class="c1"># Plus petit indice accessible</span>
    <span class="n">onStack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Nœuds actuellement dans la pile</span>
    <span class="n">sccs</span> <span class="o">=</span> <span class="p">[]</span>        <span class="c1"># Composantes fortement connexes</span>
    
    <span class="k">for</span> <span class="n">each</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">StrongConnect</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lowlinks</span><span class="p">,</span> <span class="n">onStack</span><span class="p">,</span> <span class="n">sccs</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sccs</span>

<span class="n">function</span> <span class="n">StrongConnect</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lowlinks</span><span class="p">,</span> <span class="n">onStack</span><span class="p">,</span> <span class="n">sccs</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
    <span class="n">lowlinks</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">onStack</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">StrongConnect</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lowlinks</span><span class="p">,</span> <span class="n">onStack</span><span class="p">,</span> <span class="n">sccs</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
            <span class="n">lowlinks</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lowlinks</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">lowlinks</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">onStack</span><span class="p">:</span>
            <span class="n">lowlinks</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lowlinks</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">lowlinks</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="n">scc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">true</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">onStack</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">scc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">sccs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id7">
<h4>Avantages<a class="headerlink" href="#id7" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Efficacité</strong> : Complexité O(V+E)</p></li>
<li><p><strong>Complet</strong> : Trouve toutes les composantes fortement connexes en une passe</p></li>
<li><p><strong>Information riche</strong> : Fournit plus d’informations sur la structure du graphe</p></li>
</ul>
</section>
<section id="id8">
<h4>Inconvénients<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Complexité d’implémentation</strong> : Plus difficile à implémenter et à comprendre</p></li>
<li><p><strong>Overhead mémoire</strong> : Utilise plus de structures de données auxiliaires</p></li>
</ul>
</section>
</section>
<section id="algorithme-de-detection-de-cycle-par-coloration">
<h3>4. Algorithme de détection de cycle par coloration<a class="headerlink" href="#algorithme-de-detection-de-cycle-par-coloration" title="Link to this heading"></a></h3>
<section id="id9">
<h4>Principe<a class="headerlink" href="#id9" title="Link to this heading"></a></h4>
<p>Cet algorithme utilise trois couleurs pour marquer les nœuds :</p>
<ul class="simple">
<li><p>Blanc : Nœud non visité</p></li>
<li><p>Gris : Nœud en cours de visite (dans la pile de récursion)</p></li>
<li><p>Noir : Nœud complètement visité</p></li>
</ul>
<p>Si un nœud gris est rencontré pendant la visite, alors un cycle est détecté.</p>
</section>
<section id="id10">
<h4>Pseudocode<a class="headerlink" href="#id10" title="Link to this heading"></a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">ColorCycleDetection</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="nb">map</span><span class="p">()</span>  <span class="c1"># Tous les nœuds sont initialement blancs</span>
    
    <span class="k">for</span> <span class="n">each</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DFS_Color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">true</span>  <span class="c1"># Cycle détecté</span>
    
    <span class="k">return</span> <span class="n">false</span>  <span class="c1"># Pas de cycle</span>

<span class="n">function</span> <span class="n">DFS_Color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="n">colors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;GRAY&quot;</span>  <span class="c1"># En cours de visite</span>
    
    <span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DFS_Color</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">true</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">colors</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;GRAY&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">true</span>  <span class="c1"># Cycle détecté</span>
    
    <span class="n">colors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;BLACK&quot;</span>  <span class="c1"># Complètement visité</span>
    <span class="k">return</span> <span class="n">false</span>
</pre></div>
</div>
</section>
<section id="id11">
<h4>Avantages<a class="headerlink" href="#id11" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Clarté</strong> : Facile à comprendre conceptuellement</p></li>
<li><p><strong>Efficacité</strong> : Complexité O(V+E)</p></li>
<li><p><strong>Détection précise</strong> : Identifie exactement où se trouve le cycle</p></li>
</ul>
</section>
<section id="id12">
<h4>Inconvénients<a class="headerlink" href="#id12" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Similaire au DFS standard</strong> : N’offre pas d’avantages significatifs par rapport au DFS avec ensemble de récursion</p></li>
</ul>
</section>
</section>
</section>
<section id="comparaison-des-algorithmes">
<h2>Comparaison des algorithmes<a class="headerlink" href="#comparaison-des-algorithmes" title="Link to this heading"></a></h2>
<table border="1" class="docutils">
<thead>
<tr>
<th>Algorithme</th>
<th>Complexité temporelle</th>
<th>Complexité spatiale</th>
<th>Facilité d'implémentation</th>
<th>Détection précise des cycles</th>
<th>Adaptabilité aux grands graphes</th>
</tr>
</thead>
<tbody>
<tr>
<td>DFS</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>Élevée</td>
<td>Élevée</td>
<td>Moyenne</td>
</tr>
<tr>
<td>BFS</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>Moyenne</td>
<td>Moyenne</td>
<td>Élevée</td>
</tr>
<tr>
<td>Tarjan</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>Faible</td>
<td>Élevée</td>
<td>Élevée</td>
</tr>
<tr>
<td>Coloration</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>Élevée</td>
<td>Élevée</td>
<td>Moyenne</td>
</tr>
</tbody>
</table></section>
<section id="recommandation-pour-notre-cas-d-usage">
<h2>Recommandation pour notre cas d’usage<a class="headerlink" href="#recommandation-pour-notre-cas-d-usage" title="Link to this heading"></a></h2>
<p>Pour le module <code class="docutils literal notranslate"><span class="pre">CycleDetector.psm1</span></code>, l’algorithme <strong>DFS (Depth-First Search)</strong> est recommandé pour les raisons suivantes :</p>
<ol class="simple">
<li><p><strong>Simplicité d’implémentation</strong> : Facile à implémenter en PowerShell, même avec ses limitations en termes de récursion.</p></li>
<li><p><strong>Efficacité</strong> : Performances optimales pour la détection de cycles.</p></li>
<li><p><strong>Précision</strong> : Permet d’identifier exactement les nœuds impliqués dans un cycle.</p></li>
<li><p><strong>Adaptabilité</strong> : Peut être modifié pour retourner le chemin complet du cycle.</p></li>
<li><p><strong>Compatibilité</strong> : Bien adapté aux différents types de graphes que nous devons analyser (dépendances de scripts, workflows n8n).</p></li>
</ol>
<p>Pour les très grands graphes (&gt;10 000 nœuds), des optimisations seront nécessaires :</p>
<ul class="simple">
<li><p>Implémentation itérative pour éviter les problèmes de débordement de pile</p></li>
<li><p>Mise en cache des résultats intermédiaires</p></li>
<li><p>Possibilité de limiter la profondeur de recherche</p></li>
</ul>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading"></a></h2>
<p>L’algorithme DFS représente le meilleur compromis entre simplicité d’implémentation, efficacité et précision pour notre cas d’usage. Il sera la base de notre implémentation du module <code class="docutils literal notranslate"><span class="pre">CycleDetector.psm1</span></code>.</p>
</section>
<section id="references">
<h2>Références<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<ol class="simple">
<li><p>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press.</p></li>
<li><p>Sedgewick, R., &amp; Wayne, K. (2011). Algorithms (4th ed.). Addison-Wesley Professional.</p></li>
<li><p>Tarjan, R. E. (1972). Depth-first search and linear graph algorithms. SIAM Journal on Computing, 1(2), 146-160.</p></li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, EMAIL_SENDER_1 Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>