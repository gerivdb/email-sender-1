# üöÄ **Prompt Structur√© pour Impl√©mentation M√©thodique du Plan-dev-v55**

## üìã **Structure du Workflow par Section**

### **üîÑ D√âBUT DE CHAQUE T√ÇCHE**

#### **1. V√©rification Pr√©-T√¢che**

```bash
# 1.1 V√©rifier √©tat des fichiers non suivis

git status --porcelain | Where-Object { $_ -match "^\?\?" } | Measure-Object | ForEach-Object { if ($_.Count -eq 0) { Write-Host "‚úÖ Aucun fichier non suivi" -ForegroundColor Green } else { Write-Host "‚ö†Ô∏è $($_.Count) fichiers non suivis d√©tect√©s" -ForegroundColor Yellow } }

# 1.2 Si fichiers non suivis d√©tect√©s

$untrackedFiles = git status --porcelain | Where-Object { $_ -match "^\?\?" }
if ($untrackedFiles.Count -gt 0) {
    Write-Host "‚ö†Ô∏è Fichiers non suivis d√©tect√©s - analyse requise" -ForegroundColor Yellow
    git status
}
```plaintext
#### **2. Classification et Commit des Untracked Files**

```powershell
# Script PowerShell pour classification automatique

$untrackedFiles = git status --porcelain | Where-Object { $_ -match "^\?\?" }

if ($untrackedFiles.Count -gt 0) {
    Write-Host "üìÅ Classification des fichiers non suivis:" -ForegroundColor Cyan
    
    # Cr√©er hashtable pour regrouper par domaine

    $domainGroups = @{}
    
    foreach ($file in $untrackedFiles) {
        $filePath = $file.Substring(3)  # Enlever "?? "

        
        # D√©terminer domaine th√©matique

        $domain = switch -Regex ($filePath) {
            "^tools/" { "sync-tools" }
            "^config/" { "configuration" }
            "^docs/" { "documentation" }
            "^tests/" { "testing" }
            "^scripts/" { "automation" }
            "^web/" { "interface" }
            "\.ps1$" { "powershell-scripts" }
            "\.go$" { "core-development" }
            "\.md$" { "documentation" }
            "^\.github/" { "github-workflows" }
            "^planning-ecosystem-sync/" { "planning-sync" }
            default { "miscellaneous" }
        }
        
        if (-not $domainGroups.ContainsKey($domain)) {
            $domainGroups[$domain] = @()
        }
        $domainGroups[$domain] += $filePath
        
        Write-Host "  üìÑ $filePath ‚Üí $domain" -ForegroundColor Yellow
    }
    
    # Proposition de commits th√©matiques

    Write-Host "`nüí° Commits th√©matiques sugg√©r√©s:" -ForegroundColor Cyan
    foreach ($domain in $domainGroups.Keys) {
        $fileCount = $domainGroups[$domain].Count
        Write-Host "  üéØ $domain ($fileCount fichiers):" -ForegroundColor White
        Write-Host "     git add $($domainGroups[$domain] -join ' ')" -ForegroundColor Gray
        Write-Host "     git commit -m 'feat($domain): add untracked files for plan-dev-v55'" -ForegroundColor Gray
        Write-Host ""
    }
    
    # Demander confirmation pour commits automatiques

    $autoCommit = Read-Host "Effectuer les commits automatiquement? (y/N)"
    if ($autoCommit -eq 'y' -or $autoCommit -eq 'Y') {
        foreach ($domain in $domainGroups.Keys) {
            $files = $domainGroups[$domain] -join ' '
            git add $files
            git commit -m "feat($domain): add untracked files for plan-dev-v55

- Added $($domainGroups[$domain].Count) files in $domain domain
- Files: $($domainGroups[$domain] -join ', ')

Refs: plan-dev-v55-planning-ecosystem-sync.md"
            
            Write-Host "‚úÖ Commit cr√©√© pour domaine: $domain" -ForegroundColor Green
        }
    }
}
```plaintext
#### **3. V√©rification de la Branche Appropri√©e**

```powershell
# 3.1 Obtenir branche actuelle

$currentBranch = git branch --show-current

# 3.2 D√©terminer branche appropri√©e selon la t√¢che

$taskType = $env:TASK_TYPE
if (-not $taskType) {
    $taskType = Read-Host "Type de t√¢che (plan-dev-v55/sync-tools/validation/documentation)"
}

$targetBranch = switch ($taskType) {
    "plan-dev-v55" { "planning-ecosystem-sync" }
    "sync-tools" { "planning-ecosystem-sync" }
    "validation" { "planning-ecosystem-sync" }
    "documentation" { "planning-ecosystem-sync" }
    "testing" { "planning-ecosystem-sync" }
    "interface" { "planning-ecosystem-sync" }
    default { "planning-ecosystem-sync" }
}

# 3.3 V√©rifier et changer de branche si n√©cessaire

if ($currentBranch -ne $targetBranch) {
    Write-Host "üîÑ Changement de branche: $currentBranch ‚Üí $targetBranch" -ForegroundColor Yellow
    
    # V√©rifier si la branche existe

    $branchExists = git branch --list $targetBranch
    if ($branchExists) {
        git checkout $targetBranch
    } else {
        Write-Host "üìù Cr√©ation de la nouvelle branche: $targetBranch" -ForegroundColor Cyan
        git checkout -b $targetBranch
    }
    
    if ($LASTEXITCODE -eq 0) {
        Write-Host "‚úÖ Basculement r√©ussi vers: $targetBranch" -ForegroundColor Green
    } else {
        Write-Host "‚ùå √âchec du basculement vers: $targetBranch" -ForegroundColor Red
        exit 1
    }
}

$currentBranch = git branch --show-current
Write-Host "‚úÖ Branche active: $currentBranch" -ForegroundColor Green
```plaintext
---

### **‚úÖ FIN DE CHAQUE T√ÇCHE**

#### **4. Commit de la T√¢che Termin√©e**

```powershell
# 4.1 V√©rifier modifications en cours

git add .

# 4.2 Status avant commit

Write-Host "üìä √âtat avant commit:" -ForegroundColor Cyan
git status --short

# 4.3 Param√®tres du commit (√† adapter selon la t√¢che)

$taskId = $env:TASK_ID
$section = $env:SECTION
$description = $env:DESCRIPTION

if (-not $taskId) { $taskId = Read-Host "ID de la t√¢che (ex: 4.1.1.2)" }
if (-not $section) { $section = Read-Host "Section (ex: migration-assistant)" }
if (-not $description) { $description = Read-Host "Description courte" }

# 4.4 Commit avec message structur√©

$commitMessage = @"
feat($section): complete $taskId - $description

- ‚úÖ Impl√©mentation termin√©e
- ‚úÖ Tests passants  
- ‚úÖ Documentation mise √† jour
- ‚úÖ Code review effectu√©

Refs: plan-dev-v55-planning-ecosystem-sync.md#phase-4

"@

git commit -m $commitMessage

if ($LASTEXITCODE -eq 0) {
    $lastCommit = git log -1 --oneline
    Write-Host "‚úÖ Commit cr√©√©: $lastCommit" -ForegroundColor Green
} else {
    Write-Host "‚ùå √âchec de la cr√©ation du commit" -ForegroundColor Red
    exit 1
}
```plaintext
#### **5. Push vers la Branche Appropri√©e**

```powershell
# 5.1 Push avec suivi de la branche distante

$currentBranch = git branch --show-current
git push -u origin $currentBranch

# 5.2 V√©rification push

if ($LASTEXITCODE -eq 0) {
    Write-Host "üöÄ Push r√©ussi vers $currentBranch" -ForegroundColor Green
} else {
    Write-Host "‚ùå √âchec du push - intervention manuelle requise" -ForegroundColor Red
    Write-Host "V√©rifiez la connectivit√© r√©seau et les permissions" -ForegroundColor Yellow
}

# 5.3 Afficher hash du commit pour r√©f√©rence

$commitHash = git rev-parse --short HEAD
Write-Host "üìù Commit hash: $commitHash" -ForegroundColor Cyan
Write-Host "üåê URL commit: https://github.com/your-repo/commit/$commitHash" -ForegroundColor Blue
```plaintext
---

### **üìä FIN DE CHAQUE SECTION**

#### **6. Mise √† Jour du Plan-dev-v55**

```powershell
# Script de mise √† jour automatique des cases √† cocher

param(
    [string]$PlanFile = "projet\roadmaps\plans\consolidated\plan-dev-v55-planning-ecosystem-sync.md",
    [string]$Section,
    [string[]]$CompletedTasks
)

Write-Host "üìù Mise √† jour du plan: $Section" -ForegroundColor Green

# V√©rifier que le fichier existe

if (-not (Test-Path $PlanFile)) {
    Write-Error "‚ùå Fichier plan non trouv√©: $PlanFile"
    exit 1
}

# Lire le contenu du plan

$content = Get-Content $PlanFile -Raw -Encoding UTF8

# Sauvegarde avant modification

$backupFile = "$PlanFile.backup.$(Get-Date -Format 'yyyyMMdd-HHmmss')"
Copy-Item $PlanFile $backupFile
Write-Host "üíæ Backup cr√©√©: $backupFile" -ForegroundColor Blue

# Mise √† jour des cases √† cocher pour les t√¢ches termin√©es

$updatedCount = 0
foreach ($task in $CompletedTasks) {
    $pattern = "- \[ \] $([regex]::Escape($task))"
    $replacement = "- [x] $task"
    
    if ($content -match $pattern) {
        $content = $content -replace $pattern, $replacement
        $updatedCount++
        Write-Host "  ‚úÖ T√¢che coch√©e: $task" -ForegroundColor Green
    } else {
        Write-Host "  ‚ö†Ô∏è T√¢che non trouv√©e: $task" -ForegroundColor Yellow
    }
}

# Calculer nouvelle progression de la section si sp√©cifi√©e

if ($Section) {
    # Extraire la section sp√©cifique pour calculer la progression

    $sectionPattern = "### $([regex]::Escape($Section)).*?(?=###|\z)"

    $sectionMatch = [regex]::Match($content, $sectionPattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)
    
    if ($sectionMatch.Success) {
        $sectionContent = $sectionMatch.Value
        $totalTasks = ([regex]::Matches($sectionContent, "- \[[x ]\]")).Count
        $completedTasks = ([regex]::Matches($sectionContent, "- \[x\]")).Count
        
        if ($totalTasks -gt 0) {
            $progressPercent = [math]::Round(($completedTasks / $totalTasks) * 100, 0)
            
            # Mettre √† jour la progression de la section

            $progressPattern = "(\*Progression: )\d+(%)(\*)"
            $progressReplacement = "`${1}$progressPercent`${2}`${3}"
            $content = [regex]::Replace($content, $progressPattern, $progressReplacement)
            
            Write-Host "üìä Progression $Section: $completedTasks/$totalTasks ($progressPercent%)" -ForegroundColor Cyan
        }
    }
}

# Calculer progression globale

$allTasks = ([regex]::Matches($content, "- \[[x ]\]")).Count
$allCompleted = ([regex]::Matches($content, "- \[x\]")).Count
$globalProgress = if ($allTasks -gt 0) { [math]::Round(($allCompleted / $allTasks) * 100, 0) } else { 0 }

# Mettre √† jour progression globale

$globalPattern = "(\*\*Version.*?Progression globale : )\d+(%)(\*\*)"
$globalReplacement = "`${1}$globalProgress`${2}`${3}"
$content = [regex]::Replace($content, $globalPattern, $globalReplacement)

# Sauvegarder le fichier mis √† jour

Set-Content -Path $PlanFile -Value $content -Encoding UTF8

Write-Host "‚úÖ Plan mis √† jour - Progression globale: $globalProgress%" -ForegroundColor Cyan
Write-Host "üìà T√¢ches mises √† jour: $updatedCount" -ForegroundColor Green

# Commit de la mise √† jour du plan

git add $PlanFile
$planCommitMessage = @"
docs(planning): update progress for $Section - $globalProgress% global completion

- Updated task checkboxes: $updatedCount tasks completed
- Section progress updated
- Global progress: $globalProgress%

Refs: plan-dev-v55-planning-ecosystem-sync.md
"@

git commit -m $planCommitMessage

if ($LASTEXITCODE -eq 0) {
    Write-Host "üìä Progression commit√©e avec succ√®s" -ForegroundColor Green
    
    # Push automatique des mises √† jour du plan

    git push origin $(git branch --show-current)
    
    if ($LASTEXITCODE -eq 0) {
        Write-Host "üöÄ Mise √† jour du plan pouss√©e vers le remote" -ForegroundColor Green
    }
} else {
    Write-Host "‚ùå √âchec du commit de la mise √† jour" -ForegroundColor Red
}
```plaintext
---

## üéØ **Template de Prompt par Section**

### **Format Standardis√© pour Chaque Section**

```markdown
## üöÄ IMPL√âMENTATION SECTION [X.Y] - [NOM_SECTION]

### PR√â-REQUIS

- [ ] V√©rifier fichiers non suivis et les committer par domaine
- [ ] Confirmer branche: `planning-ecosystem-sync`
- [ ] √âtat propre du workspace: `git status`
- [ ] Variables d'environnement d√©finies:
  ```powershell
  $env:TASK_TYPE = "plan-dev-v55"
  $env:SECTION = "migration-assistant"
  $env:TASK_ID = "4.1.1.2"
  $env:DESCRIPTION = "Planification s√©quence de migration"
  ```

### T√ÇCHES √Ä IMPL√âMENTER

**Phase [X]**: [Nom Phase]
**Section [X.Y]**: [Nom Section]  
**Objectif**: [Description objectif]

#### T√¢che [X.Y.Z] - [Nom T√¢che]

- [ ] **Micro-√©tape [X.Y.Z.1]**: [Description]
  ```[language]
  [Code example avec contexte]
  ```
  - **Fichiers concern√©s**: `[liste des fichiers]`
  - **Tests requis**: [Description des tests]
  - **Crit√®res d'acceptation**: [Liste des crit√®res]

- [ ] **Micro-√©tape [X.Y.Z.2]**: [Description]
  - **D√©pendances**: [X.Y.Z.1]
  - **Estimation**: [temps estim√©]

### POST-IMPL√âMENTATION

- [ ] **Tests unitaires passants**: `go test ./... -v`
- [ ] **Linting propre**: `golangci-lint run`
- [ ] **Commit structur√©**: 
  ```
  feat(section-X-Y): complete [X.Y.Z] - [description]
  
  - ‚úÖ [D√©tail impl√©mentation]
  - ‚úÖ [Tests ajout√©s]
  - ‚úÖ [Documentation mise √† jour]
  
  Refs: plan-dev-v55-planning-ecosystem-sync.md#phase-X

  ```
- [ ] **Push vers branche**: `planning-ecosystem-sync`
- [ ] **Mise √† jour plan**: Cases √† cocher + progression
- [ ] **Nettoyage**: Aucun fichier non suivi restant

### VALIDATION

- [ ] **Fonctionnalit√© test√©e**: Manuel + automatique
- [ ] **Code review**: Si requis par l'√©quipe
- [ ] **Documentation √† jour**: Inline + externe
- [ ] **Int√©gration valid√©e**: Avec composants existants
- [ ] **Performance acceptable**: Selon m√©triques d√©finies
```plaintext
---

## üìã **Checklist Globale d'Application**

### **üîç Avant de Commencer une Section**

```powershell
# Checklist automatis√©e

Write-Host "üîç V√âRIFICATION PR√â-IMPL√âMENTATION" -ForegroundColor Cyan

# 1. √âtat workspace propre

$gitStatus = git status --porcelain
if ($gitStatus) {
    Write-Host "‚ö†Ô∏è Workspace non propre - fichiers modifi√©s d√©tect√©s" -ForegroundColor Yellow
    git status
} else {
    Write-Host "‚úÖ Workspace propre" -ForegroundColor Green
}

# 2. Branche correcte

$currentBranch = git branch --show-current
if ($currentBranch -eq "planning-ecosystem-sync") {
    Write-Host "‚úÖ Branche correcte: $currentBranch" -ForegroundColor Green
} else {
    Write-Host "‚ö†Ô∏è Branche incorrecte: $currentBranch (attendu: planning-ecosystem-sync)" -ForegroundColor Yellow
}

# 3. Derni√®re version du plan

$planFile = "projet\roadmaps\plans\consolidated\plan-dev-v55-planning-ecosystem-sync.md"
if (Test-Path $planFile) {
    $lastModified = (Get-Item $planFile).LastWriteTime
    Write-Host "‚úÖ Plan trouv√© - derni√®re modification: $lastModified" -ForegroundColor Green
} else {
    Write-Host "‚ùå Plan non trouv√©: $planFile" -ForegroundColor Red
}

# 4. Environnement Go fonctionnel

$goVersion = go version 2>$null
if ($goVersion) {
    Write-Host "‚úÖ Go disponible: $goVersion" -ForegroundColor Green
} else {
    Write-Host "‚ùå Go non disponible ou mal configur√©" -ForegroundColor Red
}

Write-Host "`nüöÄ PR√äT POUR L'IMPL√âMENTATION" -ForegroundColor Green
```plaintext
### **üîÑ Pendant l'Impl√©mentation**

1. **üîÑ Commits atomiques** - Une micro-t√¢che = un commit
2. **üîÑ Messages descriptifs** - Format standardis√© avec r√©f√©rence
3. **üîÑ Tests continus** - Validation apr√®s chaque modification
4. **üîÑ Documentation inline** - Code auto-document√© + commentaires

### **‚úÖ Fin de Section**

```powershell
# Checklist automatis√©e de fin de section

Write-Host "‚úÖ V√âRIFICATION POST-IMPL√âMENTATION" -ForegroundColor Cyan

# 1. Toutes t√¢ches commit√©es

$uncommittedFiles = git status --porcelain
if (-not $uncommittedFiles) {
    Write-Host "‚úÖ Toutes modifications commit√©es" -ForegroundColor Green
} else {
    Write-Host "‚ö†Ô∏è Fichiers non commit√©es:" -ForegroundColor Yellow
    git status --short
}

# 2. Push r√©ussi

$lastCommit = git log -1 --oneline
Write-Host "üìù Dernier commit: $lastCommit" -ForegroundColor Cyan

# 3. Tests section passent

Write-Host "üß™ Ex√©cution des tests..." -ForegroundColor Yellow
go test ./... -short
if ($LASTEXITCODE -eq 0) {
    Write-Host "‚úÖ Tous les tests passent" -ForegroundColor Green
} else {
    Write-Host "‚ùå Certains tests √©chouent" -ForegroundColor Red
}

# 4. Plan mis √† jour

$planContent = Get-Content $planFile -Raw
$completedTasks = ([regex]::Matches($planContent, "- \[x\]")).Count
$totalTasks = ([regex]::Matches($planContent, "- \[[x ]\]")).Count
$progress = [math]::Round(($completedTasks / $totalTasks) * 100, 0)

Write-Host "üìä Progression globale: $completedTasks/$totalTasks ($progress%)" -ForegroundColor Cyan
```plaintext
---

## üéØ **Application Pratique sur Plan-dev-v55**

### **Script Principal d'Ex√©cution**

```powershell
# implement-section.ps1

param(
    [Parameter(Mandatory=$true)]
    [string]$Section,
    
    [Parameter(Mandatory=$true)]
    [string]$TaskId,
    
    [string]$Description = "",
    [string]$PlanFile = "projet\roadmaps\plans\consolidated\plan-dev-v55-planning-ecosystem-sync.md",
    [string]$Branch = "planning-ecosystem-sync",
    [switch]$ValidateUntracked,
    [switch]$AutoCommit,
    [switch]$UpdateProgress
)

Write-Host "üöÄ IMPL√âMENTATION SECTION $Section - T√ÇCHE $TaskId" -ForegroundColor Cyan
Write-Host "üìù Description: $Description" -ForegroundColor White

# D√©finir variables d'environnement

$env:TASK_TYPE = "plan-dev-v55"
$env:SECTION = $Section
$env:TASK_ID = $TaskId
$env:DESCRIPTION = $Description

# 1. V√©rifications pr√©-impl√©mentation

Write-Host "`nüîç PHASE 1: V√©rifications pr√©-impl√©mentation" -ForegroundColor Yellow

if ($ValidateUntracked) {
    # Ex√©cuter script de gestion des fichiers non suivis

    & .\.github\prompts\planning\scripts\handle-untracked-files.ps1
}

# V√©rifier/changer de branche

& .\.github\prompts\planning\scripts\ensure-correct-branch.ps1 -TargetBranch $Branch

# 2. Phase d'impl√©mentation

Write-Host "`nüõ†Ô∏è PHASE 2: Impl√©mentation" -ForegroundColor Yellow
Write-Host "Veuillez impl√©menter la t√¢che $TaskId selon les sp√©cifications du plan." -ForegroundColor White
Write-Host "Appuyez sur Entr√©e quand l'impl√©mentation est termin√©e..."
Read-Host

# 3. Post-impl√©mentation

Write-Host "`n‚úÖ PHASE 3: Post-impl√©mentation" -ForegroundColor Yellow

if ($AutoCommit) {
    & .\.github\prompts\planning\scripts\commit-completed-task.ps1 -TaskId $TaskId -Section $Section -Description $Description
}

if ($UpdateProgress) {
    & .\.github\prompts\planning\scripts\update-plan-progress.ps1 -PlanFile $PlanFile -Section $Section -CompletedTasks @($TaskId)
}

Write-Host "`nüéâ IMPL√âMENTATION TERMIN√âE AVEC SUCC√àS!" -ForegroundColor Green
```plaintext
### **Utilisation Pratique**

```powershell
# Exemple d'utilisation pour la micro-√©tape 4.1.1.2

.\implement-section.ps1 `
  -Section "migration-assistant" `
  -TaskId "4.1.1.2" `
  -Description "Planification s√©quence de migration" `
  -ValidateUntracked `
  -AutoCommit `
  -UpdateProgress

# Pour une section compl√®te

$tasks = @("4.1.1.1", "4.1.1.2", "4.1.1.3", "4.1.1.4")
foreach ($task in $tasks) {
    .\implement-section.ps1 -Section "migration-assistant" -TaskId $task -ValidateUntracked -AutoCommit -UpdateProgress
    Write-Host "T√¢che $task termin√©e - Continuez avec la suivante..." -ForegroundColor Green
    Read-Host
}
```plaintext
---

## üìã **B√©n√©fices de ce Workflow**

### **üîí Tra√ßabilit√© et Qualit√©**

- **Historique complet** de chaque modification avec contexte
- **Messages de commit standardis√©s** pour faciliter le suivi
- **Branches th√©matiques** pour isoler les d√©veloppements
- **Validation automatique** √† chaque √©tape

### **üìä Suivi et Reporting**

- **Progression en temps r√©el** du plan de d√©veloppement
- **M√©triques automatis√©es** (commits, tests, couverture)
- **Dashboard** de l'√©tat du projet
- **Alertes** en cas de probl√®me

### **üöÄ Efficacit√© et Reproductibilit√©**

- **Workflow automatis√©** r√©duisant les erreurs manuelles
- **Scripts r√©utilisables** pour toutes les sections
- **Validation continue** √©vitant l'accumulation de dette technique
- **Documentation maintenue** automatiquement

### **üë• Collaboration d'√âquipe**

- **Standards uniformes** pour tous les d√©veloppeurs
- **Code reviews** facilit√©es par les commits atomiques
- **Int√©gration continue** avec validation automatique
- **Partage de connaissances** via la documentation

---

## Ce prompt garantit une impl√©mentation m√©thodique, tra√ßable et de haute qualit√© du plan-dev-v55 Planning Ecosystem Synchronization.